
HVAC.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001c62  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000048  00800060  00001c62  00001cf6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000083  008000a8  008000a8  00001d3e  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001d3e  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 000003a8  00000000  00000000  00001d6e  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00003b16  00000000  00000000  00002116  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 0000109d  00000000  00000000  00005c2c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000015aa  00000000  00000000  00006cc9  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000009d4  00000000  00000000  00008274  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00001001  00000000  00000000  00008c48  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0000291f  00000000  00000000  00009c49  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000368  00000000  00000000  0000c568  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 4a 00 	jmp	0x94	; 0x94 <__ctors_end>
       4:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
       8:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
       c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      10:	0c 94 46 0a 	jmp	0x148c	; 0x148c <__vector_4>
      14:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      18:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      1c:	0c 94 85 07 	jmp	0xf0a	; 0xf0a <__vector_7>
      20:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      24:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      28:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      2c:	0c 94 d5 0a 	jmp	0x15aa	; 0x15aa <__vector_11>
      30:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      34:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      38:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      3c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      40:	0c 94 b3 07 	jmp	0xf66	; 0xf66 <__vector_16>
      44:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      48:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      4c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      50:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>

00000054 <__trampolines_end>:
      54:	00 13       	cpse	r16, r16
      56:	1a 04       	cpc	r1, r10
      58:	0b 19       	sub	r16, r11
      5a:	00 00       	nop
      5c:	00 06       	cpc	r0, r16
      5e:	14 1f       	adc	r17, r20
      60:	05 0c       	add	r0, r5
      62:	00 00       	nop
      64:	00 13       	cpse	r16, r16
      66:	1e 04       	cpc	r1, r14
      68:	0f 19       	sub	r16, r15
      6a:	00 00       	nop
      6c:	00 06       	cpc	r0, r16
      6e:	14 1f       	adc	r17, r20
      70:	05 0c       	add	r0, r5
      72:	00 00       	nop
      74:	08 15       	cp	r16, r8
      76:	02 00       	.word	0x0002	; ????
      78:	08 15       	cp	r16, r8
      7a:	02 00       	.word	0x0002	; ????
      7c:	04 0a       	sbc	r0, r20
      7e:	11 00       	.word	0x0011	; ????
      80:	04 0a       	sbc	r0, r20
      82:	11 00       	.word	0x0011	; ????
      84:	02 15       	cp	r16, r2
      86:	08 00       	.word	0x0008	; ????
      88:	02 15       	cp	r16, r2
      8a:	08 00       	.word	0x0008	; ????
      8c:	11 0a       	sbc	r1, r17
      8e:	04 00       	.word	0x0004	; ????
      90:	11 0a       	sbc	r1, r17
      92:	04 00       	.word	0x0004	; ????

00000094 <__ctors_end>:
      94:	11 24       	eor	r1, r1
      96:	1f be       	out	0x3f, r1	; 63
      98:	cf e5       	ldi	r28, 0x5F	; 95
      9a:	d8 e0       	ldi	r29, 0x08	; 8
      9c:	de bf       	out	0x3e, r29	; 62
      9e:	cd bf       	out	0x3d, r28	; 61

000000a0 <__do_copy_data>:
      a0:	10 e0       	ldi	r17, 0x00	; 0
      a2:	a0 e6       	ldi	r26, 0x60	; 96
      a4:	b0 e0       	ldi	r27, 0x00	; 0
      a6:	e2 e6       	ldi	r30, 0x62	; 98
      a8:	fc e1       	ldi	r31, 0x1C	; 28
      aa:	02 c0       	rjmp	.+4      	; 0xb0 <__do_copy_data+0x10>
      ac:	05 90       	lpm	r0, Z+
      ae:	0d 92       	st	X+, r0
      b0:	a8 3a       	cpi	r26, 0xA8	; 168
      b2:	b1 07       	cpc	r27, r17
      b4:	d9 f7       	brne	.-10     	; 0xac <__do_copy_data+0xc>

000000b6 <__do_clear_bss>:
      b6:	21 e0       	ldi	r18, 0x01	; 1
      b8:	a8 ea       	ldi	r26, 0xA8	; 168
      ba:	b0 e0       	ldi	r27, 0x00	; 0
      bc:	01 c0       	rjmp	.+2      	; 0xc0 <.do_clear_bss_start>

000000be <.do_clear_bss_loop>:
      be:	1d 92       	st	X+, r1

000000c0 <.do_clear_bss_start>:
      c0:	ab 32       	cpi	r26, 0x2B	; 43
      c2:	b2 07       	cpc	r27, r18
      c4:	e1 f7       	brne	.-8      	; 0xbe <.do_clear_bss_loop>
      c6:	0e 94 b9 05 	call	0xb72	; 0xb72 <main>
      ca:	0c 94 2f 0e 	jmp	0x1c5e	; 0x1c5e <_exit>

000000ce <__bad_interrupt>:
      ce:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000d2 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
      d2:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
      d4:	03 96       	adiw	r24, 0x03	; 3
      d6:	92 83       	std	Z+2, r25	; 0x02
      d8:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
      da:	2f ef       	ldi	r18, 0xFF	; 255
      dc:	3f ef       	ldi	r19, 0xFF	; 255
      de:	34 83       	std	Z+4, r19	; 0x04
      e0:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
      e2:	96 83       	std	Z+6, r25	; 0x06
      e4:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
      e6:	90 87       	std	Z+8, r25	; 0x08
      e8:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
      ea:	10 82       	st	Z, r1
      ec:	08 95       	ret

000000ee <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
      ee:	fc 01       	movw	r30, r24
      f0:	11 86       	std	Z+9, r1	; 0x09
      f2:	10 86       	std	Z+8, r1	; 0x08
      f4:	08 95       	ret

000000f6 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
      f6:	cf 93       	push	r28
      f8:	df 93       	push	r29
      fa:	9c 01       	movw	r18, r24
      fc:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
      fe:	dc 01       	movw	r26, r24
     100:	11 96       	adiw	r26, 0x01	; 1
     102:	cd 91       	ld	r28, X+
     104:	dc 91       	ld	r29, X
     106:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     108:	d3 83       	std	Z+3, r29	; 0x03
     10a:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     10c:	8c 81       	ldd	r24, Y+4	; 0x04
     10e:	9d 81       	ldd	r25, Y+5	; 0x05
     110:	95 83       	std	Z+5, r25	; 0x05
     112:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     114:	8c 81       	ldd	r24, Y+4	; 0x04
     116:	9d 81       	ldd	r25, Y+5	; 0x05
     118:	dc 01       	movw	r26, r24
     11a:	13 96       	adiw	r26, 0x03	; 3
     11c:	7c 93       	st	X, r23
     11e:	6e 93       	st	-X, r22
     120:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     122:	7d 83       	std	Y+5, r23	; 0x05
     124:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     126:	31 87       	std	Z+9, r19	; 0x09
     128:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     12a:	f9 01       	movw	r30, r18
     12c:	80 81       	ld	r24, Z
     12e:	8f 5f       	subi	r24, 0xFF	; 255
     130:	80 83       	st	Z, r24
}
     132:	df 91       	pop	r29
     134:	cf 91       	pop	r28
     136:	08 95       	ret

00000138 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     138:	cf 93       	push	r28
     13a:	df 93       	push	r29
     13c:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     13e:	48 81       	ld	r20, Y
     140:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     142:	4f 3f       	cpi	r20, 0xFF	; 255
     144:	2f ef       	ldi	r18, 0xFF	; 255
     146:	52 07       	cpc	r21, r18
     148:	21 f4       	brne	.+8      	; 0x152 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     14a:	fc 01       	movw	r30, r24
     14c:	a7 81       	ldd	r26, Z+7	; 0x07
     14e:	b0 85       	ldd	r27, Z+8	; 0x08
     150:	0d c0       	rjmp	.+26     	; 0x16c <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     152:	dc 01       	movw	r26, r24
     154:	13 96       	adiw	r26, 0x03	; 3
     156:	12 96       	adiw	r26, 0x02	; 2
     158:	ed 91       	ld	r30, X+
     15a:	fc 91       	ld	r31, X
     15c:	13 97       	sbiw	r26, 0x03	; 3
     15e:	20 81       	ld	r18, Z
     160:	31 81       	ldd	r19, Z+1	; 0x01
     162:	42 17       	cp	r20, r18
     164:	53 07       	cpc	r21, r19
     166:	10 f0       	brcs	.+4      	; 0x16c <vListInsert+0x34>
     168:	df 01       	movw	r26, r30
     16a:	f5 cf       	rjmp	.-22     	; 0x156 <vListInsert+0x1e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     16c:	12 96       	adiw	r26, 0x02	; 2
     16e:	ed 91       	ld	r30, X+
     170:	fc 91       	ld	r31, X
     172:	13 97       	sbiw	r26, 0x03	; 3
     174:	fb 83       	std	Y+3, r31	; 0x03
     176:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     178:	d5 83       	std	Z+5, r29	; 0x05
     17a:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     17c:	bd 83       	std	Y+5, r27	; 0x05
     17e:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     180:	13 96       	adiw	r26, 0x03	; 3
     182:	dc 93       	st	X, r29
     184:	ce 93       	st	-X, r28
     186:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     188:	99 87       	std	Y+9, r25	; 0x09
     18a:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     18c:	fc 01       	movw	r30, r24
     18e:	20 81       	ld	r18, Z
     190:	2f 5f       	subi	r18, 0xFF	; 255
     192:	20 83       	st	Z, r18
}
     194:	df 91       	pop	r29
     196:	cf 91       	pop	r28
     198:	08 95       	ret

0000019a <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     19a:	cf 93       	push	r28
     19c:	df 93       	push	r29
     19e:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     1a0:	a0 85       	ldd	r26, Z+8	; 0x08
     1a2:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     1a4:	c2 81       	ldd	r28, Z+2	; 0x02
     1a6:	d3 81       	ldd	r29, Z+3	; 0x03
     1a8:	84 81       	ldd	r24, Z+4	; 0x04
     1aa:	95 81       	ldd	r25, Z+5	; 0x05
     1ac:	9d 83       	std	Y+5, r25	; 0x05
     1ae:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     1b0:	c4 81       	ldd	r28, Z+4	; 0x04
     1b2:	d5 81       	ldd	r29, Z+5	; 0x05
     1b4:	82 81       	ldd	r24, Z+2	; 0x02
     1b6:	93 81       	ldd	r25, Z+3	; 0x03
     1b8:	9b 83       	std	Y+3, r25	; 0x03
     1ba:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     1bc:	11 96       	adiw	r26, 0x01	; 1
     1be:	cd 91       	ld	r28, X+
     1c0:	dc 91       	ld	r29, X
     1c2:	12 97       	sbiw	r26, 0x02	; 2
     1c4:	ce 17       	cp	r28, r30
     1c6:	df 07       	cpc	r29, r31
     1c8:	31 f4       	brne	.+12     	; 0x1d6 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     1ca:	8c 81       	ldd	r24, Y+4	; 0x04
     1cc:	9d 81       	ldd	r25, Y+5	; 0x05
     1ce:	12 96       	adiw	r26, 0x02	; 2
     1d0:	9c 93       	st	X, r25
     1d2:	8e 93       	st	-X, r24
     1d4:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     1d6:	11 86       	std	Z+9, r1	; 0x09
     1d8:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     1da:	8c 91       	ld	r24, X
     1dc:	81 50       	subi	r24, 0x01	; 1
     1de:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     1e0:	df 91       	pop	r29
     1e2:	cf 91       	pop	r28
     1e4:	08 95       	ret

000001e6 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     1e6:	e0 91 cb 00 	lds	r30, 0x00CB
     1ea:	f0 91 cc 00 	lds	r31, 0x00CC
     1ee:	80 81       	ld	r24, Z
     1f0:	81 11       	cpse	r24, r1
     1f2:	07 c0       	rjmp	.+14     	; 0x202 <prvResetNextTaskUnblockTime+0x1c>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
     1f4:	8f ef       	ldi	r24, 0xFF	; 255
     1f6:	9f ef       	ldi	r25, 0xFF	; 255
     1f8:	90 93 ac 00 	sts	0x00AC, r25
     1fc:	80 93 ab 00 	sts	0x00AB, r24
     200:	08 95       	ret
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     202:	e0 91 cb 00 	lds	r30, 0x00CB
     206:	f0 91 cc 00 	lds	r31, 0x00CC
     20a:	05 80       	ldd	r0, Z+5	; 0x05
     20c:	f6 81       	ldd	r31, Z+6	; 0x06
     20e:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
     210:	06 80       	ldd	r0, Z+6	; 0x06
     212:	f7 81       	ldd	r31, Z+7	; 0x07
     214:	e0 2d       	mov	r30, r0
     216:	82 81       	ldd	r24, Z+2	; 0x02
     218:	93 81       	ldd	r25, Z+3	; 0x03
     21a:	90 93 ac 00 	sts	0x00AC, r25
     21e:	80 93 ab 00 	sts	0x00AB, r24
     222:	08 95       	ret

00000224 <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
     224:	0f 93       	push	r16
     226:	1f 93       	push	r17
     228:	cf 93       	push	r28
     22a:	df 93       	push	r29
     22c:	ec 01       	movw	r28, r24
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
     22e:	00 91 b3 00 	lds	r16, 0x00B3
     232:	10 91 b4 00 	lds	r17, 0x00B4
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
     236:	80 91 03 01 	lds	r24, 0x0103
     23a:	90 91 04 01 	lds	r25, 0x0104
     23e:	02 96       	adiw	r24, 0x02	; 2
     240:	0e 94 cd 00 	call	0x19a	; 0x19a <uxListRemove>
	#else /* INCLUDE_vTaskSuspend */
	{
		/* Calculate the time at which the task should be woken if the event
		does not occur.  This may overflow but this doesn't matter, the kernel
		will manage it correctly. */
		xTimeToWake = xConstTickCount + xTicksToWait;
     244:	c0 0f       	add	r28, r16
     246:	d1 1f       	adc	r29, r17

		/* The list item will be inserted in wake time order. */
		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
     248:	e0 91 03 01 	lds	r30, 0x0103
     24c:	f0 91 04 01 	lds	r31, 0x0104
     250:	d3 83       	std	Z+3, r29	; 0x03
     252:	c2 83       	std	Z+2, r28	; 0x02

		if( xTimeToWake < xConstTickCount )
     254:	c0 17       	cp	r28, r16
     256:	d1 07       	cpc	r29, r17
     258:	68 f4       	brcc	.+26     	; 0x274 <prvAddCurrentTaskToDelayedList+0x50>
		{
			/* Wake time has overflowed.  Place this item in the overflow list. */
			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     25a:	60 91 03 01 	lds	r22, 0x0103
     25e:	70 91 04 01 	lds	r23, 0x0104
     262:	80 91 c9 00 	lds	r24, 0x00C9
     266:	90 91 ca 00 	lds	r25, 0x00CA
     26a:	6e 5f       	subi	r22, 0xFE	; 254
     26c:	7f 4f       	sbci	r23, 0xFF	; 255
     26e:	0e 94 9c 00 	call	0x138	; 0x138 <vListInsert>
     272:	17 c0       	rjmp	.+46     	; 0x2a2 <prvAddCurrentTaskToDelayedList+0x7e>
		}
		else
		{
			/* The wake time has not overflowed, so the current block list is used. */
			vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     274:	60 91 03 01 	lds	r22, 0x0103
     278:	70 91 04 01 	lds	r23, 0x0104
     27c:	80 91 cb 00 	lds	r24, 0x00CB
     280:	90 91 cc 00 	lds	r25, 0x00CC
     284:	6e 5f       	subi	r22, 0xFE	; 254
     286:	7f 4f       	sbci	r23, 0xFF	; 255
     288:	0e 94 9c 00 	call	0x138	; 0x138 <vListInsert>

			/* If the task entering the blocked state was placed at the head of the
			list of blocked tasks then xNextTaskUnblockTime needs to be updated
			too. */
			if( xTimeToWake < xNextTaskUnblockTime )
     28c:	80 91 ab 00 	lds	r24, 0x00AB
     290:	90 91 ac 00 	lds	r25, 0x00AC
     294:	c8 17       	cp	r28, r24
     296:	d9 07       	cpc	r29, r25
     298:	20 f4       	brcc	.+8      	; 0x2a2 <prvAddCurrentTaskToDelayedList+0x7e>
			{
				xNextTaskUnblockTime = xTimeToWake;
     29a:	d0 93 ac 00 	sts	0x00AC, r29
     29e:	c0 93 ab 00 	sts	0x00AB, r28

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
     2a2:	df 91       	pop	r29
     2a4:	cf 91       	pop	r28
     2a6:	1f 91       	pop	r17
     2a8:	0f 91       	pop	r16
     2aa:	08 95       	ret

000002ac <xTaskCreate>:
							const char * const pcName,
							const uint16_t usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
     2ac:	4f 92       	push	r4
     2ae:	5f 92       	push	r5
     2b0:	6f 92       	push	r6
     2b2:	7f 92       	push	r7
     2b4:	8f 92       	push	r8
     2b6:	9f 92       	push	r9
     2b8:	af 92       	push	r10
     2ba:	bf 92       	push	r11
     2bc:	cf 92       	push	r12
     2be:	df 92       	push	r13
     2c0:	ef 92       	push	r14
     2c2:	ff 92       	push	r15
     2c4:	0f 93       	push	r16
     2c6:	cf 93       	push	r28
     2c8:	df 93       	push	r29
     2ca:	4c 01       	movw	r8, r24
     2cc:	6b 01       	movw	r12, r22
     2ce:	5a 01       	movw	r10, r20
     2d0:	29 01       	movw	r4, r18
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     2d2:	ca 01       	movw	r24, r20
     2d4:	0e 94 11 06 	call	0xc22	; 0xc22 <pvPortMalloc>
     2d8:	3c 01       	movw	r6, r24

			if( pxStack != NULL )
     2da:	00 97       	sbiw	r24, 0x00	; 0
     2dc:	09 f4       	brne	.+2      	; 0x2e0 <xTaskCreate+0x34>
     2de:	db c0       	rjmp	.+438    	; 0x496 <xTaskCreate+0x1ea>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
     2e0:	86 e2       	ldi	r24, 0x26	; 38
     2e2:	90 e0       	ldi	r25, 0x00	; 0
     2e4:	0e 94 11 06 	call	0xc22	; 0xc22 <pvPortMalloc>
     2e8:	ec 01       	movw	r28, r24

				if( pxNewTCB != NULL )
     2ea:	00 97       	sbiw	r24, 0x00	; 0
     2ec:	71 f0       	breq	.+28     	; 0x30a <xTaskCreate+0x5e>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
     2ee:	78 8e       	std	Y+24, r7	; 0x18
     2f0:	6f 8a       	std	Y+23, r6	; 0x17
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
     2f2:	81 e0       	ldi	r24, 0x01	; 1
     2f4:	a8 1a       	sub	r10, r24
     2f6:	b1 08       	sbc	r11, r1
     2f8:	6a 0c       	add	r6, r10
     2fa:	7b 1c       	adc	r7, r11
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
     2fc:	d6 01       	movw	r26, r12
     2fe:	8c 91       	ld	r24, X
     300:	89 8f       	std	Y+25, r24	; 0x19

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
     302:	8c 91       	ld	r24, X
     304:	81 11       	cpse	r24, r1
     306:	05 c0       	rjmp	.+10     	; 0x312 <xTaskCreate+0x66>
     308:	16 c0       	rjmp	.+44     	; 0x336 <xTaskCreate+0x8a>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
     30a:	c3 01       	movw	r24, r6
     30c:	0e 94 20 06 	call	0xc40	; 0xc40 <vPortFree>
     310:	c2 c0       	rjmp	.+388    	; 0x496 <xTaskCreate+0x1ea>
     312:	ae 01       	movw	r20, r28
     314:	46 5e       	subi	r20, 0xE6	; 230
     316:	5f 4f       	sbci	r21, 0xFF	; 255
     318:	f6 01       	movw	r30, r12
     31a:	31 96       	adiw	r30, 0x01	; 1
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
     31c:	21 e0       	ldi	r18, 0x01	; 1
     31e:	cf 01       	movw	r24, r30
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
     320:	31 91       	ld	r19, Z+
     322:	da 01       	movw	r26, r20
     324:	3d 93       	st	X+, r19
     326:	ad 01       	movw	r20, r26

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
     328:	dc 01       	movw	r26, r24
     32a:	8c 91       	ld	r24, X
     32c:	88 23       	and	r24, r24
     32e:	19 f0       	breq	.+6      	; 0x336 <xTaskCreate+0x8a>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
     330:	2f 5f       	subi	r18, 0xFF	; 255
     332:	28 30       	cpi	r18, 0x08	; 8
     334:	a1 f7       	brne	.-24     	; 0x31e <xTaskCreate+0x72>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
     336:	18 a2       	std	Y+32, r1	; 0x20
     338:	04 30       	cpi	r16, 0x04	; 4
     33a:	08 f0       	brcs	.+2      	; 0x33e <xTaskCreate+0x92>
     33c:	03 e0       	ldi	r16, 0x03	; 3
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
     33e:	0e 8b       	std	Y+22, r16	; 0x16
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
     340:	6e 01       	movw	r12, r28
     342:	b2 e0       	ldi	r27, 0x02	; 2
     344:	cb 0e       	add	r12, r27
     346:	d1 1c       	adc	r13, r1
     348:	c6 01       	movw	r24, r12
     34a:	0e 94 77 00 	call	0xee	; 0xee <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
     34e:	ce 01       	movw	r24, r28
     350:	0c 96       	adiw	r24, 0x0c	; 12
     352:	0e 94 77 00 	call	0xee	; 0xee <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
     356:	d9 87       	std	Y+9, r29	; 0x09
     358:	c8 87       	std	Y+8, r28	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     35a:	84 e0       	ldi	r24, 0x04	; 4
     35c:	90 e0       	ldi	r25, 0x00	; 0
     35e:	80 1b       	sub	r24, r16
     360:	91 09       	sbc	r25, r1
     362:	9d 87       	std	Y+13, r25	; 0x0d
     364:	8c 87       	std	Y+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
     366:	db 8b       	std	Y+19, r29	; 0x13
     368:	ca 8b       	std	Y+18, r28	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
     36a:	19 a2       	std	Y+33, r1	; 0x21
     36c:	1a a2       	std	Y+34, r1	; 0x22
     36e:	1b a2       	std	Y+35, r1	; 0x23
     370:	1c a2       	std	Y+36, r1	; 0x24
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
     372:	1d a2       	std	Y+37, r1	; 0x25
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
     374:	a2 01       	movw	r20, r4
     376:	b4 01       	movw	r22, r8
     378:	c3 01       	movw	r24, r6
     37a:	0e 94 2f 06 	call	0xc5e	; 0xc5e <pxPortInitialiseStack>
     37e:	99 83       	std	Y+1, r25	; 0x01
     380:	88 83       	st	Y, r24
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( ( void * ) pxCreatedTask != NULL )
     382:	e1 14       	cp	r14, r1
     384:	f1 04       	cpc	r15, r1
     386:	19 f0       	breq	.+6      	; 0x38e <xTaskCreate+0xe2>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
     388:	f7 01       	movw	r30, r14
     38a:	d1 83       	std	Z+1, r29	; 0x01
     38c:	c0 83       	st	Z, r28

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
     38e:	0f b6       	in	r0, 0x3f	; 63
     390:	f8 94       	cli
     392:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
     394:	80 91 b5 00 	lds	r24, 0x00B5
     398:	8f 5f       	subi	r24, 0xFF	; 255
     39a:	80 93 b5 00 	sts	0x00B5, r24
		if( pxCurrentTCB == NULL )
     39e:	80 91 03 01 	lds	r24, 0x0103
     3a2:	90 91 04 01 	lds	r25, 0x0104
     3a6:	89 2b       	or	r24, r25
     3a8:	a9 f5       	brne	.+106    	; 0x414 <xTaskCreate+0x168>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
     3aa:	d0 93 04 01 	sts	0x0104, r29
     3ae:	c0 93 03 01 	sts	0x0103, r28

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
     3b2:	80 91 b5 00 	lds	r24, 0x00B5
     3b6:	81 30       	cpi	r24, 0x01	; 1
     3b8:	e9 f5       	brne	.+122    	; 0x434 <xTaskCreate+0x188>
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
     3ba:	8f ed       	ldi	r24, 0xDF	; 223
     3bc:	90 e0       	ldi	r25, 0x00	; 0
     3be:	0e 94 69 00 	call	0xd2	; 0xd2 <vListInitialise>
     3c2:	88 ee       	ldi	r24, 0xE8	; 232
     3c4:	90 e0       	ldi	r25, 0x00	; 0
     3c6:	0e 94 69 00 	call	0xd2	; 0xd2 <vListInitialise>
     3ca:	81 ef       	ldi	r24, 0xF1	; 241
     3cc:	90 e0       	ldi	r25, 0x00	; 0
     3ce:	0e 94 69 00 	call	0xd2	; 0xd2 <vListInitialise>
     3d2:	8a ef       	ldi	r24, 0xFA	; 250
     3d4:	90 e0       	ldi	r25, 0x00	; 0
     3d6:	0e 94 69 00 	call	0xd2	; 0xd2 <vListInitialise>
	}

	vListInitialise( &xDelayedTaskList1 );
     3da:	86 ed       	ldi	r24, 0xD6	; 214
     3dc:	90 e0       	ldi	r25, 0x00	; 0
     3de:	0e 94 69 00 	call	0xd2	; 0xd2 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
     3e2:	8d ec       	ldi	r24, 0xCD	; 205
     3e4:	90 e0       	ldi	r25, 0x00	; 0
     3e6:	0e 94 69 00 	call	0xd2	; 0xd2 <vListInitialise>
	vListInitialise( &xPendingReadyList );
     3ea:	80 ec       	ldi	r24, 0xC0	; 192
     3ec:	90 e0       	ldi	r25, 0x00	; 0
     3ee:	0e 94 69 00 	call	0xd2	; 0xd2 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
     3f2:	87 eb       	ldi	r24, 0xB7	; 183
     3f4:	90 e0       	ldi	r25, 0x00	; 0
     3f6:	0e 94 69 00 	call	0xd2	; 0xd2 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
     3fa:	86 ed       	ldi	r24, 0xD6	; 214
     3fc:	90 e0       	ldi	r25, 0x00	; 0
     3fe:	90 93 cc 00 	sts	0x00CC, r25
     402:	80 93 cb 00 	sts	0x00CB, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
     406:	8d ec       	ldi	r24, 0xCD	; 205
     408:	90 e0       	ldi	r25, 0x00	; 0
     40a:	90 93 ca 00 	sts	0x00CA, r25
     40e:	80 93 c9 00 	sts	0x00C9, r24
     412:	10 c0       	rjmp	.+32     	; 0x434 <xTaskCreate+0x188>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
     414:	80 91 b1 00 	lds	r24, 0x00B1
     418:	81 11       	cpse	r24, r1
     41a:	0c c0       	rjmp	.+24     	; 0x434 <xTaskCreate+0x188>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
     41c:	e0 91 03 01 	lds	r30, 0x0103
     420:	f0 91 04 01 	lds	r31, 0x0104
     424:	96 89       	ldd	r25, Z+22	; 0x16
     426:	8e 89       	ldd	r24, Y+22	; 0x16
     428:	89 17       	cp	r24, r25
     42a:	20 f0       	brcs	.+8      	; 0x434 <xTaskCreate+0x188>
				{
					pxCurrentTCB = pxNewTCB;
     42c:	d0 93 04 01 	sts	0x0104, r29
     430:	c0 93 03 01 	sts	0x0103, r28
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
     434:	80 91 ad 00 	lds	r24, 0x00AD
     438:	8f 5f       	subi	r24, 0xFF	; 255
     43a:	80 93 ad 00 	sts	0x00AD, r24
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
     43e:	8e 89       	ldd	r24, Y+22	; 0x16
     440:	90 91 b2 00 	lds	r25, 0x00B2
     444:	98 17       	cp	r25, r24
     446:	10 f4       	brcc	.+4      	; 0x44c <xTaskCreate+0x1a0>
     448:	80 93 b2 00 	sts	0x00B2, r24
     44c:	90 e0       	ldi	r25, 0x00	; 0
     44e:	9c 01       	movw	r18, r24
     450:	22 0f       	add	r18, r18
     452:	33 1f       	adc	r19, r19
     454:	22 0f       	add	r18, r18
     456:	33 1f       	adc	r19, r19
     458:	22 0f       	add	r18, r18
     45a:	33 1f       	adc	r19, r19
     45c:	82 0f       	add	r24, r18
     45e:	93 1f       	adc	r25, r19
     460:	b6 01       	movw	r22, r12
     462:	81 52       	subi	r24, 0x21	; 33
     464:	9f 4f       	sbci	r25, 0xFF	; 255
     466:	0e 94 7b 00 	call	0xf6	; 0xf6 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
     46a:	0f 90       	pop	r0
     46c:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
     46e:	80 91 b1 00 	lds	r24, 0x00B1
     472:	88 23       	and	r24, r24
     474:	61 f0       	breq	.+24     	; 0x48e <xTaskCreate+0x1e2>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
     476:	e0 91 03 01 	lds	r30, 0x0103
     47a:	f0 91 04 01 	lds	r31, 0x0104
     47e:	96 89       	ldd	r25, Z+22	; 0x16
     480:	8e 89       	ldd	r24, Y+22	; 0x16
     482:	98 17       	cp	r25, r24
     484:	30 f4       	brcc	.+12     	; 0x492 <xTaskCreate+0x1e6>
		{
			taskYIELD_IF_USING_PREEMPTION();
     486:	0e 94 d0 06 	call	0xda0	; 0xda0 <vPortYield>
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
			prvAddNewTaskToReadyList( pxNewTCB );
			xReturn = pdPASS;
     48a:	81 e0       	ldi	r24, 0x01	; 1
     48c:	05 c0       	rjmp	.+10     	; 0x498 <xTaskCreate+0x1ec>
     48e:	81 e0       	ldi	r24, 0x01	; 1
     490:	03 c0       	rjmp	.+6      	; 0x498 <xTaskCreate+0x1ec>
     492:	81 e0       	ldi	r24, 0x01	; 1
     494:	01 c0       	rjmp	.+2      	; 0x498 <xTaskCreate+0x1ec>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     496:	8f ef       	ldi	r24, 0xFF	; 255
		}

		return xReturn;
	}
     498:	df 91       	pop	r29
     49a:	cf 91       	pop	r28
     49c:	0f 91       	pop	r16
     49e:	ff 90       	pop	r15
     4a0:	ef 90       	pop	r14
     4a2:	df 90       	pop	r13
     4a4:	cf 90       	pop	r12
     4a6:	bf 90       	pop	r11
     4a8:	af 90       	pop	r10
     4aa:	9f 90       	pop	r9
     4ac:	8f 90       	pop	r8
     4ae:	7f 90       	pop	r7
     4b0:	6f 90       	pop	r6
     4b2:	5f 90       	pop	r5
     4b4:	4f 90       	pop	r4
     4b6:	08 95       	ret

000004b8 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
     4b8:	ef 92       	push	r14
     4ba:	ff 92       	push	r15
     4bc:	0f 93       	push	r16
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
     4be:	0f 2e       	mov	r0, r31
     4c0:	f9 ea       	ldi	r31, 0xA9	; 169
     4c2:	ef 2e       	mov	r14, r31
     4c4:	f0 e0       	ldi	r31, 0x00	; 0
     4c6:	ff 2e       	mov	r15, r31
     4c8:	f0 2d       	mov	r31, r0
     4ca:	00 e0       	ldi	r16, 0x00	; 0
     4cc:	20 e0       	ldi	r18, 0x00	; 0
     4ce:	30 e0       	ldi	r19, 0x00	; 0
     4d0:	45 e5       	ldi	r20, 0x55	; 85
     4d2:	50 e0       	ldi	r21, 0x00	; 0
     4d4:	6a e6       	ldi	r22, 0x6A	; 106
     4d6:	70 e0       	ldi	r23, 0x00	; 0
     4d8:	8d ed       	ldi	r24, 0xDD	; 221
     4da:	93 e0       	ldi	r25, 0x03	; 3
     4dc:	0e 94 56 01 	call	0x2ac	; 0x2ac <xTaskCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
     4e0:	81 30       	cpi	r24, 0x01	; 1
     4e2:	81 f4       	brne	.+32     	; 0x504 <vTaskStartScheduler+0x4c>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
     4e4:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
     4e6:	8f ef       	ldi	r24, 0xFF	; 255
     4e8:	9f ef       	ldi	r25, 0xFF	; 255
     4ea:	90 93 ac 00 	sts	0x00AC, r25
     4ee:	80 93 ab 00 	sts	0x00AB, r24
		xSchedulerRunning = pdTRUE;
     4f2:	81 e0       	ldi	r24, 0x01	; 1
     4f4:	80 93 b1 00 	sts	0x00B1, r24
		xTickCount = ( TickType_t ) 0U;
     4f8:	10 92 b4 00 	sts	0x00B4, r1
     4fc:	10 92 b3 00 	sts	0x00B3, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
     500:	0e 94 9b 06 	call	0xd36	; 0xd36 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
     504:	0f 91       	pop	r16
     506:	ff 90       	pop	r15
     508:	ef 90       	pop	r14
     50a:	08 95       	ret

0000050c <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
     50c:	80 91 a8 00 	lds	r24, 0x00A8
     510:	8f 5f       	subi	r24, 0xFF	; 255
     512:	80 93 a8 00 	sts	0x00A8, r24
     516:	08 95       	ret

00000518 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
     518:	cf 92       	push	r12
     51a:	df 92       	push	r13
     51c:	ef 92       	push	r14
     51e:	ff 92       	push	r15
     520:	0f 93       	push	r16
     522:	1f 93       	push	r17
     524:	cf 93       	push	r28
     526:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     528:	80 91 a8 00 	lds	r24, 0x00A8
     52c:	81 11       	cpse	r24, r1
     52e:	98 c0       	rjmp	.+304    	; 0x660 <xTaskIncrementTick+0x148>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + 1;
     530:	e0 90 b3 00 	lds	r14, 0x00B3
     534:	f0 90 b4 00 	lds	r15, 0x00B4
     538:	8f ef       	ldi	r24, 0xFF	; 255
     53a:	e8 1a       	sub	r14, r24
     53c:	f8 0a       	sbc	r15, r24

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
     53e:	f0 92 b4 00 	sts	0x00B4, r15
     542:	e0 92 b3 00 	sts	0x00B3, r14

		if( xConstTickCount == ( TickType_t ) 0U )
     546:	e1 14       	cp	r14, r1
     548:	f1 04       	cpc	r15, r1
     54a:	b9 f4       	brne	.+46     	; 0x57a <xTaskIncrementTick+0x62>
		{
			taskSWITCH_DELAYED_LISTS();
     54c:	80 91 cb 00 	lds	r24, 0x00CB
     550:	90 91 cc 00 	lds	r25, 0x00CC
     554:	20 91 c9 00 	lds	r18, 0x00C9
     558:	30 91 ca 00 	lds	r19, 0x00CA
     55c:	30 93 cc 00 	sts	0x00CC, r19
     560:	20 93 cb 00 	sts	0x00CB, r18
     564:	90 93 ca 00 	sts	0x00CA, r25
     568:	80 93 c9 00 	sts	0x00C9, r24
     56c:	80 91 ae 00 	lds	r24, 0x00AE
     570:	8f 5f       	subi	r24, 0xFF	; 255
     572:	80 93 ae 00 	sts	0x00AE, r24
     576:	0e 94 f3 00 	call	0x1e6	; 0x1e6 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
     57a:	80 91 ab 00 	lds	r24, 0x00AB
     57e:	90 91 ac 00 	lds	r25, 0x00AC
     582:	e8 16       	cp	r14, r24
     584:	f9 06       	cpc	r15, r25
     586:	08 f4       	brcc	.+2      	; 0x58a <xTaskIncrementTick+0x72>
     588:	54 c0       	rjmp	.+168    	; 0x632 <xTaskIncrementTick+0x11a>
     58a:	d1 2c       	mov	r13, r1
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
						{
							xSwitchRequired = pdTRUE;
     58c:	cc 24       	eor	r12, r12
     58e:	c3 94       	inc	r12
     590:	01 c0       	rjmp	.+2      	; 0x594 <xTaskIncrementTick+0x7c>
     592:	dc 2c       	mov	r13, r12
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     594:	e0 91 cb 00 	lds	r30, 0x00CB
     598:	f0 91 cc 00 	lds	r31, 0x00CC
     59c:	80 81       	ld	r24, Z
     59e:	81 11       	cpse	r24, r1
     5a0:	07 c0       	rjmp	.+14     	; 0x5b0 <xTaskIncrementTick+0x98>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     5a2:	8f ef       	ldi	r24, 0xFF	; 255
     5a4:	9f ef       	ldi	r25, 0xFF	; 255
     5a6:	90 93 ac 00 	sts	0x00AC, r25
     5aa:	80 93 ab 00 	sts	0x00AB, r24
					break;
     5ae:	42 c0       	rjmp	.+132    	; 0x634 <xTaskIncrementTick+0x11c>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     5b0:	e0 91 cb 00 	lds	r30, 0x00CB
     5b4:	f0 91 cc 00 	lds	r31, 0x00CC
     5b8:	05 80       	ldd	r0, Z+5	; 0x05
     5ba:	f6 81       	ldd	r31, Z+6	; 0x06
     5bc:	e0 2d       	mov	r30, r0
     5be:	c6 81       	ldd	r28, Z+6	; 0x06
     5c0:	d7 81       	ldd	r29, Z+7	; 0x07
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
     5c2:	2a 81       	ldd	r18, Y+2	; 0x02
     5c4:	3b 81       	ldd	r19, Y+3	; 0x03

					if( xConstTickCount < xItemValue )
     5c6:	e2 16       	cp	r14, r18
     5c8:	f3 06       	cpc	r15, r19
     5ca:	28 f4       	brcc	.+10     	; 0x5d6 <xTaskIncrementTick+0xbe>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
     5cc:	30 93 ac 00 	sts	0x00AC, r19
     5d0:	20 93 ab 00 	sts	0x00AB, r18
						break;
     5d4:	2f c0       	rjmp	.+94     	; 0x634 <xTaskIncrementTick+0x11c>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     5d6:	8e 01       	movw	r16, r28
     5d8:	0e 5f       	subi	r16, 0xFE	; 254
     5da:	1f 4f       	sbci	r17, 0xFF	; 255
     5dc:	c8 01       	movw	r24, r16
     5de:	0e 94 cd 00 	call	0x19a	; 0x19a <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     5e2:	8c 89       	ldd	r24, Y+20	; 0x14
     5e4:	9d 89       	ldd	r25, Y+21	; 0x15
     5e6:	89 2b       	or	r24, r25
     5e8:	21 f0       	breq	.+8      	; 0x5f2 <xTaskIncrementTick+0xda>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     5ea:	ce 01       	movw	r24, r28
     5ec:	0c 96       	adiw	r24, 0x0c	; 12
     5ee:	0e 94 cd 00 	call	0x19a	; 0x19a <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
     5f2:	2e 89       	ldd	r18, Y+22	; 0x16
     5f4:	80 91 b2 00 	lds	r24, 0x00B2
     5f8:	82 17       	cp	r24, r18
     5fa:	10 f4       	brcc	.+4      	; 0x600 <xTaskIncrementTick+0xe8>
     5fc:	20 93 b2 00 	sts	0x00B2, r18
     600:	30 e0       	ldi	r19, 0x00	; 0
     602:	c9 01       	movw	r24, r18
     604:	88 0f       	add	r24, r24
     606:	99 1f       	adc	r25, r25
     608:	88 0f       	add	r24, r24
     60a:	99 1f       	adc	r25, r25
     60c:	88 0f       	add	r24, r24
     60e:	99 1f       	adc	r25, r25
     610:	82 0f       	add	r24, r18
     612:	93 1f       	adc	r25, r19
     614:	b8 01       	movw	r22, r16
     616:	81 52       	subi	r24, 0x21	; 33
     618:	9f 4f       	sbci	r25, 0xFF	; 255
     61a:	0e 94 7b 00 	call	0xf6	; 0xf6 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     61e:	e0 91 03 01 	lds	r30, 0x0103
     622:	f0 91 04 01 	lds	r31, 0x0104
     626:	9e 89       	ldd	r25, Y+22	; 0x16
     628:	86 89       	ldd	r24, Z+22	; 0x16
     62a:	98 17       	cp	r25, r24
     62c:	08 f0       	brcs	.+2      	; 0x630 <xTaskIncrementTick+0x118>
     62e:	b1 cf       	rjmp	.-158    	; 0x592 <xTaskIncrementTick+0x7a>
     630:	b1 cf       	rjmp	.-158    	; 0x594 <xTaskIncrementTick+0x7c>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
     632:	d1 2c       	mov	r13, r1
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
     634:	e0 91 03 01 	lds	r30, 0x0103
     638:	f0 91 04 01 	lds	r31, 0x0104
     63c:	86 89       	ldd	r24, Z+22	; 0x16
     63e:	90 e0       	ldi	r25, 0x00	; 0
     640:	fc 01       	movw	r30, r24
     642:	ee 0f       	add	r30, r30
     644:	ff 1f       	adc	r31, r31
     646:	ee 0f       	add	r30, r30
     648:	ff 1f       	adc	r31, r31
     64a:	ee 0f       	add	r30, r30
     64c:	ff 1f       	adc	r31, r31
     64e:	8e 0f       	add	r24, r30
     650:	9f 1f       	adc	r25, r31
     652:	fc 01       	movw	r30, r24
     654:	e1 52       	subi	r30, 0x21	; 33
     656:	ff 4f       	sbci	r31, 0xFF	; 255
     658:	80 81       	ld	r24, Z
     65a:	82 30       	cpi	r24, 0x02	; 2
     65c:	40 f4       	brcc	.+16     	; 0x66e <xTaskIncrementTick+0x156>
     65e:	09 c0       	rjmp	.+18     	; 0x672 <xTaskIncrementTick+0x15a>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
     660:	80 91 b0 00 	lds	r24, 0x00B0
     664:	8f 5f       	subi	r24, 0xFF	; 255
     666:	80 93 b0 00 	sts	0x00B0, r24

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
     66a:	d1 2c       	mov	r13, r1
     66c:	02 c0       	rjmp	.+4      	; 0x672 <xTaskIncrementTick+0x15a>
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
			{
				xSwitchRequired = pdTRUE;
     66e:	dd 24       	eor	r13, r13
     670:	d3 94       	inc	r13
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
     672:	80 91 af 00 	lds	r24, 0x00AF
     676:	88 23       	and	r24, r24
     678:	11 f0       	breq	.+4      	; 0x67e <xTaskIncrementTick+0x166>
		{
			xSwitchRequired = pdTRUE;
     67a:	dd 24       	eor	r13, r13
     67c:	d3 94       	inc	r13
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
     67e:	8d 2d       	mov	r24, r13
     680:	df 91       	pop	r29
     682:	cf 91       	pop	r28
     684:	1f 91       	pop	r17
     686:	0f 91       	pop	r16
     688:	ff 90       	pop	r15
     68a:	ef 90       	pop	r14
     68c:	df 90       	pop	r13
     68e:	cf 90       	pop	r12
     690:	08 95       	ret

00000692 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
     692:	df 92       	push	r13
     694:	ef 92       	push	r14
     696:	ff 92       	push	r15
     698:	0f 93       	push	r16
     69a:	1f 93       	push	r17
     69c:	cf 93       	push	r28
     69e:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
     6a0:	0f b6       	in	r0, 0x3f	; 63
     6a2:	f8 94       	cli
     6a4:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
     6a6:	80 91 a8 00 	lds	r24, 0x00A8
     6aa:	81 50       	subi	r24, 0x01	; 1
     6ac:	80 93 a8 00 	sts	0x00A8, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     6b0:	80 91 a8 00 	lds	r24, 0x00A8
     6b4:	81 11       	cpse	r24, r1
     6b6:	5e c0       	rjmp	.+188    	; 0x774 <xTaskResumeAll+0xe2>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
     6b8:	80 91 b5 00 	lds	r24, 0x00B5
     6bc:	88 23       	and	r24, r24
     6be:	09 f4       	brne	.+2      	; 0x6c2 <xTaskResumeAll+0x30>
     6c0:	5b c0       	rjmp	.+182    	; 0x778 <xTaskResumeAll+0xe6>
     6c2:	c0 e0       	ldi	r28, 0x00	; 0
     6c4:	d0 e0       	ldi	r29, 0x00	; 0
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     6c6:	0f 2e       	mov	r0, r31
     6c8:	f0 ec       	ldi	r31, 0xC0	; 192
     6ca:	ef 2e       	mov	r14, r31
     6cc:	f0 e0       	ldi	r31, 0x00	; 0
     6ce:	ff 2e       	mov	r15, r31
     6d0:	f0 2d       	mov	r31, r0

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
     6d2:	dd 24       	eor	r13, r13
     6d4:	d3 94       	inc	r13
     6d6:	30 c0       	rjmp	.+96     	; 0x738 <xTaskResumeAll+0xa6>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
     6d8:	e0 91 c5 00 	lds	r30, 0x00C5
     6dc:	f0 91 c6 00 	lds	r31, 0x00C6
     6e0:	c6 81       	ldd	r28, Z+6	; 0x06
     6e2:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     6e4:	ce 01       	movw	r24, r28
     6e6:	0c 96       	adiw	r24, 0x0c	; 12
     6e8:	0e 94 cd 00 	call	0x19a	; 0x19a <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     6ec:	8e 01       	movw	r16, r28
     6ee:	0e 5f       	subi	r16, 0xFE	; 254
     6f0:	1f 4f       	sbci	r17, 0xFF	; 255
     6f2:	c8 01       	movw	r24, r16
     6f4:	0e 94 cd 00 	call	0x19a	; 0x19a <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     6f8:	8e 89       	ldd	r24, Y+22	; 0x16
     6fa:	90 91 b2 00 	lds	r25, 0x00B2
     6fe:	98 17       	cp	r25, r24
     700:	10 f4       	brcc	.+4      	; 0x706 <xTaskResumeAll+0x74>
     702:	80 93 b2 00 	sts	0x00B2, r24
     706:	90 e0       	ldi	r25, 0x00	; 0
     708:	9c 01       	movw	r18, r24
     70a:	22 0f       	add	r18, r18
     70c:	33 1f       	adc	r19, r19
     70e:	22 0f       	add	r18, r18
     710:	33 1f       	adc	r19, r19
     712:	22 0f       	add	r18, r18
     714:	33 1f       	adc	r19, r19
     716:	82 0f       	add	r24, r18
     718:	93 1f       	adc	r25, r19
     71a:	b8 01       	movw	r22, r16
     71c:	81 52       	subi	r24, 0x21	; 33
     71e:	9f 4f       	sbci	r25, 0xFF	; 255
     720:	0e 94 7b 00 	call	0xf6	; 0xf6 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     724:	e0 91 03 01 	lds	r30, 0x0103
     728:	f0 91 04 01 	lds	r31, 0x0104
     72c:	9e 89       	ldd	r25, Y+22	; 0x16
     72e:	86 89       	ldd	r24, Z+22	; 0x16
     730:	98 17       	cp	r25, r24
     732:	10 f0       	brcs	.+4      	; 0x738 <xTaskResumeAll+0xa6>
					{
						xYieldPending = pdTRUE;
     734:	d0 92 af 00 	sts	0x00AF, r13
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     738:	f7 01       	movw	r30, r14
     73a:	80 81       	ld	r24, Z
     73c:	81 11       	cpse	r24, r1
     73e:	cc cf       	rjmp	.-104    	; 0x6d8 <xTaskResumeAll+0x46>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
     740:	cd 2b       	or	r28, r29
     742:	11 f0       	breq	.+4      	; 0x748 <xTaskResumeAll+0xb6>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
     744:	0e 94 f3 00 	call	0x1e6	; 0x1e6 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
     748:	c0 91 b0 00 	lds	r28, 0x00B0

					if( uxPendedCounts > ( UBaseType_t ) 0U )
     74c:	cc 23       	and	r28, r28
     74e:	51 f0       	breq	.+20     	; 0x764 <xTaskResumeAll+0xd2>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
							{
								xYieldPending = pdTRUE;
     750:	d1 e0       	ldi	r29, 0x01	; 1

					if( uxPendedCounts > ( UBaseType_t ) 0U )
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
     752:	0e 94 8c 02 	call	0x518	; 0x518 <xTaskIncrementTick>
     756:	81 11       	cpse	r24, r1
							{
								xYieldPending = pdTRUE;
     758:	d0 93 af 00 	sts	0x00AF, r29
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
     75c:	c1 50       	subi	r28, 0x01	; 1
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
     75e:	c9 f7       	brne	.-14     	; 0x752 <xTaskResumeAll+0xc0>

						uxPendedTicks = 0;
     760:	10 92 b0 00 	sts	0x00B0, r1
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
     764:	80 91 af 00 	lds	r24, 0x00AF
     768:	88 23       	and	r24, r24
     76a:	41 f0       	breq	.+16     	; 0x77c <xTaskResumeAll+0xea>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
     76c:	0e 94 d0 06 	call	0xda0	; 0xda0 <vPortYield>

				if( xYieldPending != pdFALSE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
     770:	81 e0       	ldi	r24, 0x01	; 1
     772:	05 c0       	rjmp	.+10     	; 0x77e <xTaskResumeAll+0xec>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB = NULL;
BaseType_t xAlreadyYielded = pdFALSE;
     774:	80 e0       	ldi	r24, 0x00	; 0
     776:	03 c0       	rjmp	.+6      	; 0x77e <xTaskResumeAll+0xec>
     778:	80 e0       	ldi	r24, 0x00	; 0
     77a:	01 c0       	rjmp	.+2      	; 0x77e <xTaskResumeAll+0xec>
     77c:	80 e0       	ldi	r24, 0x00	; 0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
     77e:	0f 90       	pop	r0
     780:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
     782:	df 91       	pop	r29
     784:	cf 91       	pop	r28
     786:	1f 91       	pop	r17
     788:	0f 91       	pop	r16
     78a:	ff 90       	pop	r15
     78c:	ef 90       	pop	r14
     78e:	df 90       	pop	r13
     790:	08 95       	ret

00000792 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
     792:	cf 93       	push	r28
     794:	df 93       	push	r29
     796:	ec 01       	movw	r28, r24
	BaseType_t xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
     798:	00 97       	sbiw	r24, 0x00	; 0
     79a:	51 f0       	breq	.+20     	; 0x7b0 <vTaskDelay+0x1e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
     79c:	0e 94 86 02 	call	0x50c	; 0x50c <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
     7a0:	60 e0       	ldi	r22, 0x00	; 0
     7a2:	ce 01       	movw	r24, r28
     7a4:	0e 94 12 01 	call	0x224	; 0x224 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
     7a8:	0e 94 49 03 	call	0x692	; 0x692 <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     7ac:	81 11       	cpse	r24, r1
     7ae:	02 c0       	rjmp	.+4      	; 0x7b4 <vTaskDelay+0x22>
		{
			portYIELD_WITHIN_API();
     7b0:	0e 94 d0 06 	call	0xda0	; 0xda0 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     7b4:	df 91       	pop	r29
     7b6:	cf 91       	pop	r28
     7b8:	08 95       	ret

000007ba <prvIdleTask>:

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
     7ba:	0f 2e       	mov	r0, r31
     7bc:	ff ed       	ldi	r31, 0xDF	; 223
     7be:	ef 2e       	mov	r14, r31
     7c0:	f0 e0       	ldi	r31, 0x00	; 0
     7c2:	ff 2e       	mov	r15, r31
     7c4:	f0 2d       	mov	r31, r0
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
     7c6:	c7 eb       	ldi	r28, 0xB7	; 183
     7c8:	d0 e0       	ldi	r29, 0x00	; 0
     7ca:	28 c0       	rjmp	.+80     	; 0x81c <prvIdleTask+0x62>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
     7cc:	0e 94 86 02 	call	0x50c	; 0x50c <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
     7d0:	18 81       	ld	r17, Y
			}
			( void ) xTaskResumeAll();
     7d2:	0e 94 49 03 	call	0x692	; 0x692 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
     7d6:	11 23       	and	r17, r17
     7d8:	09 f1       	breq	.+66     	; 0x81c <prvIdleTask+0x62>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
     7da:	0f b6       	in	r0, 0x3f	; 63
     7dc:	f8 94       	cli
     7de:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
     7e0:	e0 91 bc 00 	lds	r30, 0x00BC
     7e4:	f0 91 bd 00 	lds	r31, 0x00BD
     7e8:	06 81       	ldd	r16, Z+6	; 0x06
     7ea:	17 81       	ldd	r17, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     7ec:	c8 01       	movw	r24, r16
     7ee:	02 96       	adiw	r24, 0x02	; 2
     7f0:	0e 94 cd 00 	call	0x19a	; 0x19a <uxListRemove>
					--uxCurrentNumberOfTasks;
     7f4:	80 91 b5 00 	lds	r24, 0x00B5
     7f8:	81 50       	subi	r24, 0x01	; 1
     7fa:	80 93 b5 00 	sts	0x00B5, r24
					--uxDeletedTasksWaitingCleanUp;
     7fe:	80 91 b6 00 	lds	r24, 0x00B6
     802:	81 50       	subi	r24, 0x01	; 1
     804:	80 93 b6 00 	sts	0x00B6, r24
				}
				taskEXIT_CRITICAL();
     808:	0f 90       	pop	r0
     80a:	0f be       	out	0x3f, r0	; 63

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
     80c:	f8 01       	movw	r30, r16
     80e:	87 89       	ldd	r24, Z+23	; 0x17
     810:	90 8d       	ldd	r25, Z+24	; 0x18
     812:	0e 94 20 06 	call	0xc40	; 0xc40 <vPortFree>
			vPortFree( pxTCB );
     816:	c8 01       	movw	r24, r16
     818:	0e 94 20 06 	call	0xc40	; 0xc40 <vPortFree>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
     81c:	80 91 b6 00 	lds	r24, 0x00B6
     820:	81 11       	cpse	r24, r1
     822:	d4 cf       	rjmp	.-88     	; 0x7cc <prvIdleTask+0x12>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
     824:	f7 01       	movw	r30, r14
     826:	80 81       	ld	r24, Z
     828:	82 30       	cpi	r24, 0x02	; 2
     82a:	10 f0       	brcs	.+4      	; 0x830 <prvIdleTask+0x76>
			{
				taskYIELD();
     82c:	0e 94 d0 06 	call	0xda0	; 0xda0 <vPortYield>
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
     830:	0e 94 10 06 	call	0xc20	; 0xc20 <vApplicationIdleHook>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
     834:	f3 cf       	rjmp	.-26     	; 0x81c <prvIdleTask+0x62>

00000836 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
     836:	80 91 a8 00 	lds	r24, 0x00A8
     83a:	88 23       	and	r24, r24
     83c:	21 f0       	breq	.+8      	; 0x846 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
     83e:	81 e0       	ldi	r24, 0x01	; 1
     840:	80 93 af 00 	sts	0x00AF, r24
     844:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
     846:	10 92 af 00 	sts	0x00AF, r1
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
     84a:	20 91 b2 00 	lds	r18, 0x00B2
     84e:	82 2f       	mov	r24, r18
     850:	90 e0       	ldi	r25, 0x00	; 0
     852:	fc 01       	movw	r30, r24
     854:	ee 0f       	add	r30, r30
     856:	ff 1f       	adc	r31, r31
     858:	ee 0f       	add	r30, r30
     85a:	ff 1f       	adc	r31, r31
     85c:	ee 0f       	add	r30, r30
     85e:	ff 1f       	adc	r31, r31
     860:	e8 0f       	add	r30, r24
     862:	f9 1f       	adc	r31, r25
     864:	e1 52       	subi	r30, 0x21	; 33
     866:	ff 4f       	sbci	r31, 0xFF	; 255
     868:	30 81       	ld	r19, Z
     86a:	31 11       	cpse	r19, r1
     86c:	11 c0       	rjmp	.+34     	; 0x890 <__stack+0x31>
     86e:	21 50       	subi	r18, 0x01	; 1
     870:	82 2f       	mov	r24, r18
     872:	90 e0       	ldi	r25, 0x00	; 0
     874:	fc 01       	movw	r30, r24
     876:	ee 0f       	add	r30, r30
     878:	ff 1f       	adc	r31, r31
     87a:	ee 0f       	add	r30, r30
     87c:	ff 1f       	adc	r31, r31
     87e:	ee 0f       	add	r30, r30
     880:	ff 1f       	adc	r31, r31
     882:	e8 0f       	add	r30, r24
     884:	f9 1f       	adc	r31, r25
     886:	e1 52       	subi	r30, 0x21	; 33
     888:	ff 4f       	sbci	r31, 0xFF	; 255
     88a:	30 81       	ld	r19, Z
     88c:	33 23       	and	r19, r19
     88e:	79 f3       	breq	.-34     	; 0x86e <__stack+0xf>
     890:	fc 01       	movw	r30, r24
     892:	ee 0f       	add	r30, r30
     894:	ff 1f       	adc	r31, r31
     896:	ee 0f       	add	r30, r30
     898:	ff 1f       	adc	r31, r31
     89a:	ee 0f       	add	r30, r30
     89c:	ff 1f       	adc	r31, r31
     89e:	8e 0f       	add	r24, r30
     8a0:	9f 1f       	adc	r25, r31
     8a2:	fc 01       	movw	r30, r24
     8a4:	e1 52       	subi	r30, 0x21	; 33
     8a6:	ff 4f       	sbci	r31, 0xFF	; 255
     8a8:	a1 81       	ldd	r26, Z+1	; 0x01
     8aa:	b2 81       	ldd	r27, Z+2	; 0x02
     8ac:	12 96       	adiw	r26, 0x02	; 2
     8ae:	0d 90       	ld	r0, X+
     8b0:	bc 91       	ld	r27, X
     8b2:	a0 2d       	mov	r26, r0
     8b4:	b2 83       	std	Z+2, r27	; 0x02
     8b6:	a1 83       	std	Z+1, r26	; 0x01
     8b8:	cf 01       	movw	r24, r30
     8ba:	03 96       	adiw	r24, 0x03	; 3
     8bc:	a8 17       	cp	r26, r24
     8be:	b9 07       	cpc	r27, r25
     8c0:	31 f4       	brne	.+12     	; 0x8ce <__stack+0x6f>
     8c2:	12 96       	adiw	r26, 0x02	; 2
     8c4:	8d 91       	ld	r24, X+
     8c6:	9c 91       	ld	r25, X
     8c8:	13 97       	sbiw	r26, 0x03	; 3
     8ca:	92 83       	std	Z+2, r25	; 0x02
     8cc:	81 83       	std	Z+1, r24	; 0x01
     8ce:	01 80       	ldd	r0, Z+1	; 0x01
     8d0:	f2 81       	ldd	r31, Z+2	; 0x02
     8d2:	e0 2d       	mov	r30, r0
     8d4:	86 81       	ldd	r24, Z+6	; 0x06
     8d6:	97 81       	ldd	r25, Z+7	; 0x07
     8d8:	90 93 04 01 	sts	0x0104, r25
     8dc:	80 93 03 01 	sts	0x0103, r24
     8e0:	20 93 b2 00 	sts	0x00B2, r18
     8e4:	08 95       	ret

000008e6 <_LCD_OutNibble>:
// Funkcja wystawiajca pbajt na magistral danych
//
//-------------------------------------------------------------------------------------------------
void _LCD_OutNibble(unsigned char nibbleToWrite)
{
if(nibbleToWrite & 0x01)
     8e6:	80 ff       	sbrs	r24, 0
     8e8:	02 c0       	rjmp	.+4      	; 0x8ee <_LCD_OutNibble+0x8>
	LCD_DB4_PORT |= LCD_DB4;
     8ea:	ac 9a       	sbi	0x15, 4	; 21
     8ec:	01 c0       	rjmp	.+2      	; 0x8f0 <_LCD_OutNibble+0xa>
else
	LCD_DB4_PORT  &= ~LCD_DB4;
     8ee:	ac 98       	cbi	0x15, 4	; 21

if(nibbleToWrite & 0x02)
     8f0:	81 ff       	sbrs	r24, 1
     8f2:	02 c0       	rjmp	.+4      	; 0x8f8 <_LCD_OutNibble+0x12>
	LCD_DB5_PORT |= LCD_DB5;
     8f4:	ad 9a       	sbi	0x15, 5	; 21
     8f6:	01 c0       	rjmp	.+2      	; 0x8fa <_LCD_OutNibble+0x14>
else
	LCD_DB5_PORT  &= ~LCD_DB5;
     8f8:	ad 98       	cbi	0x15, 5	; 21

if(nibbleToWrite & 0x04)
     8fa:	82 ff       	sbrs	r24, 2
     8fc:	02 c0       	rjmp	.+4      	; 0x902 <_LCD_OutNibble+0x1c>
	LCD_DB6_PORT |= LCD_DB6;
     8fe:	ae 9a       	sbi	0x15, 6	; 21
     900:	01 c0       	rjmp	.+2      	; 0x904 <_LCD_OutNibble+0x1e>
else
	LCD_DB6_PORT  &= ~LCD_DB6;
     902:	ae 98       	cbi	0x15, 6	; 21

if(nibbleToWrite & 0x08)
     904:	83 ff       	sbrs	r24, 3
     906:	02 c0       	rjmp	.+4      	; 0x90c <_LCD_OutNibble+0x26>
	LCD_DB7_PORT |= LCD_DB7;
     908:	af 9a       	sbi	0x15, 7	; 21
     90a:	08 95       	ret
else
	LCD_DB7_PORT  &= ~LCD_DB7;
     90c:	af 98       	cbi	0x15, 7	; 21
     90e:	08 95       	ret

00000910 <_LCD_Write>:
//
// Funkcja zapisu bajtu do wywietacza (bez rozrnienia instrukcja/dane).
//
//-------------------------------------------------------------------------------------------------
void _LCD_Write(unsigned char dataToWrite)
{
     910:	cf 93       	push	r28
     912:	c8 2f       	mov	r28, r24
LCD_E_PORT |= LCD_E;
     914:	ab 9a       	sbi	0x15, 3	; 21
_LCD_OutNibble(dataToWrite >> 4);
     916:	82 95       	swap	r24
     918:	8f 70       	andi	r24, 0x0F	; 15
     91a:	0e 94 73 04 	call	0x8e6	; 0x8e6 <_LCD_OutNibble>
LCD_E_PORT &= ~LCD_E;
     91e:	ab 98       	cbi	0x15, 3	; 21
LCD_E_PORT |= LCD_E;
     920:	ab 9a       	sbi	0x15, 3	; 21
_LCD_OutNibble(dataToWrite);
     922:	8c 2f       	mov	r24, r28
     924:	0e 94 73 04 	call	0x8e6	; 0x8e6 <_LCD_OutNibble>
LCD_E_PORT &= ~LCD_E;
     928:	ab 98       	cbi	0x15, 3	; 21
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     92a:	87 ec       	ldi	r24, 0xC7	; 199
     92c:	90 e0       	ldi	r25, 0x00	; 0
     92e:	01 97       	sbiw	r24, 0x01	; 1
     930:	f1 f7       	brne	.-4      	; 0x92e <_LCD_Write+0x1e>
     932:	00 c0       	rjmp	.+0      	; 0x934 <_LCD_Write+0x24>
     934:	00 00       	nop
_delay_us(50);
}
     936:	cf 91       	pop	r28
     938:	08 95       	ret

0000093a <LCD_WriteCommand>:
// Funkcja zapisu rozkazu do wywietlacza
//
//-------------------------------------------------------------------------------------------------
void LCD_WriteCommand(unsigned char commandToWrite)
{
LCD_RS_PORT &= ~LCD_RS;
     93a:	aa 98       	cbi	0x15, 2	; 21
_LCD_Write(commandToWrite);
     93c:	0e 94 88 04 	call	0x910	; 0x910 <_LCD_Write>
     940:	08 95       	ret

00000942 <LCD_WriteData>:
// Funkcja zapisu danych do pamici wywietlacza
//
//-------------------------------------------------------------------------------------------------
void LCD_WriteData(unsigned char dataToWrite)
{
LCD_RS_PORT |= LCD_RS;
     942:	aa 9a       	sbi	0x15, 2	; 21
_LCD_Write(dataToWrite);
     944:	0e 94 88 04 	call	0x910	; 0x910 <_LCD_Write>
     948:	08 95       	ret

0000094a <LCD_WriteText>:
//
// Funkcja wywietlenia napisu na wyswietlaczu.
//
//-------------------------------------------------------------------------------------------------
void LCD_WriteText(char * text)
{
     94a:	cf 93       	push	r28
     94c:	df 93       	push	r29
     94e:	ec 01       	movw	r28, r24
while(*text)
     950:	88 81       	ld	r24, Y
     952:	88 23       	and	r24, r24
     954:	31 f0       	breq	.+12     	; 0x962 <LCD_WriteText+0x18>
     956:	21 96       	adiw	r28, 0x01	; 1
  LCD_WriteData(*text++);
     958:	0e 94 a1 04 	call	0x942	; 0x942 <LCD_WriteData>
// Funkcja wywietlenia napisu na wyswietlaczu.
//
//-------------------------------------------------------------------------------------------------
void LCD_WriteText(char * text)
{
while(*text)
     95c:	89 91       	ld	r24, Y+
     95e:	81 11       	cpse	r24, r1
     960:	fb cf       	rjmp	.-10     	; 0x958 <LCD_WriteText+0xe>
  LCD_WriteData(*text++);
}
     962:	df 91       	pop	r29
     964:	cf 91       	pop	r28
     966:	08 95       	ret

00000968 <LCD_GoTo>:
// Funkcja ustawienia wsprzdnych ekranowych
//
//-------------------------------------------------------------------------------------------------
void LCD_GoTo(unsigned char x, unsigned char y)
{
LCD_WriteCommand(HD44780_DDRAM_SET | (x + (0x40 * y)));
     968:	90 e4       	ldi	r25, 0x40	; 64
     96a:	69 9f       	mul	r22, r25
     96c:	80 0d       	add	r24, r0
     96e:	11 24       	eor	r1, r1
     970:	80 68       	ori	r24, 0x80	; 128
     972:	0e 94 9d 04 	call	0x93a	; 0x93a <LCD_WriteCommand>
     976:	08 95       	ret

00000978 <LCD_Clear>:
// Funkcja czyszczenia ekranu wywietlacza.
//
//-------------------------------------------------------------------------------------------------
void LCD_Clear(void)
{
LCD_WriteCommand(HD44780_CLEAR);
     978:	81 e0       	ldi	r24, 0x01	; 1
     97a:	0e 94 9d 04 	call	0x93a	; 0x93a <LCD_WriteCommand>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     97e:	8f e3       	ldi	r24, 0x3F	; 63
     980:	9f e1       	ldi	r25, 0x1F	; 31
     982:	01 97       	sbiw	r24, 0x01	; 1
     984:	f1 f7       	brne	.-4      	; 0x982 <LCD_Clear+0xa>
     986:	00 c0       	rjmp	.+0      	; 0x988 <LCD_Clear+0x10>
     988:	00 00       	nop
     98a:	08 95       	ret

0000098c <LCD_Initalize>:
//
// Procedura inicjalizacji kontrolera HD44780.
//
//-------------------------------------------------------------------------------------------------
void LCD_Initalize(void)
{
     98c:	cf 93       	push	r28
unsigned char i;
LCD_DB4_DIR |= LCD_DB4; // Konfiguracja kierunku pracy wyprowadze
     98e:	a4 9a       	sbi	0x14, 4	; 20
LCD_DB5_DIR |= LCD_DB5; //
     990:	a5 9a       	sbi	0x14, 5	; 20
LCD_DB6_DIR |= LCD_DB6; //
     992:	a6 9a       	sbi	0x14, 6	; 20
LCD_DB7_DIR |= LCD_DB7; //
     994:	a7 9a       	sbi	0x14, 7	; 20
LCD_E_DIR 	|= LCD_E;   //
     996:	a3 9a       	sbi	0x14, 3	; 20
LCD_RS_DIR 	|= LCD_RS;  //
     998:	a2 9a       	sbi	0x14, 2	; 20
     99a:	8f e5       	ldi	r24, 0x5F	; 95
     99c:	9a ee       	ldi	r25, 0xEA	; 234
     99e:	01 97       	sbiw	r24, 0x01	; 1
     9a0:	f1 f7       	brne	.-4      	; 0x99e <LCD_Initalize+0x12>
     9a2:	00 c0       	rjmp	.+0      	; 0x9a4 <LCD_Initalize+0x18>
     9a4:	00 00       	nop
_delay_ms(15); // oczekiwanie na ustalibizowanie si napiecia zasilajacego
LCD_RS_PORT &= ~LCD_RS; // wyzerowanie linii RS
     9a6:	aa 98       	cbi	0x15, 2	; 21
LCD_E_PORT &= ~LCD_E;  // wyzerowanie linii E
     9a8:	ab 98       	cbi	0x15, 3	; 21
     9aa:	c3 e0       	ldi	r28, 0x03	; 3

for(i = 0; i < 3; i++) // trzykrotne powtrzenie bloku instrukcji
  {
  LCD_E_PORT |= LCD_E; //  E = 1
     9ac:	ab 9a       	sbi	0x15, 3	; 21
  _LCD_OutNibble(0x03); // tryb 8-bitowy
     9ae:	83 e0       	ldi	r24, 0x03	; 3
     9b0:	0e 94 73 04 	call	0x8e6	; 0x8e6 <_LCD_OutNibble>
  LCD_E_PORT &= ~LCD_E; // E = 0
     9b4:	ab 98       	cbi	0x15, 3	; 21
     9b6:	8f e1       	ldi	r24, 0x1F	; 31
     9b8:	9e e4       	ldi	r25, 0x4E	; 78
     9ba:	01 97       	sbiw	r24, 0x01	; 1
     9bc:	f1 f7       	brne	.-4      	; 0x9ba <LCD_Initalize+0x2e>
     9be:	00 c0       	rjmp	.+0      	; 0x9c0 <LCD_Initalize+0x34>
     9c0:	00 00       	nop
     9c2:	c1 50       	subi	r28, 0x01	; 1
LCD_RS_DIR 	|= LCD_RS;  //
_delay_ms(15); // oczekiwanie na ustalibizowanie si napiecia zasilajacego
LCD_RS_PORT &= ~LCD_RS; // wyzerowanie linii RS
LCD_E_PORT &= ~LCD_E;  // wyzerowanie linii E

for(i = 0; i < 3; i++) // trzykrotne powtrzenie bloku instrukcji
     9c4:	99 f7       	brne	.-26     	; 0x9ac <LCD_Initalize+0x20>
  _LCD_OutNibble(0x03); // tryb 8-bitowy
  LCD_E_PORT &= ~LCD_E; // E = 0
  _delay_ms(5); // czekaj 5ms
  }

LCD_E_PORT |= LCD_E; // E = 1
     9c6:	ab 9a       	sbi	0x15, 3	; 21
_LCD_OutNibble(0x02); // tryb 4-bitowy
     9c8:	82 e0       	ldi	r24, 0x02	; 2
     9ca:	0e 94 73 04 	call	0x8e6	; 0x8e6 <_LCD_OutNibble>
LCD_E_PORT &= ~LCD_E; // E = 0
     9ce:	ab 98       	cbi	0x15, 3	; 21
     9d0:	8f e9       	ldi	r24, 0x9F	; 159
     9d2:	9f e0       	ldi	r25, 0x0F	; 15
     9d4:	01 97       	sbiw	r24, 0x01	; 1
     9d6:	f1 f7       	brne	.-4      	; 0x9d4 <LCD_Initalize+0x48>
     9d8:	00 c0       	rjmp	.+0      	; 0x9da <LCD_Initalize+0x4e>
     9da:	00 00       	nop

_delay_ms(1); // czekaj 1ms 
LCD_WriteCommand(HD44780_FUNCTION_SET | HD44780_FONT5x7 | HD44780_TWO_LINE | HD44780_4_BIT); // interfejs 4-bity, 2-linie, znak 5x7
     9dc:	88 e2       	ldi	r24, 0x28	; 40
     9de:	0e 94 9d 04 	call	0x93a	; 0x93a <LCD_WriteCommand>
LCD_WriteCommand(HD44780_DISPLAY_ONOFF | HD44780_DISPLAY_OFF); // wyczenie wyswietlacza
     9e2:	88 e0       	ldi	r24, 0x08	; 8
     9e4:	0e 94 9d 04 	call	0x93a	; 0x93a <LCD_WriteCommand>
LCD_WriteCommand(HD44780_CLEAR); // czyszczenie zawartosi pamieci DDRAM
     9e8:	81 e0       	ldi	r24, 0x01	; 1
     9ea:	0e 94 9d 04 	call	0x93a	; 0x93a <LCD_WriteCommand>
     9ee:	8f e3       	ldi	r24, 0x3F	; 63
     9f0:	9f e1       	ldi	r25, 0x1F	; 31
     9f2:	01 97       	sbiw	r24, 0x01	; 1
     9f4:	f1 f7       	brne	.-4      	; 0x9f2 <LCD_Initalize+0x66>
     9f6:	00 c0       	rjmp	.+0      	; 0x9f8 <LCD_Initalize+0x6c>
     9f8:	00 00       	nop
_delay_ms(2);
LCD_WriteCommand(HD44780_ENTRY_MODE | HD44780_EM_SHIFT_CURSOR | HD44780_EM_INCREMENT);// inkrementaja adresu i przesuwanie kursora
     9fa:	86 e0       	ldi	r24, 0x06	; 6
     9fc:	0e 94 9d 04 	call	0x93a	; 0x93a <LCD_WriteCommand>
LCD_WriteCommand(HD44780_DISPLAY_ONOFF | HD44780_DISPLAY_ON | HD44780_CURSOR_OFF | HD44780_CURSOR_NOBLINK); // wcz LCD, bez kursora i mrugania
     a00:	8c e0       	ldi	r24, 0x0C	; 12
     a02:	0e 94 9d 04 	call	0x93a	; 0x93a <LCD_WriteCommand>
}
     a06:	cf 91       	pop	r28
     a08:	08 95       	ret

00000a0a <LCD_AddCustomSymbol>:
//
//-------------------------------------------------------------------------------------------------


void LCD_AddCustomSymbol(int ram_adr, char *c)
{
     a0a:	0f 93       	push	r16
     a0c:	1f 93       	push	r17
     a0e:	cf 93       	push	r28
     a10:	df 93       	push	r29
	int i=0;
	for (i=0;i<8;i++)
	{
		LCD_WriteCommand(HD44780_CGRAM_SET|(ram_adr<<3)|i);
     a12:	88 0f       	add	r24, r24
     a14:	99 1f       	adc	r25, r25
     a16:	88 0f       	add	r24, r24
     a18:	99 1f       	adc	r25, r25
     a1a:	88 0f       	add	r24, r24
     a1c:	99 1f       	adc	r25, r25
     a1e:	08 2f       	mov	r16, r24
     a20:	00 64       	ori	r16, 0x40	; 64
     a22:	c6 2f       	mov	r28, r22
     a24:	d7 2f       	mov	r29, r23
     a26:	10 e0       	ldi	r17, 0x00	; 0
     a28:	81 2f       	mov	r24, r17
     a2a:	80 2b       	or	r24, r16
     a2c:	0e 94 9d 04 	call	0x93a	; 0x93a <LCD_WriteCommand>
		LCD_WriteData(c[i]);
     a30:	89 91       	ld	r24, Y+
     a32:	0e 94 a1 04 	call	0x942	; 0x942 <LCD_WriteData>
     a36:	1f 5f       	subi	r17, 0xFF	; 255


void LCD_AddCustomSymbol(int ram_adr, char *c)
{
	int i=0;
	for (i=0;i<8;i++)
     a38:	18 30       	cpi	r17, 0x08	; 8
     a3a:	b1 f7       	brne	.-20     	; 0xa28 <LCD_AddCustomSymbol+0x1e>
	{
		LCD_WriteCommand(HD44780_CGRAM_SET|(ram_adr<<3)|i);
		LCD_WriteData(c[i]);
	}
	LCD_WriteCommand(HD44780_ENTRY_MODE | HD44780_EM_SHIFT_CURSOR | HD44780_EM_INCREMENT);
     a3c:	86 e0       	ldi	r24, 0x06	; 6
     a3e:	0e 94 9d 04 	call	0x93a	; 0x93a <LCD_WriteCommand>
}
     a42:	df 91       	pop	r29
     a44:	cf 91       	pop	r28
     a46:	1f 91       	pop	r17
     a48:	0f 91       	pop	r16
     a4a:	08 95       	ret

00000a4c <LCD_FillGRAM>:
	}
};


void LCD_FillGRAM(void)
{
     a4c:	cf 92       	push	r12
     a4e:	df 92       	push	r13
     a50:	ef 92       	push	r14
     a52:	ff 92       	push	r15
     a54:	0f 93       	push	r16
     a56:	1f 93       	push	r17
     a58:	cf 93       	push	r28
     a5a:	df 93       	push	r29
     a5c:	cd b7       	in	r28, 0x3d	; 61
     a5e:	de b7       	in	r29, 0x3e	; 62
     a60:	28 97       	sbiw	r28, 0x08	; 8
     a62:	0f b6       	in	r0, 0x3f	; 63
     a64:	f8 94       	cli
     a66:	de bf       	out	0x3e, r29	; 62
     a68:	0f be       	out	0x3f, r0	; 63
     a6a:	cd bf       	out	0x3d, r28	; 61
     a6c:	0f 2e       	mov	r0, r31
     a6e:	f4 e5       	ldi	r31, 0x54	; 84
     a70:	cf 2e       	mov	r12, r31
     a72:	f0 e0       	ldi	r31, 0x00	; 0
     a74:	df 2e       	mov	r13, r31
     a76:	f0 2d       	mov	r31, r0
	char buffer[8];
	int i,j;
	for (i=0;i<8;i++)
     a78:	e1 2c       	mov	r14, r1
     a7a:	f1 2c       	mov	r15, r1
     a7c:	8e 01       	movw	r16, r28
     a7e:	07 5f       	subi	r16, 0xF7	; 247
     a80:	1f 4f       	sbci	r17, 0xFF	; 255
     a82:	16 c0       	rjmp	.+44     	; 0xab0 <LCD_FillGRAM+0x64>
	{
		for (j=0;j<8;j++)
		{
			#if defined(USE_PROGRAM_MEMORY)
			buffer[j] = pgm_read_byte_near(&(lcd_custom_sym[i][j]));
     a84:	84 91       	lpm	r24, Z
     a86:	8d 93       	st	X+, r24
     a88:	31 96       	adiw	r30, 0x01	; 1
{
	char buffer[8];
	int i,j;
	for (i=0;i<8;i++)
	{
		for (j=0;j<8;j++)
     a8a:	a0 17       	cp	r26, r16
     a8c:	b1 07       	cpc	r27, r17
     a8e:	d1 f7       	brne	.-12     	; 0xa84 <LCD_FillGRAM+0x38>
			buffer[j] = pgm_read_byte_near(&(lcd_custom_sym[i][j]));
			#else
			buffer[j] = lcd_custom_sym[i][j];
			#endif
		}
		LCD_AddCustomSymbol(i,buffer);
     a90:	be 01       	movw	r22, r28
     a92:	6f 5f       	subi	r22, 0xFF	; 255
     a94:	7f 4f       	sbci	r23, 0xFF	; 255
     a96:	c7 01       	movw	r24, r14
     a98:	0e 94 05 05 	call	0xa0a	; 0xa0a <LCD_AddCustomSymbol>

void LCD_FillGRAM(void)
{
	char buffer[8];
	int i,j;
	for (i=0;i<8;i++)
     a9c:	8f ef       	ldi	r24, 0xFF	; 255
     a9e:	e8 1a       	sub	r14, r24
     aa0:	f8 0a       	sbc	r15, r24
     aa2:	88 e0       	ldi	r24, 0x08	; 8
     aa4:	c8 0e       	add	r12, r24
     aa6:	d1 1c       	adc	r13, r1
     aa8:	88 e0       	ldi	r24, 0x08	; 8
     aaa:	e8 16       	cp	r14, r24
     aac:	f1 04       	cpc	r15, r1
     aae:	21 f0       	breq	.+8      	; 0xab8 <LCD_FillGRAM+0x6c>
     ab0:	de 01       	movw	r26, r28
     ab2:	11 96       	adiw	r26, 0x01	; 1
	}
};


void LCD_FillGRAM(void)
{
     ab4:	f6 01       	movw	r30, r12
     ab6:	e6 cf       	rjmp	.-52     	; 0xa84 <LCD_FillGRAM+0x38>
			#endif
		}
		LCD_AddCustomSymbol(i,buffer);
	}
	
}
     ab8:	28 96       	adiw	r28, 0x08	; 8
     aba:	0f b6       	in	r0, 0x3f	; 63
     abc:	f8 94       	cli
     abe:	de bf       	out	0x3e, r29	; 62
     ac0:	0f be       	out	0x3f, r0	; 63
     ac2:	cd bf       	out	0x3d, r28	; 61
     ac4:	df 91       	pop	r29
     ac6:	cf 91       	pop	r28
     ac8:	1f 91       	pop	r17
     aca:	0f 91       	pop	r16
     acc:	ff 90       	pop	r15
     ace:	ef 90       	pop	r14
     ad0:	df 90       	pop	r13
     ad2:	cf 90       	pop	r12
     ad4:	08 95       	ret

00000ad6 <temperature>:
{
	(void)pvParameters;
	char buf[4]="0000";
	for(;;)
	{
		auto_climate_control();
     ad6:	0e 94 2b 09 	call	0x1256	; 0x1256 <auto_climate_control>
		vTaskDelay(55);
     ada:	87 e3       	ldi	r24, 0x37	; 55
     adc:	90 e0       	ldi	r25, 0x00	; 0
     ade:	0e 94 c9 03 	call	0x792	; 0x792 <vTaskDelay>
     ae2:	f9 cf       	rjmp	.-14     	; 0xad6 <temperature>

00000ae4 <debug_>:
static void debug_(void *pvParameters)
{
	(void)pvParameters;
	for(;;)
	{
		debounce_D(&PINB);
     ae4:	86 e3       	ldi	r24, 0x36	; 54
     ae6:	90 e0       	ldi	r25, 0x00	; 0
     ae8:	0e 94 7a 09 	call	0x12f4	; 0x12f4 <debounce_D>
		vTaskDelay(3);
     aec:	83 e0       	ldi	r24, 0x03	; 3
     aee:	90 e0       	ldi	r25, 0x00	; 0
     af0:	0e 94 c9 03 	call	0x792	; 0x792 <vTaskDelay>
     af4:	f7 cf       	rjmp	.-18     	; 0xae4 <debug_>

00000af6 <display>:
		vTaskDelay(50*2);
	}
}
//______________________________________________________________________________________
static void display(void *pvParameters)
{
     af6:	cf 93       	push	r28
     af8:	df 93       	push	r29
     afa:	00 d0       	rcall	.+0      	; 0xafc <display+0x6>
     afc:	00 d0       	rcall	.+0      	; 0xafe <display+0x8>
     afe:	cd b7       	in	r28, 0x3d	; 61
     b00:	de b7       	in	r29, 0x3e	; 62
	(void)pvParameters;
	char buf[4]="0";
     b02:	80 e3       	ldi	r24, 0x30	; 48
     b04:	90 e0       	ldi	r25, 0x00	; 0
     b06:	a0 e0       	ldi	r26, 0x00	; 0
     b08:	b0 e0       	ldi	r27, 0x00	; 0
     b0a:	89 83       	std	Y+1, r24	; 0x01
     b0c:	9a 83       	std	Y+2, r25	; 0x02
     b0e:	ab 83       	std	Y+3, r26	; 0x03
     b10:	bc 83       	std	Y+4, r27	; 0x04
	for(;;)
	{
		
		
		
		display_phase();
     b12:	0e 94 d0 07 	call	0xfa0	; 0xfa0 <display_phase>
		
	
		set_pwm_pow_lvl(POW);
     b16:	80 91 1f 01 	lds	r24, 0x011F
     b1a:	86 95       	lsr	r24
     b1c:	83 70       	andi	r24, 0x03	; 3
     b1e:	0e 94 0e 0a 	call	0x141c	; 0x141c <set_pwm_pow_lvl>
		set_pwm_fan_lvl(FAN);
     b22:	80 91 1f 01 	lds	r24, 0x011F
     b26:	86 95       	lsr	r24
     b28:	86 95       	lsr	r24
     b2a:	86 95       	lsr	r24
     b2c:	83 70       	andi	r24, 0x03	; 3
     b2e:	0e 94 ef 09 	call	0x13de	; 0x13de <set_pwm_fan_lvl>
		
		//PORTD&=~((PORTD<<6)&PIND7);
				
				/*--------------------------------------------motor--feedback----------------------*/
				itoa(motor(),buf,10);
     b32:	0e 94 25 09 	call	0x124a	; 0x124a <motor>
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
     b36:	4a e0       	ldi	r20, 0x0A	; 10
     b38:	be 01       	movw	r22, r28
     b3a:	6f 5f       	subi	r22, 0xFF	; 255
     b3c:	7f 4f       	sbci	r23, 0xFF	; 255
     b3e:	99 27       	eor	r25, r25
     b40:	87 fd       	sbrc	r24, 7
     b42:	90 95       	com	r25
     b44:	0e 94 dd 0d 	call	0x1bba	; 0x1bba <__itoa_ncheck>
				LCD_GoTo(6,1);
     b48:	61 e0       	ldi	r22, 0x01	; 1
     b4a:	86 e0       	ldi	r24, 0x06	; 6
     b4c:	0e 94 b4 04 	call	0x968	; 0x968 <LCD_GoTo>
				LCD_WriteText("m_fb:");
     b50:	8f e6       	ldi	r24, 0x6F	; 111
     b52:	90 e0       	ldi	r25, 0x00	; 0
     b54:	0e 94 a5 04 	call	0x94a	; 0x94a <LCD_WriteText>
				LCD_GoTo(11,1);
     b58:	61 e0       	ldi	r22, 0x01	; 1
     b5a:	8b e0       	ldi	r24, 0x0B	; 11
     b5c:	0e 94 b4 04 	call	0x968	; 0x968 <LCD_GoTo>
				LCD_WriteText(buf);
     b60:	ce 01       	movw	r24, r28
     b62:	01 96       	adiw	r24, 0x01	; 1
     b64:	0e 94 a5 04 	call	0x94a	; 0x94a <LCD_WriteText>
				/*---------------------------------------------------------------------------------*/
		vTaskDelay(70);
     b68:	86 e4       	ldi	r24, 0x46	; 70
     b6a:	90 e0       	ldi	r25, 0x00	; 0
     b6c:	0e 94 c9 03 	call	0x792	; 0x792 <vTaskDelay>
     b70:	d0 cf       	rjmp	.-96     	; 0xb12 <display+0x1c>

00000b72 <main>:
static void debug_   (void *pvParameters);
static void temperature(void *pvParameters);
/*-----------------------------------------------------------*/

int main( void )
{
     b72:	ef 92       	push	r14
     b74:	ff 92       	push	r15
     b76:	0f 93       	push	r16
     b78:	cf 93       	push	r28
     b7a:	df 93       	push	r29
     b7c:	1f 92       	push	r1
     b7e:	cd b7       	in	r28, 0x3d	; 61
     b80:	de b7       	in	r29, 0x3e	; 62

static void prvIncrementResetCount( void )
{
unsigned char ucCount;

	eeprom_read_block( &ucCount, mainRESET_COUNT_ADDRESS, sizeof( ucCount ) );
     b82:	41 e0       	ldi	r20, 0x01	; 1
     b84:	50 e0       	ldi	r21, 0x00	; 0
     b86:	60 e5       	ldi	r22, 0x50	; 80
     b88:	70 e0       	ldi	r23, 0x00	; 0
     b8a:	ce 01       	movw	r24, r28
     b8c:	01 96       	adiw	r24, 0x01	; 1
     b8e:	0e 94 02 0e 	call	0x1c04	; 0x1c04 <__eerd_block_m32>
	ucCount++;
     b92:	69 81       	ldd	r22, Y+1	; 0x01
     b94:	6f 5f       	subi	r22, 0xFF	; 255
     b96:	69 83       	std	Y+1, r22	; 0x01
	eeprom_write_byte( mainRESET_COUNT_ADDRESS, ucCount );
     b98:	80 e5       	ldi	r24, 0x50	; 80
     b9a:	90 e0       	ldi	r25, 0x00	; 0
     b9c:	0e 94 12 0e 	call	0x1c24	; 0x1c24 <__eewr_byte_m32>
	
	
	
	//events|=128;
	
	DDRB=0;
     ba0:	17 ba       	out	0x17, r1	; 23
	PORTB=0xff;
     ba2:	8f ef       	ldi	r24, 0xFF	; 255
     ba4:	88 bb       	out	0x18, r24	; 24
	
	DDRD = 0xff;
     ba6:	81 bb       	out	0x11, r24	; 17
	PORTD=0xff;
     ba8:	82 bb       	out	0x12, r24	; 18
	
	DDRA=0;
     baa:	1a ba       	out	0x1a, r1	; 26
	PORTA=0xff;
     bac:	8b bb       	out	0x1b, r24	; 27
	
	desired_temp=20;
     bae:	84 e1       	ldi	r24, 0x14	; 20
     bb0:	80 93 25 01 	sts	0x0125, r24
	
	adc_init();
     bb4:	0e 94 88 07 	call	0xf10	; 0xf10 <adc_init>
	 
	init_timer2();
     bb8:	0e 94 36 0a 	call	0x146c	; 0x146c <init_timer2>
	init_timer0();
     bbc:	0e 94 2c 0a 	call	0x1458	; 0x1458 <init_timer0>
	 
	LCD_Initalize();
     bc0:	0e 94 c6 04 	call	0x98c	; 0x98c <LCD_Initalize>
	LCD_FillGRAM();
     bc4:	0e 94 26 05 	call	0xa4c	; 0xa4c <LCD_FillGRAM>

	/* Create the tasks defined within this file. */
	//xTaskCreate( vLCD_TASK, "LCD", configMINIMAL_STACK_SIZE, NULL, mainCHECK_TASK_PRIORITY, NULL );
	//xTaskCreate( tBlinkLED, "Blink", configMINIMAL_STACK_SIZE, NULL, mainCHECK_TASK_PRIORITY, NULL);
	xTaskCreate( display, "debug", configMINIMAL_STACK_SIZE, NULL, mainCHECK_TASK_PRIORITY, NULL);
     bc8:	e1 2c       	mov	r14, r1
     bca:	f1 2c       	mov	r15, r1
     bcc:	03 e0       	ldi	r16, 0x03	; 3
     bce:	20 e0       	ldi	r18, 0x00	; 0
     bd0:	30 e0       	ldi	r19, 0x00	; 0
     bd2:	45 e5       	ldi	r20, 0x55	; 85
     bd4:	50 e0       	ldi	r21, 0x00	; 0
     bd6:	65 e7       	ldi	r22, 0x75	; 117
     bd8:	70 e0       	ldi	r23, 0x00	; 0
     bda:	8b e7       	ldi	r24, 0x7B	; 123
     bdc:	95 e0       	ldi	r25, 0x05	; 5
     bde:	0e 94 56 01 	call	0x2ac	; 0x2ac <xTaskCreate>
	xTaskCreate( debug_, "debug_", configMINIMAL_STACK_SIZE, NULL, mainCHECK_TASK_PRIORITY, NULL);
     be2:	20 e0       	ldi	r18, 0x00	; 0
     be4:	30 e0       	ldi	r19, 0x00	; 0
     be6:	45 e5       	ldi	r20, 0x55	; 85
     be8:	50 e0       	ldi	r21, 0x00	; 0
     bea:	6b e7       	ldi	r22, 0x7B	; 123
     bec:	70 e0       	ldi	r23, 0x00	; 0
     bee:	82 e7       	ldi	r24, 0x72	; 114
     bf0:	95 e0       	ldi	r25, 0x05	; 5
     bf2:	0e 94 56 01 	call	0x2ac	; 0x2ac <xTaskCreate>
	xTaskCreate( temperature, "temperaturee", configMINIMAL_STACK_SIZE, NULL, mainCHECK_TASK_PRIORITY, NULL);
     bf6:	20 e0       	ldi	r18, 0x00	; 0
     bf8:	30 e0       	ldi	r19, 0x00	; 0
     bfa:	45 e5       	ldi	r20, 0x55	; 85
     bfc:	50 e0       	ldi	r21, 0x00	; 0
     bfe:	62 e8       	ldi	r22, 0x82	; 130
     c00:	70 e0       	ldi	r23, 0x00	; 0
     c02:	8b e6       	ldi	r24, 0x6B	; 107
     c04:	95 e0       	ldi	r25, 0x05	; 5
     c06:	0e 94 56 01 	call	0x2ac	; 0x2ac <xTaskCreate>
	
	/* In this port, to use preemptive scheduler define configUSE_PREEMPTION
	as 1 in portmacro.h.  To use the cooperative scheduler define
	configUSE_PREEMPTION as 0. */
	vTaskStartScheduler();
     c0a:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <vTaskStartScheduler>

	return 0;
}
     c0e:	80 e0       	ldi	r24, 0x00	; 0
     c10:	90 e0       	ldi	r25, 0x00	; 0
     c12:	0f 90       	pop	r0
     c14:	df 91       	pop	r29
     c16:	cf 91       	pop	r28
     c18:	0f 91       	pop	r16
     c1a:	ff 90       	pop	r15
     c1c:	ef 90       	pop	r14
     c1e:	08 95       	ret

00000c20 <vApplicationIdleHook>:
	eeprom_write_byte( mainRESET_COUNT_ADDRESS, ucCount );
}
/*-----------------------------------------------------------*/

void vApplicationIdleHook( void )
{
     c20:	08 95       	ret

00000c22 <pvPortMalloc>:
#endif

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     c22:	cf 93       	push	r28
     c24:	df 93       	push	r29
     c26:	ec 01       	movw	r28, r24
void *pvReturn;

	vTaskSuspendAll();
     c28:	0e 94 86 02 	call	0x50c	; 0x50c <vTaskSuspendAll>
	{
		pvReturn = malloc( xWantedSize );
     c2c:	ce 01       	movw	r24, r28
     c2e:	0e 94 ab 0c 	call	0x1956	; 0x1956 <malloc>
     c32:	ec 01       	movw	r28, r24
		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     c34:	0e 94 49 03 	call	0x692	; 0x692 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     c38:	ce 01       	movw	r24, r28
     c3a:	df 91       	pop	r29
     c3c:	cf 91       	pop	r28
     c3e:	08 95       	ret

00000c40 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     c40:	cf 93       	push	r28
     c42:	df 93       	push	r29
     c44:	ec 01       	movw	r28, r24
	if( pv )
     c46:	00 97       	sbiw	r24, 0x00	; 0
     c48:	39 f0       	breq	.+14     	; 0xc58 <vPortFree+0x18>
	{
		vTaskSuspendAll();
     c4a:	0e 94 86 02 	call	0x50c	; 0x50c <vTaskSuspendAll>
		{
			free( pv );
     c4e:	ce 01       	movw	r24, r28
     c50:	0e 94 43 0d 	call	0x1a86	; 0x1a86 <free>
			traceFREE( pv, 0 );
		}
		( void ) xTaskResumeAll();
     c54:	0e 94 49 03 	call	0x692	; 0x692 <xTaskResumeAll>
	}
}
     c58:	df 91       	pop	r29
     c5a:	cf 91       	pop	r28
     c5c:	08 95       	ret

00000c5e <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     c5e:	31 e1       	ldi	r19, 0x11	; 17
     c60:	fc 01       	movw	r30, r24
     c62:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
     c64:	31 97       	sbiw	r30, 0x01	; 1
     c66:	22 e2       	ldi	r18, 0x22	; 34
     c68:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
     c6a:	31 97       	sbiw	r30, 0x01	; 1
     c6c:	a3 e3       	ldi	r26, 0x33	; 51
     c6e:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     c70:	31 97       	sbiw	r30, 0x01	; 1
     c72:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     c74:	31 97       	sbiw	r30, 0x01	; 1
     c76:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
     c78:	31 97       	sbiw	r30, 0x01	; 1
     c7a:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     c7c:	31 97       	sbiw	r30, 0x01	; 1
     c7e:	60 e8       	ldi	r22, 0x80	; 128
     c80:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
     c82:	31 97       	sbiw	r30, 0x01	; 1
     c84:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
     c86:	31 97       	sbiw	r30, 0x01	; 1
     c88:	62 e0       	ldi	r22, 0x02	; 2
     c8a:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
     c8c:	31 97       	sbiw	r30, 0x01	; 1
     c8e:	63 e0       	ldi	r22, 0x03	; 3
     c90:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
     c92:	31 97       	sbiw	r30, 0x01	; 1
     c94:	64 e0       	ldi	r22, 0x04	; 4
     c96:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
     c98:	31 97       	sbiw	r30, 0x01	; 1
     c9a:	65 e0       	ldi	r22, 0x05	; 5
     c9c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
     c9e:	31 97       	sbiw	r30, 0x01	; 1
     ca0:	66 e0       	ldi	r22, 0x06	; 6
     ca2:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
     ca4:	31 97       	sbiw	r30, 0x01	; 1
     ca6:	67 e0       	ldi	r22, 0x07	; 7
     ca8:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
     caa:	31 97       	sbiw	r30, 0x01	; 1
     cac:	68 e0       	ldi	r22, 0x08	; 8
     cae:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
     cb0:	31 97       	sbiw	r30, 0x01	; 1
     cb2:	69 e0       	ldi	r22, 0x09	; 9
     cb4:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
     cb6:	31 97       	sbiw	r30, 0x01	; 1
     cb8:	60 e1       	ldi	r22, 0x10	; 16
     cba:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
     cbc:	31 97       	sbiw	r30, 0x01	; 1
     cbe:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
     cc0:	31 97       	sbiw	r30, 0x01	; 1
     cc2:	32 e1       	ldi	r19, 0x12	; 18
     cc4:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
     cc6:	31 97       	sbiw	r30, 0x01	; 1
     cc8:	33 e1       	ldi	r19, 0x13	; 19
     cca:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
     ccc:	31 97       	sbiw	r30, 0x01	; 1
     cce:	34 e1       	ldi	r19, 0x14	; 20
     cd0:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
     cd2:	31 97       	sbiw	r30, 0x01	; 1
     cd4:	35 e1       	ldi	r19, 0x15	; 21
     cd6:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
     cd8:	31 97       	sbiw	r30, 0x01	; 1
     cda:	36 e1       	ldi	r19, 0x16	; 22
     cdc:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
     cde:	31 97       	sbiw	r30, 0x01	; 1
     ce0:	37 e1       	ldi	r19, 0x17	; 23
     ce2:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
     ce4:	31 97       	sbiw	r30, 0x01	; 1
     ce6:	38 e1       	ldi	r19, 0x18	; 24
     ce8:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
     cea:	31 97       	sbiw	r30, 0x01	; 1
     cec:	39 e1       	ldi	r19, 0x19	; 25
     cee:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
     cf0:	31 97       	sbiw	r30, 0x01	; 1
     cf2:	30 e2       	ldi	r19, 0x20	; 32
     cf4:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
     cf6:	31 97       	sbiw	r30, 0x01	; 1
     cf8:	31 e2       	ldi	r19, 0x21	; 33
     cfa:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
     cfc:	31 97       	sbiw	r30, 0x01	; 1
     cfe:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
     d00:	31 97       	sbiw	r30, 0x01	; 1
     d02:	23 e2       	ldi	r18, 0x23	; 35
     d04:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     d06:	31 97       	sbiw	r30, 0x01	; 1
     d08:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     d0a:	31 97       	sbiw	r30, 0x01	; 1
     d0c:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
     d0e:	31 97       	sbiw	r30, 0x01	; 1
     d10:	26 e2       	ldi	r18, 0x26	; 38
     d12:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
     d14:	31 97       	sbiw	r30, 0x01	; 1
     d16:	27 e2       	ldi	r18, 0x27	; 39
     d18:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
     d1a:	31 97       	sbiw	r30, 0x01	; 1
     d1c:	28 e2       	ldi	r18, 0x28	; 40
     d1e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
     d20:	31 97       	sbiw	r30, 0x01	; 1
     d22:	29 e2       	ldi	r18, 0x29	; 41
     d24:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
     d26:	31 97       	sbiw	r30, 0x01	; 1
     d28:	20 e3       	ldi	r18, 0x30	; 48
     d2a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
     d2c:	31 97       	sbiw	r30, 0x01	; 1
     d2e:	21 e3       	ldi	r18, 0x31	; 49
     d30:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
     d32:	86 97       	sbiw	r24, 0x26	; 38
     d34:	08 95       	ret

00000d36 <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	OCR1AH = ucHighByte;
     d36:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = ucLowByte;
     d38:	89 ef       	ldi	r24, 0xF9	; 249
     d3a:	8a bd       	out	0x2a, r24	; 42

	/* Setup clock source and compare match behaviour. */
	/* ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64; */
	ucLowByte = (1<<3)|(1<<1)|(1<<0);
	TCCR1B = ucLowByte;
     d3c:	8b e0       	ldi	r24, 0x0B	; 11
     d3e:	8e bd       	out	0x2e, r24	; 46

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
     d40:	89 b7       	in	r24, 0x39	; 57
	/* ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE; */
	ucLowByte |= (1<<4);
     d42:	80 61       	ori	r24, 0x10	; 16
	TIMSK = ucLowByte;
     d44:	89 bf       	out	0x39, r24	; 57
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     d46:	a0 91 03 01 	lds	r26, 0x0103
     d4a:	b0 91 04 01 	lds	r27, 0x0104
     d4e:	cd 91       	ld	r28, X+
     d50:	cd bf       	out	0x3d, r28	; 61
     d52:	dd 91       	ld	r29, X+
     d54:	de bf       	out	0x3e, r29	; 62
     d56:	ff 91       	pop	r31
     d58:	ef 91       	pop	r30
     d5a:	df 91       	pop	r29
     d5c:	cf 91       	pop	r28
     d5e:	bf 91       	pop	r27
     d60:	af 91       	pop	r26
     d62:	9f 91       	pop	r25
     d64:	8f 91       	pop	r24
     d66:	7f 91       	pop	r23
     d68:	6f 91       	pop	r22
     d6a:	5f 91       	pop	r21
     d6c:	4f 91       	pop	r20
     d6e:	3f 91       	pop	r19
     d70:	2f 91       	pop	r18
     d72:	1f 91       	pop	r17
     d74:	0f 91       	pop	r16
     d76:	ff 90       	pop	r15
     d78:	ef 90       	pop	r14
     d7a:	df 90       	pop	r13
     d7c:	cf 90       	pop	r12
     d7e:	bf 90       	pop	r11
     d80:	af 90       	pop	r10
     d82:	9f 90       	pop	r9
     d84:	8f 90       	pop	r8
     d86:	7f 90       	pop	r7
     d88:	6f 90       	pop	r6
     d8a:	5f 90       	pop	r5
     d8c:	4f 90       	pop	r4
     d8e:	3f 90       	pop	r3
     d90:	2f 90       	pop	r2
     d92:	1f 90       	pop	r1
     d94:	0f 90       	pop	r0
     d96:	0f be       	out	0x3f, r0	; 63
     d98:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     d9a:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
     d9c:	81 e0       	ldi	r24, 0x01	; 1
     d9e:	08 95       	ret

00000da0 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     da0:	0f 92       	push	r0
     da2:	0f b6       	in	r0, 0x3f	; 63
     da4:	f8 94       	cli
     da6:	0f 92       	push	r0
     da8:	1f 92       	push	r1
     daa:	11 24       	eor	r1, r1
     dac:	2f 92       	push	r2
     dae:	3f 92       	push	r3
     db0:	4f 92       	push	r4
     db2:	5f 92       	push	r5
     db4:	6f 92       	push	r6
     db6:	7f 92       	push	r7
     db8:	8f 92       	push	r8
     dba:	9f 92       	push	r9
     dbc:	af 92       	push	r10
     dbe:	bf 92       	push	r11
     dc0:	cf 92       	push	r12
     dc2:	df 92       	push	r13
     dc4:	ef 92       	push	r14
     dc6:	ff 92       	push	r15
     dc8:	0f 93       	push	r16
     dca:	1f 93       	push	r17
     dcc:	2f 93       	push	r18
     dce:	3f 93       	push	r19
     dd0:	4f 93       	push	r20
     dd2:	5f 93       	push	r21
     dd4:	6f 93       	push	r22
     dd6:	7f 93       	push	r23
     dd8:	8f 93       	push	r24
     dda:	9f 93       	push	r25
     ddc:	af 93       	push	r26
     dde:	bf 93       	push	r27
     de0:	cf 93       	push	r28
     de2:	df 93       	push	r29
     de4:	ef 93       	push	r30
     de6:	ff 93       	push	r31
     de8:	a0 91 03 01 	lds	r26, 0x0103
     dec:	b0 91 04 01 	lds	r27, 0x0104
     df0:	0d b6       	in	r0, 0x3d	; 61
     df2:	0d 92       	st	X+, r0
     df4:	0e b6       	in	r0, 0x3e	; 62
     df6:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     df8:	0e 94 1b 04 	call	0x836	; 0x836 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     dfc:	a0 91 03 01 	lds	r26, 0x0103
     e00:	b0 91 04 01 	lds	r27, 0x0104
     e04:	cd 91       	ld	r28, X+
     e06:	cd bf       	out	0x3d, r28	; 61
     e08:	dd 91       	ld	r29, X+
     e0a:	de bf       	out	0x3e, r29	; 62
     e0c:	ff 91       	pop	r31
     e0e:	ef 91       	pop	r30
     e10:	df 91       	pop	r29
     e12:	cf 91       	pop	r28
     e14:	bf 91       	pop	r27
     e16:	af 91       	pop	r26
     e18:	9f 91       	pop	r25
     e1a:	8f 91       	pop	r24
     e1c:	7f 91       	pop	r23
     e1e:	6f 91       	pop	r22
     e20:	5f 91       	pop	r21
     e22:	4f 91       	pop	r20
     e24:	3f 91       	pop	r19
     e26:	2f 91       	pop	r18
     e28:	1f 91       	pop	r17
     e2a:	0f 91       	pop	r16
     e2c:	ff 90       	pop	r15
     e2e:	ef 90       	pop	r14
     e30:	df 90       	pop	r13
     e32:	cf 90       	pop	r12
     e34:	bf 90       	pop	r11
     e36:	af 90       	pop	r10
     e38:	9f 90       	pop	r9
     e3a:	8f 90       	pop	r8
     e3c:	7f 90       	pop	r7
     e3e:	6f 90       	pop	r6
     e40:	5f 90       	pop	r5
     e42:	4f 90       	pop	r4
     e44:	3f 90       	pop	r3
     e46:	2f 90       	pop	r2
     e48:	1f 90       	pop	r1
     e4a:	0f 90       	pop	r0
     e4c:	0f be       	out	0x3f, r0	; 63
     e4e:	0f 90       	pop	r0

	asm volatile ( "ret" );
     e50:	08 95       	ret

00000e52 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     e52:	0f 92       	push	r0
     e54:	0f b6       	in	r0, 0x3f	; 63
     e56:	f8 94       	cli
     e58:	0f 92       	push	r0
     e5a:	1f 92       	push	r1
     e5c:	11 24       	eor	r1, r1
     e5e:	2f 92       	push	r2
     e60:	3f 92       	push	r3
     e62:	4f 92       	push	r4
     e64:	5f 92       	push	r5
     e66:	6f 92       	push	r6
     e68:	7f 92       	push	r7
     e6a:	8f 92       	push	r8
     e6c:	9f 92       	push	r9
     e6e:	af 92       	push	r10
     e70:	bf 92       	push	r11
     e72:	cf 92       	push	r12
     e74:	df 92       	push	r13
     e76:	ef 92       	push	r14
     e78:	ff 92       	push	r15
     e7a:	0f 93       	push	r16
     e7c:	1f 93       	push	r17
     e7e:	2f 93       	push	r18
     e80:	3f 93       	push	r19
     e82:	4f 93       	push	r20
     e84:	5f 93       	push	r21
     e86:	6f 93       	push	r22
     e88:	7f 93       	push	r23
     e8a:	8f 93       	push	r24
     e8c:	9f 93       	push	r25
     e8e:	af 93       	push	r26
     e90:	bf 93       	push	r27
     e92:	cf 93       	push	r28
     e94:	df 93       	push	r29
     e96:	ef 93       	push	r30
     e98:	ff 93       	push	r31
     e9a:	a0 91 03 01 	lds	r26, 0x0103
     e9e:	b0 91 04 01 	lds	r27, 0x0104
     ea2:	0d b6       	in	r0, 0x3d	; 61
     ea4:	0d 92       	st	X+, r0
     ea6:	0e b6       	in	r0, 0x3e	; 62
     ea8:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     eaa:	0e 94 8c 02 	call	0x518	; 0x518 <xTaskIncrementTick>
     eae:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     eb0:	0e 94 1b 04 	call	0x836	; 0x836 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     eb4:	a0 91 03 01 	lds	r26, 0x0103
     eb8:	b0 91 04 01 	lds	r27, 0x0104
     ebc:	cd 91       	ld	r28, X+
     ebe:	cd bf       	out	0x3d, r28	; 61
     ec0:	dd 91       	ld	r29, X+
     ec2:	de bf       	out	0x3e, r29	; 62
     ec4:	ff 91       	pop	r31
     ec6:	ef 91       	pop	r30
     ec8:	df 91       	pop	r29
     eca:	cf 91       	pop	r28
     ecc:	bf 91       	pop	r27
     ece:	af 91       	pop	r26
     ed0:	9f 91       	pop	r25
     ed2:	8f 91       	pop	r24
     ed4:	7f 91       	pop	r23
     ed6:	6f 91       	pop	r22
     ed8:	5f 91       	pop	r21
     eda:	4f 91       	pop	r20
     edc:	3f 91       	pop	r19
     ede:	2f 91       	pop	r18
     ee0:	1f 91       	pop	r17
     ee2:	0f 91       	pop	r16
     ee4:	ff 90       	pop	r15
     ee6:	ef 90       	pop	r14
     ee8:	df 90       	pop	r13
     eea:	cf 90       	pop	r12
     eec:	bf 90       	pop	r11
     eee:	af 90       	pop	r10
     ef0:	9f 90       	pop	r9
     ef2:	8f 90       	pop	r8
     ef4:	7f 90       	pop	r7
     ef6:	6f 90       	pop	r6
     ef8:	5f 90       	pop	r5
     efa:	4f 90       	pop	r4
     efc:	3f 90       	pop	r3
     efe:	2f 90       	pop	r2
     f00:	1f 90       	pop	r1
     f02:	0f 90       	pop	r0
     f04:	0f be       	out	0x3f, r0	; 63
     f06:	0f 90       	pop	r0

	asm volatile ( "ret" );
     f08:	08 95       	ret

00000f0a <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     f0a:	0e 94 29 07 	call	0xe52	; 0xe52 <vPortYieldFromTick>
		asm volatile ( "reti" );
     f0e:	18 95       	reti

00000f10 <adc_init>:
sint16 result_ADC;
sint16 result_ADC_motor;

void adc_init()
{
	cli();
     f10:	f8 94       	cli
	
	ADMUX=0x40;
     f12:	80 e4       	ldi	r24, 0x40	; 64
     f14:	87 b9       	out	0x07, r24	; 7

	ADCSRA|=1<<ADIE;
     f16:	33 9a       	sbi	0x06, 3	; 6
	ADCSRA|=6; //prscaler =64
     f18:	86 b1       	in	r24, 0x06	; 6
     f1a:	86 60       	ori	r24, 0x06	; 6
     f1c:	86 b9       	out	0x06, r24	; 6
	ADCSRA|=1<<ADEN;
     f1e:	37 9a       	sbi	0x06, 7	; 6
	
	sei();
     f20:	78 94       	sei
     f22:	08 95       	ret

00000f24 <get_result_ADC>:
	
}
sint16 get_result_ADC(void)
{
	//result_ADC
	return result_ADC>>3;
     f24:	80 91 21 01 	lds	r24, 0x0121
     f28:	90 91 22 01 	lds	r25, 0x0122
}
     f2c:	95 95       	asr	r25
     f2e:	87 95       	ror	r24
     f30:	95 95       	asr	r25
     f32:	87 95       	ror	r24
     f34:	95 95       	asr	r25
     f36:	87 95       	ror	r24
     f38:	08 95       	ret

00000f3a <get_result_ADC_motor>:

sint16 get_result_ADC_motor(void)
{
	//result_ADC
	return result_ADC_motor>>3;
     f3a:	80 91 23 01 	lds	r24, 0x0123
     f3e:	90 91 24 01 	lds	r25, 0x0124
}
     f42:	95 95       	asr	r25
     f44:	87 95       	ror	r24
     f46:	95 95       	asr	r25
     f48:	87 95       	ror	r24
     f4a:	95 95       	asr	r25
     f4c:	87 95       	ror	r24
     f4e:	08 95       	ret

00000f50 <adc_cyclic>:

void adc_cyclic(uint8 channel)
{
	if(channel==0)
     f50:	81 11       	cpse	r24, r1
     f52:	04 c0       	rjmp	.+8      	; 0xf5c <adc_cyclic+0xc>
	{
		ADMUX &= 0xf8;
     f54:	87 b1       	in	r24, 0x07	; 7
     f56:	88 7f       	andi	r24, 0xF8	; 248
     f58:	87 b9       	out	0x07, r24	; 7
     f5a:	03 c0       	rjmp	.+6      	; 0xf62 <adc_cyclic+0x12>
	}
	if(channel==1)
     f5c:	81 30       	cpi	r24, 0x01	; 1
     f5e:	09 f4       	brne	.+2      	; 0xf62 <adc_cyclic+0x12>
	{	
		ADMUX |= 1;
     f60:	38 9a       	sbi	0x07, 0	; 7
	}
	ADCSRA |= 1<<ADSC;
     f62:	36 9a       	sbi	0x06, 6	; 6
     f64:	08 95       	ret

00000f66 <__vector_16>:
}


ISR(ADC_vect)
{
     f66:	1f 92       	push	r1
     f68:	0f 92       	push	r0
     f6a:	0f b6       	in	r0, 0x3f	; 63
     f6c:	0f 92       	push	r0
     f6e:	11 24       	eor	r1, r1
     f70:	8f 93       	push	r24
     f72:	9f 93       	push	r25
	if(ADMUX&1)
     f74:	38 9b       	sbis	0x07, 0	; 7
     f76:	07 c0       	rjmp	.+14     	; 0xf86 <__vector_16+0x20>
		result_ADC=ADC;
     f78:	84 b1       	in	r24, 0x04	; 4
     f7a:	95 b1       	in	r25, 0x05	; 5
     f7c:	90 93 22 01 	sts	0x0122, r25
     f80:	80 93 21 01 	sts	0x0121, r24
     f84:	06 c0       	rjmp	.+12     	; 0xf92 <__vector_16+0x2c>
	else
	{
		
		result_ADC_motor=ADC;
     f86:	84 b1       	in	r24, 0x04	; 4
     f88:	95 b1       	in	r25, 0x05	; 5
     f8a:	90 93 24 01 	sts	0x0124, r25
     f8e:	80 93 23 01 	sts	0x0123, r24
	}
	
     f92:	9f 91       	pop	r25
     f94:	8f 91       	pop	r24
     f96:	0f 90       	pop	r0
     f98:	0f be       	out	0x3f, r0	; 63
     f9a:	0f 90       	pop	r0
     f9c:	1f 90       	pop	r1
     f9e:	18 95       	reti

00000fa0 <display_phase>:
#include "z_pwm.h"
#include "z_adc.h"
#include "z_events.h"

void display_phase()
{
     fa0:	cf 93       	push	r28
     fa2:	df 93       	push	r29
     fa4:	00 d0       	rcall	.+0      	; 0xfa6 <display_phase+0x6>
     fa6:	00 d0       	rcall	.+0      	; 0xfa8 <display_phase+0x8>
     fa8:	cd b7       	in	r28, 0x3d	; 61
     faa:	de b7       	in	r29, 0x3e	; 62
	
	char buf[4]="0000";
     fac:	80 e3       	ldi	r24, 0x30	; 48
     fae:	90 e3       	ldi	r25, 0x30	; 48
     fb0:	dc 01       	movw	r26, r24
     fb2:	89 83       	std	Y+1, r24	; 0x01
     fb4:	9a 83       	std	Y+2, r25	; 0x02
     fb6:	ab 83       	std	Y+3, r26	; 0x03
     fb8:	bc 83       	std	Y+4, r27	; 0x04
	
	LCD_Clear();
     fba:	0e 94 bc 04 	call	0x978	; 0x978 <LCD_Clear>
	
	if ( ON )
     fbe:	80 91 1f 01 	lds	r24, 0x011F
     fc2:	80 ff       	sbrs	r24, 0
     fc4:	a6 c0       	rjmp	.+332    	; 0x1112 <display_phase+0x172>
	{
		LCD_GoTo(0,0);
     fc6:	60 e0       	ldi	r22, 0x00	; 0
     fc8:	70 e0       	ldi	r23, 0x00	; 0
     fca:	80 e0       	ldi	r24, 0x00	; 0
     fcc:	90 e0       	ldi	r25, 0x00	; 0
     fce:	0e 94 b4 04 	call	0x968	; 0x968 <LCD_GoTo>
		LCD_WriteText("P:");
     fd2:	8f e8       	ldi	r24, 0x8F	; 143
     fd4:	90 e0       	ldi	r25, 0x00	; 0
     fd6:	0e 94 a5 04 	call	0x94a	; 0x94a <LCD_WriteText>
		
		
		itoa(POW,buf,10);
     fda:	80 91 1f 01 	lds	r24, 0x011F
     fde:	86 95       	lsr	r24
     fe0:	83 70       	andi	r24, 0x03	; 3
     fe2:	4a e0       	ldi	r20, 0x0A	; 10
     fe4:	50 e0       	ldi	r21, 0x00	; 0
     fe6:	be 01       	movw	r22, r28
     fe8:	6f 5f       	subi	r22, 0xFF	; 255
     fea:	7f 4f       	sbci	r23, 0xFF	; 255
     fec:	90 e0       	ldi	r25, 0x00	; 0
     fee:	0e 94 d2 0d 	call	0x1ba4	; 0x1ba4 <itoa>
		LCD_GoTo(2,0);
     ff2:	60 e0       	ldi	r22, 0x00	; 0
     ff4:	70 e0       	ldi	r23, 0x00	; 0
     ff6:	82 e0       	ldi	r24, 0x02	; 2
     ff8:	90 e0       	ldi	r25, 0x00	; 0
     ffa:	0e 94 b4 04 	call	0x968	; 0x968 <LCD_GoTo>
		LCD_WriteText(buf);
     ffe:	ce 01       	movw	r24, r28
    1000:	01 96       	adiw	r24, 0x01	; 1
    1002:	0e 94 a5 04 	call	0x94a	; 0x94a <LCD_WriteText>
		
		LCD_GoTo(4,0);
    1006:	60 e0       	ldi	r22, 0x00	; 0
    1008:	70 e0       	ldi	r23, 0x00	; 0
    100a:	84 e0       	ldi	r24, 0x04	; 4
    100c:	90 e0       	ldi	r25, 0x00	; 0
    100e:	0e 94 b4 04 	call	0x968	; 0x968 <LCD_GoTo>
		LCD_WriteText("F:");
    1012:	82 e9       	ldi	r24, 0x92	; 146
    1014:	90 e0       	ldi	r25, 0x00	; 0
    1016:	0e 94 a5 04 	call	0x94a	; 0x94a <LCD_WriteText>
		
		itoa(FAN,buf,10);
    101a:	80 91 1f 01 	lds	r24, 0x011F
    101e:	86 95       	lsr	r24
    1020:	86 95       	lsr	r24
    1022:	86 95       	lsr	r24
    1024:	83 70       	andi	r24, 0x03	; 3
    1026:	4a e0       	ldi	r20, 0x0A	; 10
    1028:	50 e0       	ldi	r21, 0x00	; 0
    102a:	be 01       	movw	r22, r28
    102c:	6f 5f       	subi	r22, 0xFF	; 255
    102e:	7f 4f       	sbci	r23, 0xFF	; 255
    1030:	90 e0       	ldi	r25, 0x00	; 0
    1032:	0e 94 d2 0d 	call	0x1ba4	; 0x1ba4 <itoa>
		LCD_GoTo(6,0);
    1036:	60 e0       	ldi	r22, 0x00	; 0
    1038:	70 e0       	ldi	r23, 0x00	; 0
    103a:	86 e0       	ldi	r24, 0x06	; 6
    103c:	90 e0       	ldi	r25, 0x00	; 0
    103e:	0e 94 b4 04 	call	0x968	; 0x968 <LCD_GoTo>
		LCD_WriteText(buf);
    1042:	ce 01       	movw	r24, r28
    1044:	01 96       	adiw	r24, 0x01	; 1
    1046:	0e 94 a5 04 	call	0x94a	; 0x94a <LCD_WriteText>
		
		
		LCD_GoTo(8,0);
    104a:	60 e0       	ldi	r22, 0x00	; 0
    104c:	70 e0       	ldi	r23, 0x00	; 0
    104e:	88 e0       	ldi	r24, 0x08	; 8
    1050:	90 e0       	ldi	r25, 0x00	; 0
    1052:	0e 94 b4 04 	call	0x968	; 0x968 <LCD_GoTo>
		if(HEAT)
    1056:	80 91 1f 01 	lds	r24, 0x011F
    105a:	85 ff       	sbrs	r24, 5
    105c:	05 c0       	rjmp	.+10     	; 0x1068 <display_phase+0xc8>
		LCD_WriteText("H");
    105e:	85 e9       	ldi	r24, 0x95	; 149
    1060:	90 e0       	ldi	r25, 0x00	; 0
    1062:	0e 94 a5 04 	call	0x94a	; 0x94a <LCD_WriteText>
    1066:	04 c0       	rjmp	.+8      	; 0x1070 <display_phase+0xd0>
		else 
		LCD_WriteText("C");
    1068:	87 e9       	ldi	r24, 0x97	; 151
    106a:	90 e0       	ldi	r25, 0x00	; 0
    106c:	0e 94 a5 04 	call	0x94a	; 0x94a <LCD_WriteText>
		
		
		
		LCD_GoTo(11,0);
    1070:	60 e0       	ldi	r22, 0x00	; 0
    1072:	70 e0       	ldi	r23, 0x00	; 0
    1074:	8b e0       	ldi	r24, 0x0B	; 11
    1076:	90 e0       	ldi	r25, 0x00	; 0
    1078:	0e 94 b4 04 	call	0x968	; 0x968 <LCD_GoTo>
		LCD_WriteText("W:");
    107c:	89 e9       	ldi	r24, 0x99	; 153
    107e:	90 e0       	ldi	r25, 0x00	; 0
    1080:	0e 94 a5 04 	call	0x94a	; 0x94a <LCD_WriteText>
		
		itoa(desired_temp, buf,10);
    1084:	80 91 25 01 	lds	r24, 0x0125
    1088:	4a e0       	ldi	r20, 0x0A	; 10
    108a:	50 e0       	ldi	r21, 0x00	; 0
    108c:	be 01       	movw	r22, r28
    108e:	6f 5f       	subi	r22, 0xFF	; 255
    1090:	7f 4f       	sbci	r23, 0xFF	; 255
    1092:	99 27       	eor	r25, r25
    1094:	87 fd       	sbrc	r24, 7
    1096:	90 95       	com	r25
    1098:	0e 94 d2 0d 	call	0x1ba4	; 0x1ba4 <itoa>
		LCD_GoTo(13,0);
    109c:	60 e0       	ldi	r22, 0x00	; 0
    109e:	70 e0       	ldi	r23, 0x00	; 0
    10a0:	8d e0       	ldi	r24, 0x0D	; 13
    10a2:	90 e0       	ldi	r25, 0x00	; 0
    10a4:	0e 94 b4 04 	call	0x968	; 0x968 <LCD_GoTo>
		LCD_WriteText(buf);
    10a8:	ce 01       	movw	r24, r28
    10aa:	01 96       	adiw	r24, 0x01	; 1
    10ac:	0e 94 a5 04 	call	0x94a	; 0x94a <LCD_WriteText>
		
		LCD_GoTo(0,1);
    10b0:	61 e0       	ldi	r22, 0x01	; 1
    10b2:	70 e0       	ldi	r23, 0x00	; 0
    10b4:	80 e0       	ldi	r24, 0x00	; 0
    10b6:	90 e0       	ldi	r25, 0x00	; 0
    10b8:	0e 94 b4 04 	call	0x968	; 0x968 <LCD_GoTo>
		LCD_WriteText("T:");
    10bc:	8c e9       	ldi	r24, 0x9C	; 156
    10be:	90 e0       	ldi	r25, 0x00	; 0
    10c0:	0e 94 a5 04 	call	0x94a	; 0x94a <LCD_WriteText>
		
		itoa(temp(), buf,10);
    10c4:	0e 94 0b 09 	call	0x1216	; 0x1216 <temp>
    10c8:	4a e0       	ldi	r20, 0x0A	; 10
    10ca:	50 e0       	ldi	r21, 0x00	; 0
    10cc:	be 01       	movw	r22, r28
    10ce:	6f 5f       	subi	r22, 0xFF	; 255
    10d0:	7f 4f       	sbci	r23, 0xFF	; 255
    10d2:	0e 94 d2 0d 	call	0x1ba4	; 0x1ba4 <itoa>
		LCD_GoTo(2,1);
    10d6:	61 e0       	ldi	r22, 0x01	; 1
    10d8:	70 e0       	ldi	r23, 0x00	; 0
    10da:	82 e0       	ldi	r24, 0x02	; 2
    10dc:	90 e0       	ldi	r25, 0x00	; 0
    10de:	0e 94 b4 04 	call	0x968	; 0x968 <LCD_GoTo>
		LCD_WriteText(buf);
    10e2:	ce 01       	movw	r24, r28
    10e4:	01 96       	adiw	r24, 0x01	; 1
    10e6:	0e 94 a5 04 	call	0x94a	; 0x94a <LCD_WriteText>
		
		LCD_GoTo(9,0);
    10ea:	60 e0       	ldi	r22, 0x00	; 0
    10ec:	70 e0       	ldi	r23, 0x00	; 0
    10ee:	89 e0       	ldi	r24, 0x09	; 9
    10f0:	90 e0       	ldi	r25, 0x00	; 0
    10f2:	0e 94 b4 04 	call	0x968	; 0x968 <LCD_GoTo>
		if(AUTO)
    10f6:	80 91 1f 01 	lds	r24, 0x011F
    10fa:	86 ff       	sbrs	r24, 6
    10fc:	05 c0       	rjmp	.+10     	; 0x1108 <display_phase+0x168>
		LCD_WriteText("A");
    10fe:	8f e9       	ldi	r24, 0x9F	; 159
    1100:	90 e0       	ldi	r25, 0x00	; 0
    1102:	0e 94 a5 04 	call	0x94a	; 0x94a <LCD_WriteText>
    1106:	0f c0       	rjmp	.+30     	; 0x1126 <display_phase+0x186>
		else 
		LCD_WriteText("M");
    1108:	81 ea       	ldi	r24, 0xA1	; 161
    110a:	90 e0       	ldi	r25, 0x00	; 0
    110c:	0e 94 a5 04 	call	0x94a	; 0x94a <LCD_WriteText>
    1110:	0a c0       	rjmp	.+20     	; 0x1126 <display_phase+0x186>
		
		
	}
	else 
	{
		LCD_GoTo(0,0);
    1112:	60 e0       	ldi	r22, 0x00	; 0
    1114:	70 e0       	ldi	r23, 0x00	; 0
    1116:	80 e0       	ldi	r24, 0x00	; 0
    1118:	90 e0       	ldi	r25, 0x00	; 0
    111a:	0e 94 b4 04 	call	0x968	; 0x968 <LCD_GoTo>
		LCD_WriteText("OFF");
    111e:	83 ea       	ldi	r24, 0xA3	; 163
    1120:	90 e0       	ldi	r25, 0x00	; 0
    1122:	0e 94 a5 04 	call	0x94a	; 0x94a <LCD_WriteText>
		
	}
	
    1126:	0f 90       	pop	r0
    1128:	0f 90       	pop	r0
    112a:	0f 90       	pop	r0
    112c:	0f 90       	pop	r0
    112e:	df 91       	pop	r29
    1130:	cf 91       	pop	r28
    1132:	08 95       	ret

00001134 <set_event>:

signed char desired_temp;

void set_event(unsigned char ev)
{
	ev%=7;
    1134:	95 e2       	ldi	r25, 0x25	; 37
    1136:	89 9f       	mul	r24, r25
    1138:	91 2d       	mov	r25, r1
    113a:	11 24       	eor	r1, r1
    113c:	28 2f       	mov	r18, r24
    113e:	29 1b       	sub	r18, r25
    1140:	26 95       	lsr	r18
    1142:	29 0f       	add	r18, r25
    1144:	26 95       	lsr	r18
    1146:	26 95       	lsr	r18
    1148:	92 2f       	mov	r25, r18
    114a:	99 0f       	add	r25, r25
    114c:	99 0f       	add	r25, r25
    114e:	99 0f       	add	r25, r25
    1150:	92 1b       	sub	r25, r18
    1152:	28 2f       	mov	r18, r24
    1154:	29 1b       	sub	r18, r25
	if(ev==0)
    1156:	31 f4       	brne	.+12     	; 0x1164 <set_event+0x30>
		states^=1;
    1158:	90 91 1f 01 	lds	r25, 0x011F
    115c:	81 e0       	ldi	r24, 0x01	; 1
    115e:	89 27       	eor	r24, r25
    1160:	80 93 1f 01 	sts	0x011F, r24
		
	if(ON && !AUTO)
    1164:	30 91 1f 01 	lds	r19, 0x011F
    1168:	30 ff       	sbrs	r19, 0
    116a:	36 c0       	rjmp	.+108    	; 0x11d8 <set_event+0xa4>
    116c:	83 2f       	mov	r24, r19
    116e:	82 95       	swap	r24
    1170:	86 95       	lsr	r24
    1172:	86 95       	lsr	r24
    1174:	83 70       	andi	r24, 0x03	; 3
    1176:	81 f5       	brne	.+96     	; 0x11d8 <set_event+0xa4>
	{
	
		
		if(ev==1)
    1178:	21 30       	cpi	r18, 0x01	; 1
    117a:	69 f4       	brne	.+26     	; 0x1196 <set_event+0x62>
		{
			if((states&6)<6)
    117c:	83 2f       	mov	r24, r19
    117e:	86 70       	andi	r24, 0x06	; 6
    1180:	90 e0       	ldi	r25, 0x00	; 0
    1182:	06 97       	sbiw	r24, 0x06	; 6
    1184:	24 f4       	brge	.+8      	; 0x118e <set_event+0x5a>
				states+=2;
    1186:	3e 5f       	subi	r19, 0xFE	; 254
    1188:	30 93 1f 01 	sts	0x011F, r19
    118c:	1c c0       	rjmp	.+56     	; 0x11c6 <set_event+0x92>
			else
				states&=~(3<<1);
    118e:	39 7f       	andi	r19, 0xF9	; 249
    1190:	30 93 1f 01 	sts	0x011F, r19
    1194:	18 c0       	rjmp	.+48     	; 0x11c6 <set_event+0x92>
		}
		
		if(ev==2)
    1196:	22 30       	cpi	r18, 0x02	; 2
    1198:	69 f4       	brne	.+26     	; 0x11b4 <set_event+0x80>
		{
			if((states&24)<24)
    119a:	83 2f       	mov	r24, r19
    119c:	88 71       	andi	r24, 0x18	; 24
    119e:	90 e0       	ldi	r25, 0x00	; 0
    11a0:	48 97       	sbiw	r24, 0x18	; 24
    11a2:	24 f4       	brge	.+8      	; 0x11ac <set_event+0x78>
				states+=8;
    11a4:	38 5f       	subi	r19, 0xF8	; 248
    11a6:	30 93 1f 01 	sts	0x011F, r19
    11aa:	08 95       	ret
			else
				states&=~(3<<3);
    11ac:	37 7e       	andi	r19, 0xE7	; 231
    11ae:	30 93 1f 01 	sts	0x011F, r19
    11b2:	08 95       	ret
		}
		
		if(ev==3)
    11b4:	23 30       	cpi	r18, 0x03	; 3
    11b6:	39 f4       	brne	.+14     	; 0x11c6 <set_event+0x92>
			states^=32;
    11b8:	90 91 1f 01 	lds	r25, 0x011F
    11bc:	80 e2       	ldi	r24, 0x20	; 32
    11be:	89 27       	eor	r24, r25
    11c0:	80 93 1f 01 	sts	0x011F, r24
    11c4:	08 95       	ret
			
		if(ev==4)
    11c6:	24 30       	cpi	r18, 0x04	; 4
    11c8:	29 f5       	brne	.+74     	; 0x1214 <set_event+0xe0>
			states^=64;
    11ca:	90 91 1f 01 	lds	r25, 0x011F
    11ce:	80 e4       	ldi	r24, 0x40	; 64
    11d0:	89 27       	eor	r24, r25
    11d2:	80 93 1f 01 	sts	0x011F, r24
    11d6:	08 95       	ret
    11d8:	83 2f       	mov	r24, r19
    11da:	81 74       	andi	r24, 0x41	; 65
			
		
	}
	else if(ON && AUTO)
    11dc:	81 34       	cpi	r24, 0x41	; 65
    11de:	d1 f4       	brne	.+52     	; 0x1214 <set_event+0xe0>
	{
		if (ev==4)
    11e0:	24 30       	cpi	r18, 0x04	; 4
    11e2:	29 f4       	brne	.+10     	; 0x11ee <set_event+0xba>
			states ^= 64;
    11e4:	80 e4       	ldi	r24, 0x40	; 64
    11e6:	38 27       	eor	r19, r24
    11e8:	30 93 1f 01 	sts	0x011F, r19
    11ec:	08 95       	ret
		if(ev==5)
    11ee:	25 30       	cpi	r18, 0x05	; 5
    11f0:	41 f4       	brne	.+16     	; 0x1202 <set_event+0xce>
		{
			if(desired_temp<36)
    11f2:	80 91 25 01 	lds	r24, 0x0125
    11f6:	84 32       	cpi	r24, 0x24	; 36
    11f8:	6c f4       	brge	.+26     	; 0x1214 <set_event+0xe0>
			desired_temp++;
    11fa:	8f 5f       	subi	r24, 0xFF	; 255
    11fc:	80 93 25 01 	sts	0x0125, r24
    1200:	08 95       	ret
		}
		
		if(ev==6)
    1202:	26 30       	cpi	r18, 0x06	; 6
    1204:	39 f4       	brne	.+14     	; 0x1214 <set_event+0xe0>
		{
			if(desired_temp>(-13))
    1206:	80 91 25 01 	lds	r24, 0x0125
    120a:	84 3f       	cpi	r24, 0xF4	; 244
    120c:	1c f0       	brlt	.+6      	; 0x1214 <set_event+0xe0>
			desired_temp--;
    120e:	81 50       	subi	r24, 0x01	; 1
    1210:	80 93 25 01 	sts	0x0125, r24
    1214:	08 95       	ret

00001216 <temp>:
	
}
signed char temp()
{
	
	adc_cyclic(0);
    1216:	80 e0       	ldi	r24, 0x00	; 0
    1218:	0e 94 a8 07 	call	0xf50	; 0xf50 <adc_cyclic>
	return (signed char)(get_result_ADC()/2.5 - 14);
    121c:	0e 94 92 07 	call	0xf24	; 0xf24 <get_result_ADC>
    1220:	bc 01       	movw	r22, r24
    1222:	80 e0       	ldi	r24, 0x00	; 0
    1224:	90 e0       	ldi	r25, 0x00	; 0
    1226:	0e 94 f5 0b 	call	0x17ea	; 0x17ea <__floatunsisf>
    122a:	20 e0       	ldi	r18, 0x00	; 0
    122c:	30 e0       	ldi	r19, 0x00	; 0
    122e:	40 e2       	ldi	r20, 0x20	; 32
    1230:	50 e4       	ldi	r21, 0x40	; 64
    1232:	0e 94 5c 0b 	call	0x16b8	; 0x16b8 <__divsf3>
    1236:	20 e0       	ldi	r18, 0x00	; 0
    1238:	30 e0       	ldi	r19, 0x00	; 0
    123a:	40 e6       	ldi	r20, 0x60	; 96
    123c:	51 e4       	ldi	r21, 0x41	; 65
    123e:	0e 94 f3 0a 	call	0x15e6	; 0x15e6 <__subsf3>
    1242:	0e 94 c4 0b 	call	0x1788	; 0x1788 <__fixsfsi>
    1246:	86 2f       	mov	r24, r22
	
}
    1248:	08 95       	ret

0000124a <motor>:

signed char motor()
{
	adc_cyclic(1);
    124a:	81 e0       	ldi	r24, 0x01	; 1
    124c:	0e 94 a8 07 	call	0xf50	; 0xf50 <adc_cyclic>
	return get_result_ADC_motor();
    1250:	0e 94 9d 07 	call	0xf3a	; 0xf3a <get_result_ADC_motor>
}
    1254:	08 95       	ret

00001256 <auto_climate_control>:

void auto_climate_control()
{
	char u8temp=temp();
    1256:	0e 94 0b 09 	call	0x1216	; 0x1216 <temp>
	if(ON && AUTO)
    125a:	60 91 1f 01 	lds	r22, 0x011F
    125e:	96 2f       	mov	r25, r22
    1260:	91 74       	andi	r25, 0x41	; 65
    1262:	91 34       	cpi	r25, 0x41	; 65
    1264:	09 f0       	breq	.+2      	; 0x1268 <auto_climate_control+0x12>
    1266:	45 c0       	rjmp	.+138    	; 0x12f2 <auto_climate_control+0x9c>
	{
		if(desired_temp>u8temp)
    1268:	20 91 25 01 	lds	r18, 0x0125
    126c:	33 27       	eor	r19, r19
    126e:	27 fd       	sbrc	r18, 7
    1270:	30 95       	com	r19
    1272:	90 e0       	ldi	r25, 0x00	; 0
    1274:	82 17       	cp	r24, r18
    1276:	93 07       	cpc	r25, r19
    1278:	74 f4       	brge	.+28     	; 0x1296 <auto_climate_control+0x40>
		{
			SET_HEAT_ON;
			if(desired_temp-u8temp>7)
    127a:	a9 01       	movw	r20, r18
    127c:	48 1b       	sub	r20, r24
    127e:	59 0b       	sbc	r21, r25
    1280:	48 30       	cpi	r20, 0x08	; 8
    1282:	51 05       	cpc	r21, r1
    1284:	24 f0       	brlt	.+8      	; 0x128e <auto_climate_control+0x38>
			{
				SET_FAN_3;
				SET_POW_3;
    1286:	6e 63       	ori	r22, 0x3E	; 62
    1288:	60 93 1f 01 	sts	0x011F, r22
    128c:	04 c0       	rjmp	.+8      	; 0x1296 <auto_climate_control+0x40>
			}
			else
			{
				SET_FAN_2;
    128e:	61 7c       	andi	r22, 0xC1	; 193
				SET_POW_1;
    1290:	62 63       	ori	r22, 0x32	; 50
    1292:	60 93 1f 01 	sts	0x011F, r22
			}
			
		}
		if(desired_temp<u8temp)
    1296:	28 17       	cp	r18, r24
    1298:	39 07       	cpc	r19, r25
    129a:	ac f4       	brge	.+42     	; 0x12c6 <auto_climate_control+0x70>
		{
			
			SET_HEAT_OFF;
    129c:	60 91 1f 01 	lds	r22, 0x011F
			if(u8temp-desired_temp>7)
    12a0:	ac 01       	movw	r20, r24
    12a2:	42 1b       	sub	r20, r18
    12a4:	53 0b       	sbc	r21, r19
    12a6:	48 30       	cpi	r20, 0x08	; 8
    12a8:	51 05       	cpc	r21, r1
    12aa:	3c f0       	brlt	.+14     	; 0x12ba <auto_climate_control+0x64>
			{
				SET_FAN_3;
    12ac:	67 7c       	andi	r22, 0xC7	; 199
    12ae:	68 5e       	subi	r22, 0xE8	; 232
				SET_POW_2;
    12b0:	69 7f       	andi	r22, 0xF9	; 249
    12b2:	6c 5f       	subi	r22, 0xFC	; 252
    12b4:	60 93 1f 01 	sts	0x011F, r22
    12b8:	06 c0       	rjmp	.+12     	; 0x12c6 <auto_climate_control+0x70>
			}
			else
			{
				SET_FAN_1;
    12ba:	67 7c       	andi	r22, 0xC7	; 199
    12bc:	68 5f       	subi	r22, 0xF8	; 248
				SET_POW_1;
    12be:	69 7f       	andi	r22, 0xF9	; 249
    12c0:	6e 5f       	subi	r22, 0xFE	; 254
    12c2:	60 93 1f 01 	sts	0x011F, r22
			}
		}
		if(desired_temp==u8temp)
    12c6:	28 17       	cp	r18, r24
    12c8:	39 07       	cpc	r19, r25
    12ca:	29 f4       	brne	.+10     	; 0x12d6 <auto_climate_control+0x80>
		{
			SET_FAN_0;
			SET_POW_0;
    12cc:	80 91 1f 01 	lds	r24, 0x011F
    12d0:	81 7e       	andi	r24, 0xE1	; 225
    12d2:	80 93 1f 01 	sts	0x011F, r24
		}
		set_pwm_fan_lvl(FAN);
    12d6:	80 91 1f 01 	lds	r24, 0x011F
    12da:	86 95       	lsr	r24
    12dc:	86 95       	lsr	r24
    12de:	86 95       	lsr	r24
    12e0:	83 70       	andi	r24, 0x03	; 3
    12e2:	0e 94 ef 09 	call	0x13de	; 0x13de <set_pwm_fan_lvl>
		set_pwm_pow_lvl(POW);
    12e6:	80 91 1f 01 	lds	r24, 0x011F
    12ea:	86 95       	lsr	r24
    12ec:	83 70       	andi	r24, 0x03	; 3
    12ee:	0e 94 0e 0a 	call	0x141c	; 0x141c <set_pwm_pow_lvl>
    12f2:	08 95       	ret

000012f4 <debounce_D>:

uint16_t buffer[8]={0,0,0,0,0,0,0,0};
sw_state_e enum_state[8]={0,0,0,0,0,0,0,0};

void debounce_D(volatile char *port_button)
{
    12f4:	9f 92       	push	r9
    12f6:	af 92       	push	r10
    12f8:	bf 92       	push	r11
    12fa:	cf 92       	push	r12
    12fc:	df 92       	push	r13
    12fe:	ef 92       	push	r14
    1300:	ff 92       	push	r15
    1302:	0f 93       	push	r16
    1304:	1f 93       	push	r17
    1306:	cf 93       	push	r28
    1308:	df 93       	push	r29
    130a:	6c 01       	movw	r12, r24
    130c:	0f 2e       	mov	r0, r31
    130e:	f5 e0       	ldi	r31, 0x05	; 5
    1310:	ef 2e       	mov	r14, r31
    1312:	f1 e0       	ldi	r31, 0x01	; 1
    1314:	ff 2e       	mov	r15, r31
    1316:	f0 2d       	mov	r31, r0
    1318:	0d e0       	ldi	r16, 0x0D	; 13
    131a:	11 e0       	ldi	r17, 0x01	; 1
    131c:	c0 e0       	ldi	r28, 0x00	; 0
    131e:	d0 e0       	ldi	r29, 0x00	; 0
		{
			enum_state[port_button_poz]=Bt_pressed;
		}
		else if((buffer[port_button_poz]&0x00ff)==0 && (buffer[port_button_poz]&0xff00)!=0 && enum_state[port_button_poz]==Bt_pressed)
		{
			enum_state[port_button_poz]=Bt_neg_edge;
    1320:	0f 2e       	mov	r0, r31
    1322:	f3 e0       	ldi	r31, 0x03	; 3
    1324:	9f 2e       	mov	r9, r31
    1326:	f0 2d       	mov	r31, r0
			enum_state[port_button_poz]=Bt_pos_edge;
			set_event(port_button_poz);
		}
		else if(buffer[port_button_poz]==0xffff && enum_state[port_button_poz]==Bt_pos_edge)
		{
			enum_state[port_button_poz]=Bt_pressed;
    1328:	68 94       	set
    132a:	aa 24       	eor	r10, r10
    132c:	a1 f8       	bld	r10, 1
		{
			buffer[port_button_poz]|=0x01;
		}
		if((buffer[port_button_poz]&0x00ff)==0x00ff && enum_state[port_button_poz]==Bt_unpressed)
		{
			enum_state[port_button_poz]=Bt_pos_edge;
    132e:	bb 24       	eor	r11, r11
    1330:	b3 94       	inc	r11
{
	
	uint8 port_button_poz=0;
	for (port_button_poz=0;port_button_poz<8;port_button_poz++)
	{
		buffer[port_button_poz]<<=1;
    1332:	8c 2f       	mov	r24, r28
    1334:	9d 2f       	mov	r25, r29
    1336:	f8 01       	movw	r30, r16
    1338:	20 81       	ld	r18, Z
    133a:	31 81       	ldd	r19, Z+1	; 0x01
    133c:	22 0f       	add	r18, r18
    133e:	33 1f       	adc	r19, r19
    1340:	31 83       	std	Z+1, r19	; 0x01
    1342:	20 83       	st	Z, r18
		if(((*port_button>>port_button_poz)&0x01)==0)
    1344:	d6 01       	movw	r26, r12
    1346:	4c 91       	ld	r20, X
    1348:	50 e0       	ldi	r21, 0x00	; 0
    134a:	0c 2e       	mov	r0, r28
    134c:	02 c0       	rjmp	.+4      	; 0x1352 <debounce_D+0x5e>
    134e:	55 95       	asr	r21
    1350:	47 95       	ror	r20
    1352:	0a 94       	dec	r0
    1354:	e2 f7       	brpl	.-8      	; 0x134e <debounce_D+0x5a>
    1356:	40 fd       	sbrc	r20, 0
    1358:	03 c0       	rjmp	.+6      	; 0x1360 <debounce_D+0x6c>
		{
			buffer[port_button_poz]|=0x01;
    135a:	21 60       	ori	r18, 0x01	; 1
    135c:	31 83       	std	Z+1, r19	; 0x01
    135e:	20 83       	st	Z, r18
		}
		if((buffer[port_button_poz]&0x00ff)==0x00ff && enum_state[port_button_poz]==Bt_unpressed)
    1360:	20 81       	ld	r18, Z
    1362:	31 81       	ldd	r19, Z+1	; 0x01
    1364:	0e 5f       	subi	r16, 0xFE	; 254
    1366:	1f 4f       	sbci	r17, 0xFF	; 255
    1368:	a9 01       	movw	r20, r18
    136a:	55 27       	eor	r21, r21
    136c:	4f 3f       	cpi	r20, 0xFF	; 255
    136e:	51 05       	cpc	r21, r1
    1370:	41 f4       	brne	.+16     	; 0x1382 <debounce_D+0x8e>
    1372:	f7 01       	movw	r30, r14
    1374:	60 81       	ld	r22, Z
    1376:	61 11       	cpse	r22, r1
    1378:	04 c0       	rjmp	.+8      	; 0x1382 <debounce_D+0x8e>
		{
			enum_state[port_button_poz]=Bt_pos_edge;
    137a:	b0 82       	st	Z, r11
			set_event(port_button_poz);
    137c:	0e 94 9a 08 	call	0x1134	; 0x1134 <set_event>
		if(((*port_button>>port_button_poz)&0x01)==0)
		{
			buffer[port_button_poz]|=0x01;
		}
		if((buffer[port_button_poz]&0x00ff)==0x00ff && enum_state[port_button_poz]==Bt_unpressed)
		{
    1380:	1a c0       	rjmp	.+52     	; 0x13b6 <debounce_D+0xc2>
			enum_state[port_button_poz]=Bt_pos_edge;
			set_event(port_button_poz);
		}
		else if(buffer[port_button_poz]==0xffff && enum_state[port_button_poz]==Bt_pos_edge)
    1382:	2f 3f       	cpi	r18, 0xFF	; 255
    1384:	ff ef       	ldi	r31, 0xFF	; 255
    1386:	3f 07       	cpc	r19, r31
    1388:	31 f4       	brne	.+12     	; 0x1396 <debounce_D+0xa2>
    138a:	d7 01       	movw	r26, r14
    138c:	8c 91       	ld	r24, X
    138e:	81 30       	cpi	r24, 0x01	; 1
    1390:	11 f4       	brne	.+4      	; 0x1396 <debounce_D+0xa2>
		{
			enum_state[port_button_poz]=Bt_pressed;
    1392:	ac 92       	st	X, r10
    1394:	10 c0       	rjmp	.+32     	; 0x13b6 <debounce_D+0xc2>
		}
		else if((buffer[port_button_poz]&0x00ff)==0 && (buffer[port_button_poz]&0xff00)!=0 && enum_state[port_button_poz]==Bt_pressed)
    1396:	45 2b       	or	r20, r21
    1398:	51 f4       	brne	.+20     	; 0x13ae <debounce_D+0xba>
    139a:	c9 01       	movw	r24, r18
    139c:	88 27       	eor	r24, r24
    139e:	89 2b       	or	r24, r25
    13a0:	31 f0       	breq	.+12     	; 0x13ae <debounce_D+0xba>
    13a2:	f7 01       	movw	r30, r14
    13a4:	80 81       	ld	r24, Z
    13a6:	82 30       	cpi	r24, 0x02	; 2
    13a8:	11 f4       	brne	.+4      	; 0x13ae <debounce_D+0xba>
		{
			enum_state[port_button_poz]=Bt_neg_edge;
    13aa:	90 82       	st	Z, r9
    13ac:	04 c0       	rjmp	.+8      	; 0x13b6 <debounce_D+0xc2>
		}
		else if(buffer[port_button_poz]==0x0000)
    13ae:	23 2b       	or	r18, r19
    13b0:	11 f4       	brne	.+4      	; 0x13b6 <debounce_D+0xc2>
		{
			enum_state[port_button_poz]=Bt_unpressed;
    13b2:	d7 01       	movw	r26, r14
    13b4:	1c 92       	st	X, r1
    13b6:	21 96       	adiw	r28, 0x01	; 1
    13b8:	bf ef       	ldi	r27, 0xFF	; 255
    13ba:	eb 1a       	sub	r14, r27
    13bc:	fb 0a       	sbc	r15, r27

void debounce_D(volatile char *port_button)
{
	
	uint8 port_button_poz=0;
	for (port_button_poz=0;port_button_poz<8;port_button_poz++)
    13be:	c8 30       	cpi	r28, 0x08	; 8
    13c0:	d1 05       	cpc	r29, r1
    13c2:	09 f0       	breq	.+2      	; 0x13c6 <debounce_D+0xd2>
    13c4:	b6 cf       	rjmp	.-148    	; 0x1332 <debounce_D+0x3e>
		else if(buffer[port_button_poz]==0x0000)
		{
			enum_state[port_button_poz]=Bt_unpressed;
		}
	}
}
    13c6:	df 91       	pop	r29
    13c8:	cf 91       	pop	r28
    13ca:	1f 91       	pop	r17
    13cc:	0f 91       	pop	r16
    13ce:	ff 90       	pop	r15
    13d0:	ef 90       	pop	r14
    13d2:	df 90       	pop	r13
    13d4:	cf 90       	pop	r12
    13d6:	bf 90       	pop	r11
    13d8:	af 90       	pop	r10
    13da:	9f 90       	pop	r9
    13dc:	08 95       	ret

000013de <set_pwm_fan_lvl>:


char level=0;
void set_pwm_fan_lvl( unsigned char lvl)
{
	if(ON)
    13de:	90 91 1f 01 	lds	r25, 0x011F
    13e2:	90 ff       	sbrs	r25, 0
    13e4:	17 c0       	rjmp	.+46     	; 0x1414 <set_pwm_fan_lvl+0x36>
	{
		lvl%=4;
    13e6:	83 70       	andi	r24, 0x03	; 3
		if (lvl==0)
    13e8:	21 f4       	brne	.+8      	; 0x13f2 <set_pwm_fan_lvl+0x14>
			level=FAN_LVL_0;
    13ea:	8f ef       	ldi	r24, 0xFF	; 255
    13ec:	80 93 1e 01 	sts	0x011E, r24
    13f0:	08 95       	ret
		else if(lvl==1)
    13f2:	81 30       	cpi	r24, 0x01	; 1
    13f4:	21 f4       	brne	.+8      	; 0x13fe <set_pwm_fan_lvl+0x20>
			level=FAN_LVL_1;
    13f6:	8c ed       	ldi	r24, 0xDC	; 220
    13f8:	80 93 1e 01 	sts	0x011E, r24
    13fc:	08 95       	ret
		else if (lvl==2)
    13fe:	82 30       	cpi	r24, 0x02	; 2
    1400:	21 f4       	brne	.+8      	; 0x140a <set_pwm_fan_lvl+0x2c>
			level=FAN_LVL_2;
    1402:	86 e9       	ldi	r24, 0x96	; 150
    1404:	80 93 1e 01 	sts	0x011E, r24
    1408:	08 95       	ret
		else if (lvl==3)
    140a:	83 30       	cpi	r24, 0x03	; 3
    140c:	31 f4       	brne	.+12     	; 0x141a <set_pwm_fan_lvl+0x3c>
			level=FAN_LVL_3;
    140e:	10 92 1e 01 	sts	0x011E, r1
    1412:	08 95       	ret
	}
	else
	{
		level=FAN_LVL_0;
    1414:	8f ef       	ldi	r24, 0xFF	; 255
    1416:	80 93 1e 01 	sts	0x011E, r24
    141a:	08 95       	ret

0000141c <set_pwm_pow_lvl>:
	//OCR2=lvl*85;
}
char pwm_pow_lvl;
void set_pwm_pow_lvl (unsigned char lvl)
{
	if(ON)
    141c:	90 91 1f 01 	lds	r25, 0x011F
    1420:	90 ff       	sbrs	r25, 0
    1422:	17 c0       	rjmp	.+46     	; 0x1452 <set_pwm_pow_lvl+0x36>
	{
			lvl%=4;
    1424:	83 70       	andi	r24, 0x03	; 3
		if (lvl==0)
    1426:	19 f4       	brne	.+6      	; 0x142e <set_pwm_pow_lvl+0x12>
			pwm_pow_lvl = 0;
    1428:	10 92 26 01 	sts	0x0126, r1
    142c:	08 95       	ret
		else if(lvl==1)
    142e:	81 30       	cpi	r24, 0x01	; 1
    1430:	21 f4       	brne	.+8      	; 0x143a <set_pwm_pow_lvl+0x1e>
			pwm_pow_lvl = 4;
    1432:	84 e0       	ldi	r24, 0x04	; 4
    1434:	80 93 26 01 	sts	0x0126, r24
    1438:	08 95       	ret
		else if (lvl==2)
    143a:	82 30       	cpi	r24, 0x02	; 2
    143c:	21 f4       	brne	.+8      	; 0x1446 <set_pwm_pow_lvl+0x2a>
			pwm_pow_lvl = 300;
    143e:	8c e2       	ldi	r24, 0x2C	; 44
    1440:	80 93 26 01 	sts	0x0126, r24
    1444:	08 95       	ret
		else if (lvl==3)
    1446:	83 30       	cpi	r24, 0x03	; 3
    1448:	31 f4       	brne	.+12     	; 0x1456 <set_pwm_pow_lvl+0x3a>
			pwm_pow_lvl = 1000;
    144a:	88 ee       	ldi	r24, 0xE8	; 232
    144c:	80 93 26 01 	sts	0x0126, r24
    1450:	08 95       	ret
	}
	else
	{
		pwm_pow_lvl=0;
    1452:	10 92 26 01 	sts	0x0126, r1
    1456:	08 95       	ret

00001458 <init_timer0>:
	}
	
}
void init_timer0()
{
	cli();
    1458:	f8 94       	cli
	 TCCR0|=2;
    145a:	83 b7       	in	r24, 0x33	; 51
    145c:	82 60       	ori	r24, 0x02	; 2
    145e:	83 bf       	out	0x33, r24	; 51
	TIMSK |= 1<<TOIE0; 
    1460:	89 b7       	in	r24, 0x39	; 57
    1462:	81 60       	ori	r24, 0x01	; 1
    1464:	89 bf       	out	0x39, r24	; 57
	TCNT0=0;
    1466:	12 be       	out	0x32, r1	; 50
	sei();
    1468:	78 94       	sei
    146a:	08 95       	ret

0000146c <init_timer2>:
}
void init_timer2()
{
	cli();
    146c:	f8 94       	cli
	
	OCR2=255-10;
    146e:	85 ef       	ldi	r24, 0xF5	; 245
    1470:	83 bd       	out	0x23, r24	; 35
	TCCR2=0x6b;
    1472:	8b e6       	ldi	r24, 0x6B	; 107
    1474:	85 bd       	out	0x25, r24	; 37
	TIMSK |= 1<<OCIE2;
    1476:	89 b7       	in	r24, 0x39	; 57
    1478:	80 68       	ori	r24, 0x80	; 128
    147a:	89 bf       	out	0x39, r24	; 57
	TIFR  |= 1<<OCF2; 
    147c:	88 b7       	in	r24, 0x38	; 56
    147e:	80 68       	ori	r24, 0x80	; 128
    1480:	88 bf       	out	0x38, r24	; 56
	ASSR &= 0xf0;
    1482:	82 b5       	in	r24, 0x22	; 34
    1484:	80 7f       	andi	r24, 0xF0	; 240
    1486:	82 bd       	out	0x22, r24	; 34
	
	sei();
    1488:	78 94       	sei
    148a:	08 95       	ret

0000148c <__vector_4>:
}

double count_gradient=255*50;
ISR(TIMER2_COMP_vect)
{
    148c:	1f 92       	push	r1
    148e:	0f 92       	push	r0
    1490:	0f b6       	in	r0, 0x3f	; 63
    1492:	0f 92       	push	r0
    1494:	11 24       	eor	r1, r1
    1496:	8f 92       	push	r8
    1498:	9f 92       	push	r9
    149a:	af 92       	push	r10
    149c:	bf 92       	push	r11
    149e:	cf 92       	push	r12
    14a0:	df 92       	push	r13
    14a2:	ef 92       	push	r14
    14a4:	ff 92       	push	r15
    14a6:	2f 93       	push	r18
    14a8:	3f 93       	push	r19
    14aa:	4f 93       	push	r20
    14ac:	5f 93       	push	r21
    14ae:	6f 93       	push	r22
    14b0:	7f 93       	push	r23
    14b2:	8f 93       	push	r24
    14b4:	9f 93       	push	r25
    14b6:	af 93       	push	r26
    14b8:	bf 93       	push	r27
    14ba:	ef 93       	push	r30
    14bc:	ff 93       	push	r31
	if(count_gradient>level*50)
    14be:	60 91 1e 01 	lds	r22, 0x011E
    14c2:	82 e3       	ldi	r24, 0x32	; 50
    14c4:	68 9f       	mul	r22, r24
    14c6:	b0 01       	movw	r22, r0
    14c8:	11 24       	eor	r1, r1
    14ca:	88 27       	eor	r24, r24
    14cc:	77 fd       	sbrc	r23, 7
    14ce:	80 95       	com	r24
    14d0:	98 2f       	mov	r25, r24
    14d2:	0e 94 f7 0b 	call	0x17ee	; 0x17ee <__floatsisf>
    14d6:	6b 01       	movw	r12, r22
    14d8:	7c 01       	movw	r14, r24
    14da:	80 90 66 00 	lds	r8, 0x0066
    14de:	90 90 67 00 	lds	r9, 0x0067
    14e2:	a0 90 68 00 	lds	r10, 0x0068
    14e6:	b0 90 69 00 	lds	r11, 0x0069
    14ea:	a5 01       	movw	r20, r10
    14ec:	94 01       	movw	r18, r8
    14ee:	0e 94 58 0b 	call	0x16b0	; 0x16b0 <__cmpsf2>
    14f2:	88 23       	and	r24, r24
    14f4:	84 f4       	brge	.+32     	; 0x1516 <__vector_4+0x8a>
		count_gradient--;
    14f6:	20 e0       	ldi	r18, 0x00	; 0
    14f8:	30 e0       	ldi	r19, 0x00	; 0
    14fa:	40 e8       	ldi	r20, 0x80	; 128
    14fc:	5f e3       	ldi	r21, 0x3F	; 63
    14fe:	c5 01       	movw	r24, r10
    1500:	b4 01       	movw	r22, r8
    1502:	0e 94 f3 0a 	call	0x15e6	; 0x15e6 <__subsf3>
    1506:	60 93 66 00 	sts	0x0066, r22
    150a:	70 93 67 00 	sts	0x0067, r23
    150e:	80 93 68 00 	sts	0x0068, r24
    1512:	90 93 69 00 	sts	0x0069, r25
	if(count_gradient<level*50)
    1516:	80 90 66 00 	lds	r8, 0x0066
    151a:	90 90 67 00 	lds	r9, 0x0067
    151e:	a0 90 68 00 	lds	r10, 0x0068
    1522:	b0 90 69 00 	lds	r11, 0x0069
    1526:	a5 01       	movw	r20, r10
    1528:	94 01       	movw	r18, r8
    152a:	c7 01       	movw	r24, r14
    152c:	b6 01       	movw	r22, r12
    152e:	0e 94 a7 0c 	call	0x194e	; 0x194e <__gesf2>
    1532:	18 16       	cp	r1, r24
    1534:	84 f4       	brge	.+32     	; 0x1556 <__vector_4+0xca>
		count_gradient++;
    1536:	20 e0       	ldi	r18, 0x00	; 0
    1538:	30 e0       	ldi	r19, 0x00	; 0
    153a:	40 e8       	ldi	r20, 0x80	; 128
    153c:	5f e3       	ldi	r21, 0x3F	; 63
    153e:	c5 01       	movw	r24, r10
    1540:	b4 01       	movw	r22, r8
    1542:	0e 94 f4 0a 	call	0x15e8	; 0x15e8 <__addsf3>
    1546:	60 93 66 00 	sts	0x0066, r22
    154a:	70 93 67 00 	sts	0x0067, r23
    154e:	80 93 68 00 	sts	0x0068, r24
    1552:	90 93 69 00 	sts	0x0069, r25
	OCR2=count_gradient/50;
    1556:	20 e0       	ldi	r18, 0x00	; 0
    1558:	30 e0       	ldi	r19, 0x00	; 0
    155a:	48 e4       	ldi	r20, 0x48	; 72
    155c:	52 e4       	ldi	r21, 0x42	; 66
    155e:	60 91 66 00 	lds	r22, 0x0066
    1562:	70 91 67 00 	lds	r23, 0x0067
    1566:	80 91 68 00 	lds	r24, 0x0068
    156a:	90 91 69 00 	lds	r25, 0x0069
    156e:	0e 94 5c 0b 	call	0x16b8	; 0x16b8 <__divsf3>
    1572:	0e 94 c9 0b 	call	0x1792	; 0x1792 <__fixunssfsi>
    1576:	63 bd       	out	0x23, r22	; 35
	

}
    1578:	ff 91       	pop	r31
    157a:	ef 91       	pop	r30
    157c:	bf 91       	pop	r27
    157e:	af 91       	pop	r26
    1580:	9f 91       	pop	r25
    1582:	8f 91       	pop	r24
    1584:	7f 91       	pop	r23
    1586:	6f 91       	pop	r22
    1588:	5f 91       	pop	r21
    158a:	4f 91       	pop	r20
    158c:	3f 91       	pop	r19
    158e:	2f 91       	pop	r18
    1590:	ff 90       	pop	r15
    1592:	ef 90       	pop	r14
    1594:	df 90       	pop	r13
    1596:	cf 90       	pop	r12
    1598:	bf 90       	pop	r11
    159a:	af 90       	pop	r10
    159c:	9f 90       	pop	r9
    159e:	8f 90       	pop	r8
    15a0:	0f 90       	pop	r0
    15a2:	0f be       	out	0x3f, r0	; 63
    15a4:	0f 90       	pop	r0
    15a6:	1f 90       	pop	r1
    15a8:	18 95       	reti

000015aa <__vector_11>:
char count=0;
ISR(TIMER0_OVF_vect)
{
    15aa:	1f 92       	push	r1
    15ac:	0f 92       	push	r0
    15ae:	0f b6       	in	r0, 0x3f	; 63
    15b0:	0f 92       	push	r0
    15b2:	11 24       	eor	r1, r1
    15b4:	8f 93       	push	r24
    15b6:	9f 93       	push	r25
	
	
	if ( count >= 1000 )
		count =0;
		
	if ( count < pwm_pow_lvl )
    15b8:	90 91 1d 01 	lds	r25, 0x011D
    15bc:	80 91 26 01 	lds	r24, 0x0126
    15c0:	98 17       	cp	r25, r24
    15c2:	10 f4       	brcc	.+4      	; 0x15c8 <__vector_11+0x1e>
		PORTD &= ~(1<<6);
    15c4:	96 98       	cbi	0x12, 6	; 18
    15c6:	01 c0       	rjmp	.+2      	; 0x15ca <__vector_11+0x20>
	else 
		PORTD |= 64;
    15c8:	96 9a       	sbi	0x12, 6	; 18
		
	TCNT0=250;
    15ca:	8a ef       	ldi	r24, 0xFA	; 250
    15cc:	82 bf       	out	0x32, r24	; 50
	count++;
    15ce:	80 91 1d 01 	lds	r24, 0x011D
    15d2:	8f 5f       	subi	r24, 0xFF	; 255
    15d4:	80 93 1d 01 	sts	0x011D, r24
    15d8:	9f 91       	pop	r25
    15da:	8f 91       	pop	r24
    15dc:	0f 90       	pop	r0
    15de:	0f be       	out	0x3f, r0	; 63
    15e0:	0f 90       	pop	r0
    15e2:	1f 90       	pop	r1
    15e4:	18 95       	reti

000015e6 <__subsf3>:
    15e6:	50 58       	subi	r21, 0x80	; 128

000015e8 <__addsf3>:
    15e8:	bb 27       	eor	r27, r27
    15ea:	aa 27       	eor	r26, r26
    15ec:	0e d0       	rcall	.+28     	; 0x160a <__addsf3x>
    15ee:	75 c1       	rjmp	.+746    	; 0x18da <__fp_round>
    15f0:	66 d1       	rcall	.+716    	; 0x18be <__fp_pscA>
    15f2:	30 f0       	brcs	.+12     	; 0x1600 <__addsf3+0x18>
    15f4:	6b d1       	rcall	.+726    	; 0x18cc <__fp_pscB>
    15f6:	20 f0       	brcs	.+8      	; 0x1600 <__addsf3+0x18>
    15f8:	31 f4       	brne	.+12     	; 0x1606 <__addsf3+0x1e>
    15fa:	9f 3f       	cpi	r25, 0xFF	; 255
    15fc:	11 f4       	brne	.+4      	; 0x1602 <__addsf3+0x1a>
    15fe:	1e f4       	brtc	.+6      	; 0x1606 <__addsf3+0x1e>
    1600:	5b c1       	rjmp	.+694    	; 0x18b8 <__fp_nan>
    1602:	0e f4       	brtc	.+2      	; 0x1606 <__addsf3+0x1e>
    1604:	e0 95       	com	r30
    1606:	e7 fb       	bst	r30, 7
    1608:	51 c1       	rjmp	.+674    	; 0x18ac <__fp_inf>

0000160a <__addsf3x>:
    160a:	e9 2f       	mov	r30, r25
    160c:	77 d1       	rcall	.+750    	; 0x18fc <__fp_split3>
    160e:	80 f3       	brcs	.-32     	; 0x15f0 <__addsf3+0x8>
    1610:	ba 17       	cp	r27, r26
    1612:	62 07       	cpc	r22, r18
    1614:	73 07       	cpc	r23, r19
    1616:	84 07       	cpc	r24, r20
    1618:	95 07       	cpc	r25, r21
    161a:	18 f0       	brcs	.+6      	; 0x1622 <__addsf3x+0x18>
    161c:	71 f4       	brne	.+28     	; 0x163a <__addsf3x+0x30>
    161e:	9e f5       	brtc	.+102    	; 0x1686 <__addsf3x+0x7c>
    1620:	8f c1       	rjmp	.+798    	; 0x1940 <__fp_zero>
    1622:	0e f4       	brtc	.+2      	; 0x1626 <__addsf3x+0x1c>
    1624:	e0 95       	com	r30
    1626:	0b 2e       	mov	r0, r27
    1628:	ba 2f       	mov	r27, r26
    162a:	a0 2d       	mov	r26, r0
    162c:	0b 01       	movw	r0, r22
    162e:	b9 01       	movw	r22, r18
    1630:	90 01       	movw	r18, r0
    1632:	0c 01       	movw	r0, r24
    1634:	ca 01       	movw	r24, r20
    1636:	a0 01       	movw	r20, r0
    1638:	11 24       	eor	r1, r1
    163a:	ff 27       	eor	r31, r31
    163c:	59 1b       	sub	r21, r25
    163e:	99 f0       	breq	.+38     	; 0x1666 <__addsf3x+0x5c>
    1640:	59 3f       	cpi	r21, 0xF9	; 249
    1642:	50 f4       	brcc	.+20     	; 0x1658 <__addsf3x+0x4e>
    1644:	50 3e       	cpi	r21, 0xE0	; 224
    1646:	68 f1       	brcs	.+90     	; 0x16a2 <__addsf3x+0x98>
    1648:	1a 16       	cp	r1, r26
    164a:	f0 40       	sbci	r31, 0x00	; 0
    164c:	a2 2f       	mov	r26, r18
    164e:	23 2f       	mov	r18, r19
    1650:	34 2f       	mov	r19, r20
    1652:	44 27       	eor	r20, r20
    1654:	58 5f       	subi	r21, 0xF8	; 248
    1656:	f3 cf       	rjmp	.-26     	; 0x163e <__addsf3x+0x34>
    1658:	46 95       	lsr	r20
    165a:	37 95       	ror	r19
    165c:	27 95       	ror	r18
    165e:	a7 95       	ror	r26
    1660:	f0 40       	sbci	r31, 0x00	; 0
    1662:	53 95       	inc	r21
    1664:	c9 f7       	brne	.-14     	; 0x1658 <__addsf3x+0x4e>
    1666:	7e f4       	brtc	.+30     	; 0x1686 <__addsf3x+0x7c>
    1668:	1f 16       	cp	r1, r31
    166a:	ba 0b       	sbc	r27, r26
    166c:	62 0b       	sbc	r22, r18
    166e:	73 0b       	sbc	r23, r19
    1670:	84 0b       	sbc	r24, r20
    1672:	ba f0       	brmi	.+46     	; 0x16a2 <__addsf3x+0x98>
    1674:	91 50       	subi	r25, 0x01	; 1
    1676:	a1 f0       	breq	.+40     	; 0x16a0 <__addsf3x+0x96>
    1678:	ff 0f       	add	r31, r31
    167a:	bb 1f       	adc	r27, r27
    167c:	66 1f       	adc	r22, r22
    167e:	77 1f       	adc	r23, r23
    1680:	88 1f       	adc	r24, r24
    1682:	c2 f7       	brpl	.-16     	; 0x1674 <__addsf3x+0x6a>
    1684:	0e c0       	rjmp	.+28     	; 0x16a2 <__addsf3x+0x98>
    1686:	ba 0f       	add	r27, r26
    1688:	62 1f       	adc	r22, r18
    168a:	73 1f       	adc	r23, r19
    168c:	84 1f       	adc	r24, r20
    168e:	48 f4       	brcc	.+18     	; 0x16a2 <__addsf3x+0x98>
    1690:	87 95       	ror	r24
    1692:	77 95       	ror	r23
    1694:	67 95       	ror	r22
    1696:	b7 95       	ror	r27
    1698:	f7 95       	ror	r31
    169a:	9e 3f       	cpi	r25, 0xFE	; 254
    169c:	08 f0       	brcs	.+2      	; 0x16a0 <__addsf3x+0x96>
    169e:	b3 cf       	rjmp	.-154    	; 0x1606 <__addsf3+0x1e>
    16a0:	93 95       	inc	r25
    16a2:	88 0f       	add	r24, r24
    16a4:	08 f0       	brcs	.+2      	; 0x16a8 <__addsf3x+0x9e>
    16a6:	99 27       	eor	r25, r25
    16a8:	ee 0f       	add	r30, r30
    16aa:	97 95       	ror	r25
    16ac:	87 95       	ror	r24
    16ae:	08 95       	ret

000016b0 <__cmpsf2>:
    16b0:	d9 d0       	rcall	.+434    	; 0x1864 <__fp_cmp>
    16b2:	08 f4       	brcc	.+2      	; 0x16b6 <__cmpsf2+0x6>
    16b4:	81 e0       	ldi	r24, 0x01	; 1
    16b6:	08 95       	ret

000016b8 <__divsf3>:
    16b8:	0c d0       	rcall	.+24     	; 0x16d2 <__divsf3x>
    16ba:	0f c1       	rjmp	.+542    	; 0x18da <__fp_round>
    16bc:	07 d1       	rcall	.+526    	; 0x18cc <__fp_pscB>
    16be:	40 f0       	brcs	.+16     	; 0x16d0 <__divsf3+0x18>
    16c0:	fe d0       	rcall	.+508    	; 0x18be <__fp_pscA>
    16c2:	30 f0       	brcs	.+12     	; 0x16d0 <__divsf3+0x18>
    16c4:	21 f4       	brne	.+8      	; 0x16ce <__divsf3+0x16>
    16c6:	5f 3f       	cpi	r21, 0xFF	; 255
    16c8:	19 f0       	breq	.+6      	; 0x16d0 <__divsf3+0x18>
    16ca:	f0 c0       	rjmp	.+480    	; 0x18ac <__fp_inf>
    16cc:	51 11       	cpse	r21, r1
    16ce:	39 c1       	rjmp	.+626    	; 0x1942 <__fp_szero>
    16d0:	f3 c0       	rjmp	.+486    	; 0x18b8 <__fp_nan>

000016d2 <__divsf3x>:
    16d2:	14 d1       	rcall	.+552    	; 0x18fc <__fp_split3>
    16d4:	98 f3       	brcs	.-26     	; 0x16bc <__divsf3+0x4>

000016d6 <__divsf3_pse>:
    16d6:	99 23       	and	r25, r25
    16d8:	c9 f3       	breq	.-14     	; 0x16cc <__divsf3+0x14>
    16da:	55 23       	and	r21, r21
    16dc:	b1 f3       	breq	.-20     	; 0x16ca <__divsf3+0x12>
    16de:	95 1b       	sub	r25, r21
    16e0:	55 0b       	sbc	r21, r21
    16e2:	bb 27       	eor	r27, r27
    16e4:	aa 27       	eor	r26, r26
    16e6:	62 17       	cp	r22, r18
    16e8:	73 07       	cpc	r23, r19
    16ea:	84 07       	cpc	r24, r20
    16ec:	38 f0       	brcs	.+14     	; 0x16fc <__divsf3_pse+0x26>
    16ee:	9f 5f       	subi	r25, 0xFF	; 255
    16f0:	5f 4f       	sbci	r21, 0xFF	; 255
    16f2:	22 0f       	add	r18, r18
    16f4:	33 1f       	adc	r19, r19
    16f6:	44 1f       	adc	r20, r20
    16f8:	aa 1f       	adc	r26, r26
    16fa:	a9 f3       	breq	.-22     	; 0x16e6 <__divsf3_pse+0x10>
    16fc:	33 d0       	rcall	.+102    	; 0x1764 <__divsf3_pse+0x8e>
    16fe:	0e 2e       	mov	r0, r30
    1700:	3a f0       	brmi	.+14     	; 0x1710 <__divsf3_pse+0x3a>
    1702:	e0 e8       	ldi	r30, 0x80	; 128
    1704:	30 d0       	rcall	.+96     	; 0x1766 <__divsf3_pse+0x90>
    1706:	91 50       	subi	r25, 0x01	; 1
    1708:	50 40       	sbci	r21, 0x00	; 0
    170a:	e6 95       	lsr	r30
    170c:	00 1c       	adc	r0, r0
    170e:	ca f7       	brpl	.-14     	; 0x1702 <__divsf3_pse+0x2c>
    1710:	29 d0       	rcall	.+82     	; 0x1764 <__divsf3_pse+0x8e>
    1712:	fe 2f       	mov	r31, r30
    1714:	27 d0       	rcall	.+78     	; 0x1764 <__divsf3_pse+0x8e>
    1716:	66 0f       	add	r22, r22
    1718:	77 1f       	adc	r23, r23
    171a:	88 1f       	adc	r24, r24
    171c:	bb 1f       	adc	r27, r27
    171e:	26 17       	cp	r18, r22
    1720:	37 07       	cpc	r19, r23
    1722:	48 07       	cpc	r20, r24
    1724:	ab 07       	cpc	r26, r27
    1726:	b0 e8       	ldi	r27, 0x80	; 128
    1728:	09 f0       	breq	.+2      	; 0x172c <__divsf3_pse+0x56>
    172a:	bb 0b       	sbc	r27, r27
    172c:	80 2d       	mov	r24, r0
    172e:	bf 01       	movw	r22, r30
    1730:	ff 27       	eor	r31, r31
    1732:	93 58       	subi	r25, 0x83	; 131
    1734:	5f 4f       	sbci	r21, 0xFF	; 255
    1736:	2a f0       	brmi	.+10     	; 0x1742 <__divsf3_pse+0x6c>
    1738:	9e 3f       	cpi	r25, 0xFE	; 254
    173a:	51 05       	cpc	r21, r1
    173c:	68 f0       	brcs	.+26     	; 0x1758 <__divsf3_pse+0x82>
    173e:	b6 c0       	rjmp	.+364    	; 0x18ac <__fp_inf>
    1740:	00 c1       	rjmp	.+512    	; 0x1942 <__fp_szero>
    1742:	5f 3f       	cpi	r21, 0xFF	; 255
    1744:	ec f3       	brlt	.-6      	; 0x1740 <__divsf3_pse+0x6a>
    1746:	98 3e       	cpi	r25, 0xE8	; 232
    1748:	dc f3       	brlt	.-10     	; 0x1740 <__divsf3_pse+0x6a>
    174a:	86 95       	lsr	r24
    174c:	77 95       	ror	r23
    174e:	67 95       	ror	r22
    1750:	b7 95       	ror	r27
    1752:	f7 95       	ror	r31
    1754:	9f 5f       	subi	r25, 0xFF	; 255
    1756:	c9 f7       	brne	.-14     	; 0x174a <__divsf3_pse+0x74>
    1758:	88 0f       	add	r24, r24
    175a:	91 1d       	adc	r25, r1
    175c:	96 95       	lsr	r25
    175e:	87 95       	ror	r24
    1760:	97 f9       	bld	r25, 7
    1762:	08 95       	ret
    1764:	e1 e0       	ldi	r30, 0x01	; 1
    1766:	66 0f       	add	r22, r22
    1768:	77 1f       	adc	r23, r23
    176a:	88 1f       	adc	r24, r24
    176c:	bb 1f       	adc	r27, r27
    176e:	62 17       	cp	r22, r18
    1770:	73 07       	cpc	r23, r19
    1772:	84 07       	cpc	r24, r20
    1774:	ba 07       	cpc	r27, r26
    1776:	20 f0       	brcs	.+8      	; 0x1780 <__divsf3_pse+0xaa>
    1778:	62 1b       	sub	r22, r18
    177a:	73 0b       	sbc	r23, r19
    177c:	84 0b       	sbc	r24, r20
    177e:	ba 0b       	sbc	r27, r26
    1780:	ee 1f       	adc	r30, r30
    1782:	88 f7       	brcc	.-30     	; 0x1766 <__divsf3_pse+0x90>
    1784:	e0 95       	com	r30
    1786:	08 95       	ret

00001788 <__fixsfsi>:
    1788:	04 d0       	rcall	.+8      	; 0x1792 <__fixunssfsi>
    178a:	68 94       	set
    178c:	b1 11       	cpse	r27, r1
    178e:	d9 c0       	rjmp	.+434    	; 0x1942 <__fp_szero>
    1790:	08 95       	ret

00001792 <__fixunssfsi>:
    1792:	bc d0       	rcall	.+376    	; 0x190c <__fp_splitA>
    1794:	88 f0       	brcs	.+34     	; 0x17b8 <__fixunssfsi+0x26>
    1796:	9f 57       	subi	r25, 0x7F	; 127
    1798:	90 f0       	brcs	.+36     	; 0x17be <__fixunssfsi+0x2c>
    179a:	b9 2f       	mov	r27, r25
    179c:	99 27       	eor	r25, r25
    179e:	b7 51       	subi	r27, 0x17	; 23
    17a0:	a0 f0       	brcs	.+40     	; 0x17ca <__fixunssfsi+0x38>
    17a2:	d1 f0       	breq	.+52     	; 0x17d8 <__fixunssfsi+0x46>
    17a4:	66 0f       	add	r22, r22
    17a6:	77 1f       	adc	r23, r23
    17a8:	88 1f       	adc	r24, r24
    17aa:	99 1f       	adc	r25, r25
    17ac:	1a f0       	brmi	.+6      	; 0x17b4 <__fixunssfsi+0x22>
    17ae:	ba 95       	dec	r27
    17b0:	c9 f7       	brne	.-14     	; 0x17a4 <__fixunssfsi+0x12>
    17b2:	12 c0       	rjmp	.+36     	; 0x17d8 <__fixunssfsi+0x46>
    17b4:	b1 30       	cpi	r27, 0x01	; 1
    17b6:	81 f0       	breq	.+32     	; 0x17d8 <__fixunssfsi+0x46>
    17b8:	c3 d0       	rcall	.+390    	; 0x1940 <__fp_zero>
    17ba:	b1 e0       	ldi	r27, 0x01	; 1
    17bc:	08 95       	ret
    17be:	c0 c0       	rjmp	.+384    	; 0x1940 <__fp_zero>
    17c0:	67 2f       	mov	r22, r23
    17c2:	78 2f       	mov	r23, r24
    17c4:	88 27       	eor	r24, r24
    17c6:	b8 5f       	subi	r27, 0xF8	; 248
    17c8:	39 f0       	breq	.+14     	; 0x17d8 <__fixunssfsi+0x46>
    17ca:	b9 3f       	cpi	r27, 0xF9	; 249
    17cc:	cc f3       	brlt	.-14     	; 0x17c0 <__fixunssfsi+0x2e>
    17ce:	86 95       	lsr	r24
    17d0:	77 95       	ror	r23
    17d2:	67 95       	ror	r22
    17d4:	b3 95       	inc	r27
    17d6:	d9 f7       	brne	.-10     	; 0x17ce <__fixunssfsi+0x3c>
    17d8:	3e f4       	brtc	.+14     	; 0x17e8 <__fixunssfsi+0x56>
    17da:	90 95       	com	r25
    17dc:	80 95       	com	r24
    17de:	70 95       	com	r23
    17e0:	61 95       	neg	r22
    17e2:	7f 4f       	sbci	r23, 0xFF	; 255
    17e4:	8f 4f       	sbci	r24, 0xFF	; 255
    17e6:	9f 4f       	sbci	r25, 0xFF	; 255
    17e8:	08 95       	ret

000017ea <__floatunsisf>:
    17ea:	e8 94       	clt
    17ec:	09 c0       	rjmp	.+18     	; 0x1800 <__floatsisf+0x12>

000017ee <__floatsisf>:
    17ee:	97 fb       	bst	r25, 7
    17f0:	3e f4       	brtc	.+14     	; 0x1800 <__floatsisf+0x12>
    17f2:	90 95       	com	r25
    17f4:	80 95       	com	r24
    17f6:	70 95       	com	r23
    17f8:	61 95       	neg	r22
    17fa:	7f 4f       	sbci	r23, 0xFF	; 255
    17fc:	8f 4f       	sbci	r24, 0xFF	; 255
    17fe:	9f 4f       	sbci	r25, 0xFF	; 255
    1800:	99 23       	and	r25, r25
    1802:	a9 f0       	breq	.+42     	; 0x182e <__floatsisf+0x40>
    1804:	f9 2f       	mov	r31, r25
    1806:	96 e9       	ldi	r25, 0x96	; 150
    1808:	bb 27       	eor	r27, r27
    180a:	93 95       	inc	r25
    180c:	f6 95       	lsr	r31
    180e:	87 95       	ror	r24
    1810:	77 95       	ror	r23
    1812:	67 95       	ror	r22
    1814:	b7 95       	ror	r27
    1816:	f1 11       	cpse	r31, r1
    1818:	f8 cf       	rjmp	.-16     	; 0x180a <__floatsisf+0x1c>
    181a:	fa f4       	brpl	.+62     	; 0x185a <__floatsisf+0x6c>
    181c:	bb 0f       	add	r27, r27
    181e:	11 f4       	brne	.+4      	; 0x1824 <__floatsisf+0x36>
    1820:	60 ff       	sbrs	r22, 0
    1822:	1b c0       	rjmp	.+54     	; 0x185a <__floatsisf+0x6c>
    1824:	6f 5f       	subi	r22, 0xFF	; 255
    1826:	7f 4f       	sbci	r23, 0xFF	; 255
    1828:	8f 4f       	sbci	r24, 0xFF	; 255
    182a:	9f 4f       	sbci	r25, 0xFF	; 255
    182c:	16 c0       	rjmp	.+44     	; 0x185a <__floatsisf+0x6c>
    182e:	88 23       	and	r24, r24
    1830:	11 f0       	breq	.+4      	; 0x1836 <__floatsisf+0x48>
    1832:	96 e9       	ldi	r25, 0x96	; 150
    1834:	11 c0       	rjmp	.+34     	; 0x1858 <__floatsisf+0x6a>
    1836:	77 23       	and	r23, r23
    1838:	21 f0       	breq	.+8      	; 0x1842 <__floatsisf+0x54>
    183a:	9e e8       	ldi	r25, 0x8E	; 142
    183c:	87 2f       	mov	r24, r23
    183e:	76 2f       	mov	r23, r22
    1840:	05 c0       	rjmp	.+10     	; 0x184c <__floatsisf+0x5e>
    1842:	66 23       	and	r22, r22
    1844:	71 f0       	breq	.+28     	; 0x1862 <__floatsisf+0x74>
    1846:	96 e8       	ldi	r25, 0x86	; 134
    1848:	86 2f       	mov	r24, r22
    184a:	70 e0       	ldi	r23, 0x00	; 0
    184c:	60 e0       	ldi	r22, 0x00	; 0
    184e:	2a f0       	brmi	.+10     	; 0x185a <__floatsisf+0x6c>
    1850:	9a 95       	dec	r25
    1852:	66 0f       	add	r22, r22
    1854:	77 1f       	adc	r23, r23
    1856:	88 1f       	adc	r24, r24
    1858:	da f7       	brpl	.-10     	; 0x1850 <__floatsisf+0x62>
    185a:	88 0f       	add	r24, r24
    185c:	96 95       	lsr	r25
    185e:	87 95       	ror	r24
    1860:	97 f9       	bld	r25, 7
    1862:	08 95       	ret

00001864 <__fp_cmp>:
    1864:	99 0f       	add	r25, r25
    1866:	00 08       	sbc	r0, r0
    1868:	55 0f       	add	r21, r21
    186a:	aa 0b       	sbc	r26, r26
    186c:	e0 e8       	ldi	r30, 0x80	; 128
    186e:	fe ef       	ldi	r31, 0xFE	; 254
    1870:	16 16       	cp	r1, r22
    1872:	17 06       	cpc	r1, r23
    1874:	e8 07       	cpc	r30, r24
    1876:	f9 07       	cpc	r31, r25
    1878:	c0 f0       	brcs	.+48     	; 0x18aa <__fp_cmp+0x46>
    187a:	12 16       	cp	r1, r18
    187c:	13 06       	cpc	r1, r19
    187e:	e4 07       	cpc	r30, r20
    1880:	f5 07       	cpc	r31, r21
    1882:	98 f0       	brcs	.+38     	; 0x18aa <__fp_cmp+0x46>
    1884:	62 1b       	sub	r22, r18
    1886:	73 0b       	sbc	r23, r19
    1888:	84 0b       	sbc	r24, r20
    188a:	95 0b       	sbc	r25, r21
    188c:	39 f4       	brne	.+14     	; 0x189c <__fp_cmp+0x38>
    188e:	0a 26       	eor	r0, r26
    1890:	61 f0       	breq	.+24     	; 0x18aa <__fp_cmp+0x46>
    1892:	23 2b       	or	r18, r19
    1894:	24 2b       	or	r18, r20
    1896:	25 2b       	or	r18, r21
    1898:	21 f4       	brne	.+8      	; 0x18a2 <__fp_cmp+0x3e>
    189a:	08 95       	ret
    189c:	0a 26       	eor	r0, r26
    189e:	09 f4       	brne	.+2      	; 0x18a2 <__fp_cmp+0x3e>
    18a0:	a1 40       	sbci	r26, 0x01	; 1
    18a2:	a6 95       	lsr	r26
    18a4:	8f ef       	ldi	r24, 0xFF	; 255
    18a6:	81 1d       	adc	r24, r1
    18a8:	81 1d       	adc	r24, r1
    18aa:	08 95       	ret

000018ac <__fp_inf>:
    18ac:	97 f9       	bld	r25, 7
    18ae:	9f 67       	ori	r25, 0x7F	; 127
    18b0:	80 e8       	ldi	r24, 0x80	; 128
    18b2:	70 e0       	ldi	r23, 0x00	; 0
    18b4:	60 e0       	ldi	r22, 0x00	; 0
    18b6:	08 95       	ret

000018b8 <__fp_nan>:
    18b8:	9f ef       	ldi	r25, 0xFF	; 255
    18ba:	80 ec       	ldi	r24, 0xC0	; 192
    18bc:	08 95       	ret

000018be <__fp_pscA>:
    18be:	00 24       	eor	r0, r0
    18c0:	0a 94       	dec	r0
    18c2:	16 16       	cp	r1, r22
    18c4:	17 06       	cpc	r1, r23
    18c6:	18 06       	cpc	r1, r24
    18c8:	09 06       	cpc	r0, r25
    18ca:	08 95       	ret

000018cc <__fp_pscB>:
    18cc:	00 24       	eor	r0, r0
    18ce:	0a 94       	dec	r0
    18d0:	12 16       	cp	r1, r18
    18d2:	13 06       	cpc	r1, r19
    18d4:	14 06       	cpc	r1, r20
    18d6:	05 06       	cpc	r0, r21
    18d8:	08 95       	ret

000018da <__fp_round>:
    18da:	09 2e       	mov	r0, r25
    18dc:	03 94       	inc	r0
    18de:	00 0c       	add	r0, r0
    18e0:	11 f4       	brne	.+4      	; 0x18e6 <__fp_round+0xc>
    18e2:	88 23       	and	r24, r24
    18e4:	52 f0       	brmi	.+20     	; 0x18fa <__fp_round+0x20>
    18e6:	bb 0f       	add	r27, r27
    18e8:	40 f4       	brcc	.+16     	; 0x18fa <__fp_round+0x20>
    18ea:	bf 2b       	or	r27, r31
    18ec:	11 f4       	brne	.+4      	; 0x18f2 <__fp_round+0x18>
    18ee:	60 ff       	sbrs	r22, 0
    18f0:	04 c0       	rjmp	.+8      	; 0x18fa <__fp_round+0x20>
    18f2:	6f 5f       	subi	r22, 0xFF	; 255
    18f4:	7f 4f       	sbci	r23, 0xFF	; 255
    18f6:	8f 4f       	sbci	r24, 0xFF	; 255
    18f8:	9f 4f       	sbci	r25, 0xFF	; 255
    18fa:	08 95       	ret

000018fc <__fp_split3>:
    18fc:	57 fd       	sbrc	r21, 7
    18fe:	90 58       	subi	r25, 0x80	; 128
    1900:	44 0f       	add	r20, r20
    1902:	55 1f       	adc	r21, r21
    1904:	59 f0       	breq	.+22     	; 0x191c <__fp_splitA+0x10>
    1906:	5f 3f       	cpi	r21, 0xFF	; 255
    1908:	71 f0       	breq	.+28     	; 0x1926 <__fp_splitA+0x1a>
    190a:	47 95       	ror	r20

0000190c <__fp_splitA>:
    190c:	88 0f       	add	r24, r24
    190e:	97 fb       	bst	r25, 7
    1910:	99 1f       	adc	r25, r25
    1912:	61 f0       	breq	.+24     	; 0x192c <__fp_splitA+0x20>
    1914:	9f 3f       	cpi	r25, 0xFF	; 255
    1916:	79 f0       	breq	.+30     	; 0x1936 <__fp_splitA+0x2a>
    1918:	87 95       	ror	r24
    191a:	08 95       	ret
    191c:	12 16       	cp	r1, r18
    191e:	13 06       	cpc	r1, r19
    1920:	14 06       	cpc	r1, r20
    1922:	55 1f       	adc	r21, r21
    1924:	f2 cf       	rjmp	.-28     	; 0x190a <__fp_split3+0xe>
    1926:	46 95       	lsr	r20
    1928:	f1 df       	rcall	.-30     	; 0x190c <__fp_splitA>
    192a:	08 c0       	rjmp	.+16     	; 0x193c <__fp_splitA+0x30>
    192c:	16 16       	cp	r1, r22
    192e:	17 06       	cpc	r1, r23
    1930:	18 06       	cpc	r1, r24
    1932:	99 1f       	adc	r25, r25
    1934:	f1 cf       	rjmp	.-30     	; 0x1918 <__fp_splitA+0xc>
    1936:	86 95       	lsr	r24
    1938:	71 05       	cpc	r23, r1
    193a:	61 05       	cpc	r22, r1
    193c:	08 94       	sec
    193e:	08 95       	ret

00001940 <__fp_zero>:
    1940:	e8 94       	clt

00001942 <__fp_szero>:
    1942:	bb 27       	eor	r27, r27
    1944:	66 27       	eor	r22, r22
    1946:	77 27       	eor	r23, r23
    1948:	cb 01       	movw	r24, r22
    194a:	97 f9       	bld	r25, 7
    194c:	08 95       	ret

0000194e <__gesf2>:
    194e:	8a df       	rcall	.-236    	; 0x1864 <__fp_cmp>
    1950:	08 f4       	brcc	.+2      	; 0x1954 <__gesf2+0x6>
    1952:	8f ef       	ldi	r24, 0xFF	; 255
    1954:	08 95       	ret

00001956 <malloc>:
    1956:	cf 93       	push	r28
    1958:	df 93       	push	r29
    195a:	82 30       	cpi	r24, 0x02	; 2
    195c:	91 05       	cpc	r25, r1
    195e:	10 f4       	brcc	.+4      	; 0x1964 <malloc+0xe>
    1960:	82 e0       	ldi	r24, 0x02	; 2
    1962:	90 e0       	ldi	r25, 0x00	; 0
    1964:	e0 91 29 01 	lds	r30, 0x0129
    1968:	f0 91 2a 01 	lds	r31, 0x012A
    196c:	20 e0       	ldi	r18, 0x00	; 0
    196e:	30 e0       	ldi	r19, 0x00	; 0
    1970:	a0 e0       	ldi	r26, 0x00	; 0
    1972:	b0 e0       	ldi	r27, 0x00	; 0
    1974:	30 97       	sbiw	r30, 0x00	; 0
    1976:	39 f1       	breq	.+78     	; 0x19c6 <malloc+0x70>
    1978:	40 81       	ld	r20, Z
    197a:	51 81       	ldd	r21, Z+1	; 0x01
    197c:	48 17       	cp	r20, r24
    197e:	59 07       	cpc	r21, r25
    1980:	b8 f0       	brcs	.+46     	; 0x19b0 <malloc+0x5a>
    1982:	48 17       	cp	r20, r24
    1984:	59 07       	cpc	r21, r25
    1986:	71 f4       	brne	.+28     	; 0x19a4 <malloc+0x4e>
    1988:	82 81       	ldd	r24, Z+2	; 0x02
    198a:	93 81       	ldd	r25, Z+3	; 0x03
    198c:	10 97       	sbiw	r26, 0x00	; 0
    198e:	29 f0       	breq	.+10     	; 0x199a <malloc+0x44>
    1990:	13 96       	adiw	r26, 0x03	; 3
    1992:	9c 93       	st	X, r25
    1994:	8e 93       	st	-X, r24
    1996:	12 97       	sbiw	r26, 0x02	; 2
    1998:	2c c0       	rjmp	.+88     	; 0x19f2 <malloc+0x9c>
    199a:	90 93 2a 01 	sts	0x012A, r25
    199e:	80 93 29 01 	sts	0x0129, r24
    19a2:	27 c0       	rjmp	.+78     	; 0x19f2 <malloc+0x9c>
    19a4:	21 15       	cp	r18, r1
    19a6:	31 05       	cpc	r19, r1
    19a8:	31 f0       	breq	.+12     	; 0x19b6 <malloc+0x60>
    19aa:	42 17       	cp	r20, r18
    19ac:	53 07       	cpc	r21, r19
    19ae:	18 f0       	brcs	.+6      	; 0x19b6 <malloc+0x60>
    19b0:	a9 01       	movw	r20, r18
    19b2:	db 01       	movw	r26, r22
    19b4:	01 c0       	rjmp	.+2      	; 0x19b8 <malloc+0x62>
    19b6:	ef 01       	movw	r28, r30
    19b8:	9a 01       	movw	r18, r20
    19ba:	bd 01       	movw	r22, r26
    19bc:	df 01       	movw	r26, r30
    19be:	02 80       	ldd	r0, Z+2	; 0x02
    19c0:	f3 81       	ldd	r31, Z+3	; 0x03
    19c2:	e0 2d       	mov	r30, r0
    19c4:	d7 cf       	rjmp	.-82     	; 0x1974 <malloc+0x1e>
    19c6:	21 15       	cp	r18, r1
    19c8:	31 05       	cpc	r19, r1
    19ca:	f9 f0       	breq	.+62     	; 0x1a0a <malloc+0xb4>
    19cc:	28 1b       	sub	r18, r24
    19ce:	39 0b       	sbc	r19, r25
    19d0:	24 30       	cpi	r18, 0x04	; 4
    19d2:	31 05       	cpc	r19, r1
    19d4:	80 f4       	brcc	.+32     	; 0x19f6 <malloc+0xa0>
    19d6:	8a 81       	ldd	r24, Y+2	; 0x02
    19d8:	9b 81       	ldd	r25, Y+3	; 0x03
    19da:	61 15       	cp	r22, r1
    19dc:	71 05       	cpc	r23, r1
    19de:	21 f0       	breq	.+8      	; 0x19e8 <malloc+0x92>
    19e0:	fb 01       	movw	r30, r22
    19e2:	93 83       	std	Z+3, r25	; 0x03
    19e4:	82 83       	std	Z+2, r24	; 0x02
    19e6:	04 c0       	rjmp	.+8      	; 0x19f0 <malloc+0x9a>
    19e8:	90 93 2a 01 	sts	0x012A, r25
    19ec:	80 93 29 01 	sts	0x0129, r24
    19f0:	fe 01       	movw	r30, r28
    19f2:	32 96       	adiw	r30, 0x02	; 2
    19f4:	44 c0       	rjmp	.+136    	; 0x1a7e <malloc+0x128>
    19f6:	fe 01       	movw	r30, r28
    19f8:	e2 0f       	add	r30, r18
    19fa:	f3 1f       	adc	r31, r19
    19fc:	81 93       	st	Z+, r24
    19fe:	91 93       	st	Z+, r25
    1a00:	22 50       	subi	r18, 0x02	; 2
    1a02:	31 09       	sbc	r19, r1
    1a04:	39 83       	std	Y+1, r19	; 0x01
    1a06:	28 83       	st	Y, r18
    1a08:	3a c0       	rjmp	.+116    	; 0x1a7e <malloc+0x128>
    1a0a:	20 91 27 01 	lds	r18, 0x0127
    1a0e:	30 91 28 01 	lds	r19, 0x0128
    1a12:	23 2b       	or	r18, r19
    1a14:	41 f4       	brne	.+16     	; 0x1a26 <malloc+0xd0>
    1a16:	20 91 62 00 	lds	r18, 0x0062
    1a1a:	30 91 63 00 	lds	r19, 0x0063
    1a1e:	30 93 28 01 	sts	0x0128, r19
    1a22:	20 93 27 01 	sts	0x0127, r18
    1a26:	20 91 60 00 	lds	r18, 0x0060
    1a2a:	30 91 61 00 	lds	r19, 0x0061
    1a2e:	21 15       	cp	r18, r1
    1a30:	31 05       	cpc	r19, r1
    1a32:	41 f4       	brne	.+16     	; 0x1a44 <malloc+0xee>
    1a34:	2d b7       	in	r18, 0x3d	; 61
    1a36:	3e b7       	in	r19, 0x3e	; 62
    1a38:	40 91 64 00 	lds	r20, 0x0064
    1a3c:	50 91 65 00 	lds	r21, 0x0065
    1a40:	24 1b       	sub	r18, r20
    1a42:	35 0b       	sbc	r19, r21
    1a44:	e0 91 27 01 	lds	r30, 0x0127
    1a48:	f0 91 28 01 	lds	r31, 0x0128
    1a4c:	e2 17       	cp	r30, r18
    1a4e:	f3 07       	cpc	r31, r19
    1a50:	a0 f4       	brcc	.+40     	; 0x1a7a <malloc+0x124>
    1a52:	2e 1b       	sub	r18, r30
    1a54:	3f 0b       	sbc	r19, r31
    1a56:	28 17       	cp	r18, r24
    1a58:	39 07       	cpc	r19, r25
    1a5a:	78 f0       	brcs	.+30     	; 0x1a7a <malloc+0x124>
    1a5c:	ac 01       	movw	r20, r24
    1a5e:	4e 5f       	subi	r20, 0xFE	; 254
    1a60:	5f 4f       	sbci	r21, 0xFF	; 255
    1a62:	24 17       	cp	r18, r20
    1a64:	35 07       	cpc	r19, r21
    1a66:	48 f0       	brcs	.+18     	; 0x1a7a <malloc+0x124>
    1a68:	4e 0f       	add	r20, r30
    1a6a:	5f 1f       	adc	r21, r31
    1a6c:	50 93 28 01 	sts	0x0128, r21
    1a70:	40 93 27 01 	sts	0x0127, r20
    1a74:	81 93       	st	Z+, r24
    1a76:	91 93       	st	Z+, r25
    1a78:	02 c0       	rjmp	.+4      	; 0x1a7e <malloc+0x128>
    1a7a:	e0 e0       	ldi	r30, 0x00	; 0
    1a7c:	f0 e0       	ldi	r31, 0x00	; 0
    1a7e:	cf 01       	movw	r24, r30
    1a80:	df 91       	pop	r29
    1a82:	cf 91       	pop	r28
    1a84:	08 95       	ret

00001a86 <free>:
    1a86:	cf 93       	push	r28
    1a88:	df 93       	push	r29
    1a8a:	00 97       	sbiw	r24, 0x00	; 0
    1a8c:	09 f4       	brne	.+2      	; 0x1a90 <free+0xa>
    1a8e:	87 c0       	rjmp	.+270    	; 0x1b9e <free+0x118>
    1a90:	fc 01       	movw	r30, r24
    1a92:	32 97       	sbiw	r30, 0x02	; 2
    1a94:	13 82       	std	Z+3, r1	; 0x03
    1a96:	12 82       	std	Z+2, r1	; 0x02
    1a98:	c0 91 29 01 	lds	r28, 0x0129
    1a9c:	d0 91 2a 01 	lds	r29, 0x012A
    1aa0:	20 97       	sbiw	r28, 0x00	; 0
    1aa2:	81 f4       	brne	.+32     	; 0x1ac4 <free+0x3e>
    1aa4:	20 81       	ld	r18, Z
    1aa6:	31 81       	ldd	r19, Z+1	; 0x01
    1aa8:	28 0f       	add	r18, r24
    1aaa:	39 1f       	adc	r19, r25
    1aac:	80 91 27 01 	lds	r24, 0x0127
    1ab0:	90 91 28 01 	lds	r25, 0x0128
    1ab4:	82 17       	cp	r24, r18
    1ab6:	93 07       	cpc	r25, r19
    1ab8:	79 f5       	brne	.+94     	; 0x1b18 <free+0x92>
    1aba:	f0 93 28 01 	sts	0x0128, r31
    1abe:	e0 93 27 01 	sts	0x0127, r30
    1ac2:	6d c0       	rjmp	.+218    	; 0x1b9e <free+0x118>
    1ac4:	de 01       	movw	r26, r28
    1ac6:	20 e0       	ldi	r18, 0x00	; 0
    1ac8:	30 e0       	ldi	r19, 0x00	; 0
    1aca:	ae 17       	cp	r26, r30
    1acc:	bf 07       	cpc	r27, r31
    1ace:	50 f4       	brcc	.+20     	; 0x1ae4 <free+0x5e>
    1ad0:	12 96       	adiw	r26, 0x02	; 2
    1ad2:	4d 91       	ld	r20, X+
    1ad4:	5c 91       	ld	r21, X
    1ad6:	13 97       	sbiw	r26, 0x03	; 3
    1ad8:	9d 01       	movw	r18, r26
    1ada:	41 15       	cp	r20, r1
    1adc:	51 05       	cpc	r21, r1
    1ade:	09 f1       	breq	.+66     	; 0x1b22 <free+0x9c>
    1ae0:	da 01       	movw	r26, r20
    1ae2:	f3 cf       	rjmp	.-26     	; 0x1aca <free+0x44>
    1ae4:	b3 83       	std	Z+3, r27	; 0x03
    1ae6:	a2 83       	std	Z+2, r26	; 0x02
    1ae8:	40 81       	ld	r20, Z
    1aea:	51 81       	ldd	r21, Z+1	; 0x01
    1aec:	84 0f       	add	r24, r20
    1aee:	95 1f       	adc	r25, r21
    1af0:	8a 17       	cp	r24, r26
    1af2:	9b 07       	cpc	r25, r27
    1af4:	71 f4       	brne	.+28     	; 0x1b12 <free+0x8c>
    1af6:	8d 91       	ld	r24, X+
    1af8:	9c 91       	ld	r25, X
    1afa:	11 97       	sbiw	r26, 0x01	; 1
    1afc:	84 0f       	add	r24, r20
    1afe:	95 1f       	adc	r25, r21
    1b00:	02 96       	adiw	r24, 0x02	; 2
    1b02:	91 83       	std	Z+1, r25	; 0x01
    1b04:	80 83       	st	Z, r24
    1b06:	12 96       	adiw	r26, 0x02	; 2
    1b08:	8d 91       	ld	r24, X+
    1b0a:	9c 91       	ld	r25, X
    1b0c:	13 97       	sbiw	r26, 0x03	; 3
    1b0e:	93 83       	std	Z+3, r25	; 0x03
    1b10:	82 83       	std	Z+2, r24	; 0x02
    1b12:	21 15       	cp	r18, r1
    1b14:	31 05       	cpc	r19, r1
    1b16:	29 f4       	brne	.+10     	; 0x1b22 <free+0x9c>
    1b18:	f0 93 2a 01 	sts	0x012A, r31
    1b1c:	e0 93 29 01 	sts	0x0129, r30
    1b20:	3e c0       	rjmp	.+124    	; 0x1b9e <free+0x118>
    1b22:	d9 01       	movw	r26, r18
    1b24:	13 96       	adiw	r26, 0x03	; 3
    1b26:	fc 93       	st	X, r31
    1b28:	ee 93       	st	-X, r30
    1b2a:	12 97       	sbiw	r26, 0x02	; 2
    1b2c:	4d 91       	ld	r20, X+
    1b2e:	5d 91       	ld	r21, X+
    1b30:	a4 0f       	add	r26, r20
    1b32:	b5 1f       	adc	r27, r21
    1b34:	ea 17       	cp	r30, r26
    1b36:	fb 07       	cpc	r31, r27
    1b38:	79 f4       	brne	.+30     	; 0x1b58 <free+0xd2>
    1b3a:	80 81       	ld	r24, Z
    1b3c:	91 81       	ldd	r25, Z+1	; 0x01
    1b3e:	84 0f       	add	r24, r20
    1b40:	95 1f       	adc	r25, r21
    1b42:	02 96       	adiw	r24, 0x02	; 2
    1b44:	d9 01       	movw	r26, r18
    1b46:	11 96       	adiw	r26, 0x01	; 1
    1b48:	9c 93       	st	X, r25
    1b4a:	8e 93       	st	-X, r24
    1b4c:	82 81       	ldd	r24, Z+2	; 0x02
    1b4e:	93 81       	ldd	r25, Z+3	; 0x03
    1b50:	13 96       	adiw	r26, 0x03	; 3
    1b52:	9c 93       	st	X, r25
    1b54:	8e 93       	st	-X, r24
    1b56:	12 97       	sbiw	r26, 0x02	; 2
    1b58:	e0 e0       	ldi	r30, 0x00	; 0
    1b5a:	f0 e0       	ldi	r31, 0x00	; 0
    1b5c:	8a 81       	ldd	r24, Y+2	; 0x02
    1b5e:	9b 81       	ldd	r25, Y+3	; 0x03
    1b60:	00 97       	sbiw	r24, 0x00	; 0
    1b62:	19 f0       	breq	.+6      	; 0x1b6a <free+0xe4>
    1b64:	fe 01       	movw	r30, r28
    1b66:	ec 01       	movw	r28, r24
    1b68:	f9 cf       	rjmp	.-14     	; 0x1b5c <free+0xd6>
    1b6a:	ce 01       	movw	r24, r28
    1b6c:	02 96       	adiw	r24, 0x02	; 2
    1b6e:	28 81       	ld	r18, Y
    1b70:	39 81       	ldd	r19, Y+1	; 0x01
    1b72:	82 0f       	add	r24, r18
    1b74:	93 1f       	adc	r25, r19
    1b76:	20 91 27 01 	lds	r18, 0x0127
    1b7a:	30 91 28 01 	lds	r19, 0x0128
    1b7e:	28 17       	cp	r18, r24
    1b80:	39 07       	cpc	r19, r25
    1b82:	69 f4       	brne	.+26     	; 0x1b9e <free+0x118>
    1b84:	30 97       	sbiw	r30, 0x00	; 0
    1b86:	29 f4       	brne	.+10     	; 0x1b92 <free+0x10c>
    1b88:	10 92 2a 01 	sts	0x012A, r1
    1b8c:	10 92 29 01 	sts	0x0129, r1
    1b90:	02 c0       	rjmp	.+4      	; 0x1b96 <free+0x110>
    1b92:	13 82       	std	Z+3, r1	; 0x03
    1b94:	12 82       	std	Z+2, r1	; 0x02
    1b96:	d0 93 28 01 	sts	0x0128, r29
    1b9a:	c0 93 27 01 	sts	0x0127, r28
    1b9e:	df 91       	pop	r29
    1ba0:	cf 91       	pop	r28
    1ba2:	08 95       	ret

00001ba4 <itoa>:
    1ba4:	45 32       	cpi	r20, 0x25	; 37
    1ba6:	51 05       	cpc	r21, r1
    1ba8:	20 f4       	brcc	.+8      	; 0x1bb2 <itoa+0xe>
    1baa:	42 30       	cpi	r20, 0x02	; 2
    1bac:	10 f0       	brcs	.+4      	; 0x1bb2 <itoa+0xe>
    1bae:	0c 94 dd 0d 	jmp	0x1bba	; 0x1bba <__itoa_ncheck>
    1bb2:	fb 01       	movw	r30, r22
    1bb4:	10 82       	st	Z, r1
    1bb6:	cb 01       	movw	r24, r22
    1bb8:	08 95       	ret

00001bba <__itoa_ncheck>:
    1bba:	bb 27       	eor	r27, r27
    1bbc:	4a 30       	cpi	r20, 0x0A	; 10
    1bbe:	31 f4       	brne	.+12     	; 0x1bcc <__itoa_ncheck+0x12>
    1bc0:	99 23       	and	r25, r25
    1bc2:	22 f4       	brpl	.+8      	; 0x1bcc <__itoa_ncheck+0x12>
    1bc4:	bd e2       	ldi	r27, 0x2D	; 45
    1bc6:	90 95       	com	r25
    1bc8:	81 95       	neg	r24
    1bca:	9f 4f       	sbci	r25, 0xFF	; 255
    1bcc:	0c 94 e9 0d 	jmp	0x1bd2	; 0x1bd2 <__utoa_common>

00001bd0 <__utoa_ncheck>:
    1bd0:	bb 27       	eor	r27, r27

00001bd2 <__utoa_common>:
    1bd2:	fb 01       	movw	r30, r22
    1bd4:	55 27       	eor	r21, r21
    1bd6:	aa 27       	eor	r26, r26
    1bd8:	88 0f       	add	r24, r24
    1bda:	99 1f       	adc	r25, r25
    1bdc:	aa 1f       	adc	r26, r26
    1bde:	a4 17       	cp	r26, r20
    1be0:	10 f0       	brcs	.+4      	; 0x1be6 <__utoa_common+0x14>
    1be2:	a4 1b       	sub	r26, r20
    1be4:	83 95       	inc	r24
    1be6:	50 51       	subi	r21, 0x10	; 16
    1be8:	b9 f7       	brne	.-18     	; 0x1bd8 <__utoa_common+0x6>
    1bea:	a0 5d       	subi	r26, 0xD0	; 208
    1bec:	aa 33       	cpi	r26, 0x3A	; 58
    1bee:	08 f0       	brcs	.+2      	; 0x1bf2 <__utoa_common+0x20>
    1bf0:	a9 5d       	subi	r26, 0xD9	; 217
    1bf2:	a1 93       	st	Z+, r26
    1bf4:	00 97       	sbiw	r24, 0x00	; 0
    1bf6:	79 f7       	brne	.-34     	; 0x1bd6 <__utoa_common+0x4>
    1bf8:	b1 11       	cpse	r27, r1
    1bfa:	b1 93       	st	Z+, r27
    1bfc:	11 92       	st	Z+, r1
    1bfe:	cb 01       	movw	r24, r22
    1c00:	0c 94 1f 0e 	jmp	0x1c3e	; 0x1c3e <strrev>

00001c04 <__eerd_block_m32>:
    1c04:	dc 01       	movw	r26, r24
    1c06:	cb 01       	movw	r24, r22

00001c08 <__eerd_blraw_m32>:
    1c08:	fc 01       	movw	r30, r24
    1c0a:	e1 99       	sbic	0x1c, 1	; 28
    1c0c:	fe cf       	rjmp	.-4      	; 0x1c0a <__eerd_blraw_m32+0x2>
    1c0e:	06 c0       	rjmp	.+12     	; 0x1c1c <__eerd_blraw_m32+0x14>
    1c10:	ff bb       	out	0x1f, r31	; 31
    1c12:	ee bb       	out	0x1e, r30	; 30
    1c14:	e0 9a       	sbi	0x1c, 0	; 28
    1c16:	31 96       	adiw	r30, 0x01	; 1
    1c18:	0d b2       	in	r0, 0x1d	; 29
    1c1a:	0d 92       	st	X+, r0
    1c1c:	41 50       	subi	r20, 0x01	; 1
    1c1e:	50 40       	sbci	r21, 0x00	; 0
    1c20:	b8 f7       	brcc	.-18     	; 0x1c10 <__eerd_blraw_m32+0x8>
    1c22:	08 95       	ret

00001c24 <__eewr_byte_m32>:
    1c24:	26 2f       	mov	r18, r22

00001c26 <__eewr_r18_m32>:
    1c26:	e1 99       	sbic	0x1c, 1	; 28
    1c28:	fe cf       	rjmp	.-4      	; 0x1c26 <__eewr_r18_m32>
    1c2a:	9f bb       	out	0x1f, r25	; 31
    1c2c:	8e bb       	out	0x1e, r24	; 30
    1c2e:	2d bb       	out	0x1d, r18	; 29
    1c30:	0f b6       	in	r0, 0x3f	; 63
    1c32:	f8 94       	cli
    1c34:	e2 9a       	sbi	0x1c, 2	; 28
    1c36:	e1 9a       	sbi	0x1c, 1	; 28
    1c38:	0f be       	out	0x3f, r0	; 63
    1c3a:	01 96       	adiw	r24, 0x01	; 1
    1c3c:	08 95       	ret

00001c3e <strrev>:
    1c3e:	dc 01       	movw	r26, r24
    1c40:	fc 01       	movw	r30, r24
    1c42:	67 2f       	mov	r22, r23
    1c44:	71 91       	ld	r23, Z+
    1c46:	77 23       	and	r23, r23
    1c48:	e1 f7       	brne	.-8      	; 0x1c42 <strrev+0x4>
    1c4a:	32 97       	sbiw	r30, 0x02	; 2
    1c4c:	04 c0       	rjmp	.+8      	; 0x1c56 <strrev+0x18>
    1c4e:	7c 91       	ld	r23, X
    1c50:	6d 93       	st	X+, r22
    1c52:	70 83       	st	Z, r23
    1c54:	62 91       	ld	r22, -Z
    1c56:	ae 17       	cp	r26, r30
    1c58:	bf 07       	cpc	r27, r31
    1c5a:	c8 f3       	brcs	.-14     	; 0x1c4e <strrev+0x10>
    1c5c:	08 95       	ret

00001c5e <_exit>:
    1c5e:	f8 94       	cli

00001c60 <__stop_program>:
    1c60:	ff cf       	rjmp	.-2      	; 0x1c60 <__stop_program>

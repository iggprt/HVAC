
HVAC_2.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001226  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000012  00800060  00001226  000012ba  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000007b  00800072  00800072  000012cc  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000012cc  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 000002d8  00000000  00000000  000012fc  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00002e88  00000000  00000000  000015d4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000c88  00000000  00000000  0000445c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00001205  00000000  00000000  000050e4  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000007cc  00000000  00000000  000062ec  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000ec9  00000000  00000000  00006ab8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00002545  00000000  00000000  00007981  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000002b0  00000000  00000000  00009ec6  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
#include "z_events.h"
char state;

void set_event()
{
	 events++;
       0:	0c 94 4a 00 	jmp	0x94	; 0x94 <__ctors_end>
       4:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
       8:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
       c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      10:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      14:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      18:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      1c:	0c 94 95 07 	jmp	0xf2a	; 0xf2a <__vector_7>
      20:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      24:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      28:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      2c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      30:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      34:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      38:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      3c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      40:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      44:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      48:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      4c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      50:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>

00000054 <__trampolines_end>:
      54:	00 13       	cpse	r16, r16
      56:	1a 04       	cpc	r1, r10
      58:	0b 19       	sub	r16, r11
      5a:	00 00       	nop
      5c:	00 06       	cpc	r0, r16
      5e:	14 1f       	adc	r17, r20
      60:	05 0c       	add	r0, r5
      62:	00 00       	nop
      64:	00 13       	cpse	r16, r16
      66:	1e 04       	cpc	r1, r14
      68:	0f 19       	sub	r16, r15
      6a:	00 00       	nop
      6c:	00 06       	cpc	r0, r16
      6e:	14 1f       	adc	r17, r20
      70:	05 0c       	add	r0, r5
      72:	00 00       	nop
      74:	08 15       	cp	r16, r8
      76:	02 00       	.word	0x0002	; ????
      78:	08 15       	cp	r16, r8
      7a:	02 00       	.word	0x0002	; ????
      7c:	04 0a       	sbc	r0, r20
      7e:	11 00       	.word	0x0011	; ????
      80:	04 0a       	sbc	r0, r20
      82:	11 00       	.word	0x0011	; ????
      84:	02 15       	cp	r16, r2
      86:	08 00       	.word	0x0008	; ????
      88:	02 15       	cp	r16, r2
      8a:	08 00       	.word	0x0008	; ????
      8c:	11 0a       	sbc	r1, r17
      8e:	04 00       	.word	0x0004	; ????
      90:	11 0a       	sbc	r1, r17
      92:	04 00       	.word	0x0004	; ????

00000094 <__ctors_end>:
      94:	11 24       	eor	r1, r1
      96:	1f be       	out	0x3f, r1	; 63
      98:	cf e5       	ldi	r28, 0x5F	; 95
      9a:	d8 e0       	ldi	r29, 0x08	; 8
      9c:	de bf       	out	0x3e, r29	; 62
      9e:	cd bf       	out	0x3d, r28	; 61

000000a0 <__do_copy_data>:
      a0:	10 e0       	ldi	r17, 0x00	; 0
      a2:	a0 e6       	ldi	r26, 0x60	; 96
      a4:	b0 e0       	ldi	r27, 0x00	; 0
      a6:	e6 e2       	ldi	r30, 0x26	; 38
      a8:	f2 e1       	ldi	r31, 0x12	; 18
      aa:	02 c0       	rjmp	.+4      	; 0xb0 <__do_copy_data+0x10>
      ac:	05 90       	lpm	r0, Z+
      ae:	0d 92       	st	X+, r0
      b0:	a2 37       	cpi	r26, 0x72	; 114
      b2:	b1 07       	cpc	r27, r17
      b4:	d9 f7       	brne	.-10     	; 0xac <__do_copy_data+0xc>

000000b6 <__do_clear_bss>:
      b6:	20 e0       	ldi	r18, 0x00	; 0
      b8:	a2 e7       	ldi	r26, 0x72	; 114
      ba:	b0 e0       	ldi	r27, 0x00	; 0
      bc:	01 c0       	rjmp	.+2      	; 0xc0 <.do_clear_bss_start>

000000be <.do_clear_bss_loop>:
      be:	1d 92       	st	X+, r1

000000c0 <.do_clear_bss_start>:
      c0:	ad 3e       	cpi	r26, 0xED	; 237
      c2:	b2 07       	cpc	r27, r18
      c4:	e1 f7       	brne	.-8      	; 0xbe <.do_clear_bss_loop>
      c6:	0e 94 e8 05 	call	0xbd0	; 0xbd0 <main>
      ca:	0c 94 11 09 	jmp	0x1222	; 0x1222 <_exit>

000000ce <__bad_interrupt>:
      ce:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000d2 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
      d2:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
      d4:	03 96       	adiw	r24, 0x03	; 3
      d6:	92 83       	std	Z+2, r25	; 0x02
      d8:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
      da:	2f ef       	ldi	r18, 0xFF	; 255
      dc:	3f ef       	ldi	r19, 0xFF	; 255
      de:	34 83       	std	Z+4, r19	; 0x04
      e0:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
      e2:	96 83       	std	Z+6, r25	; 0x06
      e4:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
      e6:	90 87       	std	Z+8, r25	; 0x08
      e8:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
      ea:	10 82       	st	Z, r1
      ec:	08 95       	ret

000000ee <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
      ee:	fc 01       	movw	r30, r24
      f0:	11 86       	std	Z+9, r1	; 0x09
      f2:	10 86       	std	Z+8, r1	; 0x08
      f4:	08 95       	ret

000000f6 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
      f6:	cf 93       	push	r28
      f8:	df 93       	push	r29
      fa:	9c 01       	movw	r18, r24
      fc:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
      fe:	dc 01       	movw	r26, r24
     100:	11 96       	adiw	r26, 0x01	; 1
     102:	cd 91       	ld	r28, X+
     104:	dc 91       	ld	r29, X
     106:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     108:	d3 83       	std	Z+3, r29	; 0x03
     10a:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     10c:	8c 81       	ldd	r24, Y+4	; 0x04
     10e:	9d 81       	ldd	r25, Y+5	; 0x05
     110:	95 83       	std	Z+5, r25	; 0x05
     112:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     114:	8c 81       	ldd	r24, Y+4	; 0x04
     116:	9d 81       	ldd	r25, Y+5	; 0x05
     118:	dc 01       	movw	r26, r24
     11a:	13 96       	adiw	r26, 0x03	; 3
     11c:	7c 93       	st	X, r23
     11e:	6e 93       	st	-X, r22
     120:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     122:	7d 83       	std	Y+5, r23	; 0x05
     124:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     126:	31 87       	std	Z+9, r19	; 0x09
     128:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     12a:	f9 01       	movw	r30, r18
     12c:	80 81       	ld	r24, Z
     12e:	8f 5f       	subi	r24, 0xFF	; 255
     130:	80 83       	st	Z, r24
}
     132:	df 91       	pop	r29
     134:	cf 91       	pop	r28
     136:	08 95       	ret

00000138 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     138:	cf 93       	push	r28
     13a:	df 93       	push	r29
     13c:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     13e:	48 81       	ld	r20, Y
     140:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     142:	4f 3f       	cpi	r20, 0xFF	; 255
     144:	2f ef       	ldi	r18, 0xFF	; 255
     146:	52 07       	cpc	r21, r18
     148:	21 f4       	brne	.+8      	; 0x152 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     14a:	fc 01       	movw	r30, r24
     14c:	a7 81       	ldd	r26, Z+7	; 0x07
     14e:	b0 85       	ldd	r27, Z+8	; 0x08
     150:	0d c0       	rjmp	.+26     	; 0x16c <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     152:	dc 01       	movw	r26, r24
     154:	13 96       	adiw	r26, 0x03	; 3
     156:	12 96       	adiw	r26, 0x02	; 2
     158:	ed 91       	ld	r30, X+
     15a:	fc 91       	ld	r31, X
     15c:	13 97       	sbiw	r26, 0x03	; 3
     15e:	20 81       	ld	r18, Z
     160:	31 81       	ldd	r19, Z+1	; 0x01
     162:	42 17       	cp	r20, r18
     164:	53 07       	cpc	r21, r19
     166:	10 f0       	brcs	.+4      	; 0x16c <vListInsert+0x34>
     168:	df 01       	movw	r26, r30
     16a:	f5 cf       	rjmp	.-22     	; 0x156 <vListInsert+0x1e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     16c:	12 96       	adiw	r26, 0x02	; 2
     16e:	ed 91       	ld	r30, X+
     170:	fc 91       	ld	r31, X
     172:	13 97       	sbiw	r26, 0x03	; 3
     174:	fb 83       	std	Y+3, r31	; 0x03
     176:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     178:	d5 83       	std	Z+5, r29	; 0x05
     17a:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     17c:	bd 83       	std	Y+5, r27	; 0x05
     17e:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     180:	13 96       	adiw	r26, 0x03	; 3
     182:	dc 93       	st	X, r29
     184:	ce 93       	st	-X, r28
     186:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     188:	99 87       	std	Y+9, r25	; 0x09
     18a:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     18c:	fc 01       	movw	r30, r24
     18e:	20 81       	ld	r18, Z
     190:	2f 5f       	subi	r18, 0xFF	; 255
     192:	20 83       	st	Z, r18
}
     194:	df 91       	pop	r29
     196:	cf 91       	pop	r28
     198:	08 95       	ret

0000019a <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     19a:	cf 93       	push	r28
     19c:	df 93       	push	r29
     19e:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     1a0:	a0 85       	ldd	r26, Z+8	; 0x08
     1a2:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     1a4:	c2 81       	ldd	r28, Z+2	; 0x02
     1a6:	d3 81       	ldd	r29, Z+3	; 0x03
     1a8:	84 81       	ldd	r24, Z+4	; 0x04
     1aa:	95 81       	ldd	r25, Z+5	; 0x05
     1ac:	9d 83       	std	Y+5, r25	; 0x05
     1ae:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     1b0:	c4 81       	ldd	r28, Z+4	; 0x04
     1b2:	d5 81       	ldd	r29, Z+5	; 0x05
     1b4:	82 81       	ldd	r24, Z+2	; 0x02
     1b6:	93 81       	ldd	r25, Z+3	; 0x03
     1b8:	9b 83       	std	Y+3, r25	; 0x03
     1ba:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     1bc:	11 96       	adiw	r26, 0x01	; 1
     1be:	cd 91       	ld	r28, X+
     1c0:	dc 91       	ld	r29, X
     1c2:	12 97       	sbiw	r26, 0x02	; 2
     1c4:	ce 17       	cp	r28, r30
     1c6:	df 07       	cpc	r29, r31
     1c8:	31 f4       	brne	.+12     	; 0x1d6 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     1ca:	8c 81       	ldd	r24, Y+4	; 0x04
     1cc:	9d 81       	ldd	r25, Y+5	; 0x05
     1ce:	12 96       	adiw	r26, 0x02	; 2
     1d0:	9c 93       	st	X, r25
     1d2:	8e 93       	st	-X, r24
     1d4:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     1d6:	11 86       	std	Z+9, r1	; 0x09
     1d8:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     1da:	8c 91       	ld	r24, X
     1dc:	81 50       	subi	r24, 0x01	; 1
     1de:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     1e0:	df 91       	pop	r29
     1e2:	cf 91       	pop	r28
     1e4:	08 95       	ret

000001e6 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     1e6:	e0 91 95 00 	lds	r30, 0x0095
     1ea:	f0 91 96 00 	lds	r31, 0x0096
     1ee:	80 81       	ld	r24, Z
     1f0:	81 11       	cpse	r24, r1
     1f2:	07 c0       	rjmp	.+14     	; 0x202 <prvResetNextTaskUnblockTime+0x1c>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
     1f4:	8f ef       	ldi	r24, 0xFF	; 255
     1f6:	9f ef       	ldi	r25, 0xFF	; 255
     1f8:	90 93 76 00 	sts	0x0076, r25
     1fc:	80 93 75 00 	sts	0x0075, r24
     200:	08 95       	ret
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     202:	e0 91 95 00 	lds	r30, 0x0095
     206:	f0 91 96 00 	lds	r31, 0x0096
     20a:	05 80       	ldd	r0, Z+5	; 0x05
     20c:	f6 81       	ldd	r31, Z+6	; 0x06
     20e:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
     210:	06 80       	ldd	r0, Z+6	; 0x06
     212:	f7 81       	ldd	r31, Z+7	; 0x07
     214:	e0 2d       	mov	r30, r0
     216:	82 81       	ldd	r24, Z+2	; 0x02
     218:	93 81       	ldd	r25, Z+3	; 0x03
     21a:	90 93 76 00 	sts	0x0076, r25
     21e:	80 93 75 00 	sts	0x0075, r24
     222:	08 95       	ret

00000224 <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
     224:	0f 93       	push	r16
     226:	1f 93       	push	r17
     228:	cf 93       	push	r28
     22a:	df 93       	push	r29
     22c:	ec 01       	movw	r28, r24
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
     22e:	00 91 7d 00 	lds	r16, 0x007D
     232:	10 91 7e 00 	lds	r17, 0x007E
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
     236:	80 91 cd 00 	lds	r24, 0x00CD
     23a:	90 91 ce 00 	lds	r25, 0x00CE
     23e:	02 96       	adiw	r24, 0x02	; 2
     240:	0e 94 cd 00 	call	0x19a	; 0x19a <uxListRemove>
	#else /* INCLUDE_vTaskSuspend */
	{
		/* Calculate the time at which the task should be woken if the event
		does not occur.  This may overflow but this doesn't matter, the kernel
		will manage it correctly. */
		xTimeToWake = xConstTickCount + xTicksToWait;
     244:	c0 0f       	add	r28, r16
     246:	d1 1f       	adc	r29, r17

		/* The list item will be inserted in wake time order. */
		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
     248:	e0 91 cd 00 	lds	r30, 0x00CD
     24c:	f0 91 ce 00 	lds	r31, 0x00CE
     250:	d3 83       	std	Z+3, r29	; 0x03
     252:	c2 83       	std	Z+2, r28	; 0x02

		if( xTimeToWake < xConstTickCount )
     254:	c0 17       	cp	r28, r16
     256:	d1 07       	cpc	r29, r17
     258:	68 f4       	brcc	.+26     	; 0x274 <prvAddCurrentTaskToDelayedList+0x50>
		{
			/* Wake time has overflowed.  Place this item in the overflow list. */
			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     25a:	60 91 cd 00 	lds	r22, 0x00CD
     25e:	70 91 ce 00 	lds	r23, 0x00CE
     262:	80 91 93 00 	lds	r24, 0x0093
     266:	90 91 94 00 	lds	r25, 0x0094
     26a:	6e 5f       	subi	r22, 0xFE	; 254
     26c:	7f 4f       	sbci	r23, 0xFF	; 255
     26e:	0e 94 9c 00 	call	0x138	; 0x138 <vListInsert>
     272:	17 c0       	rjmp	.+46     	; 0x2a2 <prvAddCurrentTaskToDelayedList+0x7e>
		}
		else
		{
			/* The wake time has not overflowed, so the current block list is used. */
			vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     274:	60 91 cd 00 	lds	r22, 0x00CD
     278:	70 91 ce 00 	lds	r23, 0x00CE
     27c:	80 91 95 00 	lds	r24, 0x0095
     280:	90 91 96 00 	lds	r25, 0x0096
     284:	6e 5f       	subi	r22, 0xFE	; 254
     286:	7f 4f       	sbci	r23, 0xFF	; 255
     288:	0e 94 9c 00 	call	0x138	; 0x138 <vListInsert>

			/* If the task entering the blocked state was placed at the head of the
			list of blocked tasks then xNextTaskUnblockTime needs to be updated
			too. */
			if( xTimeToWake < xNextTaskUnblockTime )
     28c:	80 91 75 00 	lds	r24, 0x0075
     290:	90 91 76 00 	lds	r25, 0x0076
     294:	c8 17       	cp	r28, r24
     296:	d9 07       	cpc	r29, r25
     298:	20 f4       	brcc	.+8      	; 0x2a2 <prvAddCurrentTaskToDelayedList+0x7e>
			{
				xNextTaskUnblockTime = xTimeToWake;
     29a:	d0 93 76 00 	sts	0x0076, r29
     29e:	c0 93 75 00 	sts	0x0075, r28

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
     2a2:	df 91       	pop	r29
     2a4:	cf 91       	pop	r28
     2a6:	1f 91       	pop	r17
     2a8:	0f 91       	pop	r16
     2aa:	08 95       	ret

000002ac <xTaskCreate>:
							const char * const pcName,
							const uint16_t usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
     2ac:	4f 92       	push	r4
     2ae:	5f 92       	push	r5
     2b0:	6f 92       	push	r6
     2b2:	7f 92       	push	r7
     2b4:	8f 92       	push	r8
     2b6:	9f 92       	push	r9
     2b8:	af 92       	push	r10
     2ba:	bf 92       	push	r11
     2bc:	cf 92       	push	r12
     2be:	df 92       	push	r13
     2c0:	ef 92       	push	r14
     2c2:	ff 92       	push	r15
     2c4:	0f 93       	push	r16
     2c6:	cf 93       	push	r28
     2c8:	df 93       	push	r29
     2ca:	4c 01       	movw	r8, r24
     2cc:	6b 01       	movw	r12, r22
     2ce:	5a 01       	movw	r10, r20
     2d0:	29 01       	movw	r4, r18
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     2d2:	ca 01       	movw	r24, r20
     2d4:	0e 94 21 06 	call	0xc42	; 0xc42 <pvPortMalloc>
     2d8:	3c 01       	movw	r6, r24

			if( pxStack != NULL )
     2da:	00 97       	sbiw	r24, 0x00	; 0
     2dc:	09 f4       	brne	.+2      	; 0x2e0 <xTaskCreate+0x34>
     2de:	db c0       	rjmp	.+438    	; 0x496 <xTaskCreate+0x1ea>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
     2e0:	86 e2       	ldi	r24, 0x26	; 38
     2e2:	90 e0       	ldi	r25, 0x00	; 0
     2e4:	0e 94 21 06 	call	0xc42	; 0xc42 <pvPortMalloc>
     2e8:	ec 01       	movw	r28, r24

				if( pxNewTCB != NULL )
     2ea:	00 97       	sbiw	r24, 0x00	; 0
     2ec:	71 f0       	breq	.+28     	; 0x30a <xTaskCreate+0x5e>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
     2ee:	78 8e       	std	Y+24, r7	; 0x18
     2f0:	6f 8a       	std	Y+23, r6	; 0x17
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
     2f2:	81 e0       	ldi	r24, 0x01	; 1
     2f4:	a8 1a       	sub	r10, r24
     2f6:	b1 08       	sbc	r11, r1
     2f8:	6a 0c       	add	r6, r10
     2fa:	7b 1c       	adc	r7, r11
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
     2fc:	d6 01       	movw	r26, r12
     2fe:	8c 91       	ld	r24, X
     300:	89 8f       	std	Y+25, r24	; 0x19

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
     302:	8c 91       	ld	r24, X
     304:	81 11       	cpse	r24, r1
     306:	05 c0       	rjmp	.+10     	; 0x312 <xTaskCreate+0x66>
     308:	16 c0       	rjmp	.+44     	; 0x336 <xTaskCreate+0x8a>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
     30a:	c3 01       	movw	r24, r6
     30c:	0e 94 30 06 	call	0xc60	; 0xc60 <vPortFree>
     310:	c2 c0       	rjmp	.+388    	; 0x496 <xTaskCreate+0x1ea>
     312:	ae 01       	movw	r20, r28
     314:	46 5e       	subi	r20, 0xE6	; 230
     316:	5f 4f       	sbci	r21, 0xFF	; 255
     318:	f6 01       	movw	r30, r12
     31a:	31 96       	adiw	r30, 0x01	; 1
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
     31c:	21 e0       	ldi	r18, 0x01	; 1
     31e:	cf 01       	movw	r24, r30
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
     320:	31 91       	ld	r19, Z+
     322:	da 01       	movw	r26, r20
     324:	3d 93       	st	X+, r19
     326:	ad 01       	movw	r20, r26

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
     328:	dc 01       	movw	r26, r24
     32a:	8c 91       	ld	r24, X
     32c:	88 23       	and	r24, r24
     32e:	19 f0       	breq	.+6      	; 0x336 <xTaskCreate+0x8a>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
     330:	2f 5f       	subi	r18, 0xFF	; 255
     332:	28 30       	cpi	r18, 0x08	; 8
     334:	a1 f7       	brne	.-24     	; 0x31e <xTaskCreate+0x72>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
     336:	18 a2       	std	Y+32, r1	; 0x20
     338:	04 30       	cpi	r16, 0x04	; 4
     33a:	08 f0       	brcs	.+2      	; 0x33e <xTaskCreate+0x92>
     33c:	03 e0       	ldi	r16, 0x03	; 3
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
     33e:	0e 8b       	std	Y+22, r16	; 0x16
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
     340:	6e 01       	movw	r12, r28
     342:	b2 e0       	ldi	r27, 0x02	; 2
     344:	cb 0e       	add	r12, r27
     346:	d1 1c       	adc	r13, r1
     348:	c6 01       	movw	r24, r12
     34a:	0e 94 77 00 	call	0xee	; 0xee <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
     34e:	ce 01       	movw	r24, r28
     350:	0c 96       	adiw	r24, 0x0c	; 12
     352:	0e 94 77 00 	call	0xee	; 0xee <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
     356:	d9 87       	std	Y+9, r29	; 0x09
     358:	c8 87       	std	Y+8, r28	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     35a:	84 e0       	ldi	r24, 0x04	; 4
     35c:	90 e0       	ldi	r25, 0x00	; 0
     35e:	80 1b       	sub	r24, r16
     360:	91 09       	sbc	r25, r1
     362:	9d 87       	std	Y+13, r25	; 0x0d
     364:	8c 87       	std	Y+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
     366:	db 8b       	std	Y+19, r29	; 0x13
     368:	ca 8b       	std	Y+18, r28	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
     36a:	19 a2       	std	Y+33, r1	; 0x21
     36c:	1a a2       	std	Y+34, r1	; 0x22
     36e:	1b a2       	std	Y+35, r1	; 0x23
     370:	1c a2       	std	Y+36, r1	; 0x24
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
     372:	1d a2       	std	Y+37, r1	; 0x25
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
     374:	a2 01       	movw	r20, r4
     376:	b4 01       	movw	r22, r8
     378:	c3 01       	movw	r24, r6
     37a:	0e 94 3f 06 	call	0xc7e	; 0xc7e <pxPortInitialiseStack>
     37e:	99 83       	std	Y+1, r25	; 0x01
     380:	88 83       	st	Y, r24
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( ( void * ) pxCreatedTask != NULL )
     382:	e1 14       	cp	r14, r1
     384:	f1 04       	cpc	r15, r1
     386:	19 f0       	breq	.+6      	; 0x38e <xTaskCreate+0xe2>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
     388:	f7 01       	movw	r30, r14
     38a:	d1 83       	std	Z+1, r29	; 0x01
     38c:	c0 83       	st	Z, r28

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
     38e:	0f b6       	in	r0, 0x3f	; 63
     390:	f8 94       	cli
     392:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
     394:	80 91 7f 00 	lds	r24, 0x007F
     398:	8f 5f       	subi	r24, 0xFF	; 255
     39a:	80 93 7f 00 	sts	0x007F, r24
		if( pxCurrentTCB == NULL )
     39e:	80 91 cd 00 	lds	r24, 0x00CD
     3a2:	90 91 ce 00 	lds	r25, 0x00CE
     3a6:	89 2b       	or	r24, r25
     3a8:	a9 f5       	brne	.+106    	; 0x414 <xTaskCreate+0x168>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
     3aa:	d0 93 ce 00 	sts	0x00CE, r29
     3ae:	c0 93 cd 00 	sts	0x00CD, r28

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
     3b2:	80 91 7f 00 	lds	r24, 0x007F
     3b6:	81 30       	cpi	r24, 0x01	; 1
     3b8:	e9 f5       	brne	.+122    	; 0x434 <xTaskCreate+0x188>
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
     3ba:	89 ea       	ldi	r24, 0xA9	; 169
     3bc:	90 e0       	ldi	r25, 0x00	; 0
     3be:	0e 94 69 00 	call	0xd2	; 0xd2 <vListInitialise>
     3c2:	82 eb       	ldi	r24, 0xB2	; 178
     3c4:	90 e0       	ldi	r25, 0x00	; 0
     3c6:	0e 94 69 00 	call	0xd2	; 0xd2 <vListInitialise>
     3ca:	8b eb       	ldi	r24, 0xBB	; 187
     3cc:	90 e0       	ldi	r25, 0x00	; 0
     3ce:	0e 94 69 00 	call	0xd2	; 0xd2 <vListInitialise>
     3d2:	84 ec       	ldi	r24, 0xC4	; 196
     3d4:	90 e0       	ldi	r25, 0x00	; 0
     3d6:	0e 94 69 00 	call	0xd2	; 0xd2 <vListInitialise>
	}

	vListInitialise( &xDelayedTaskList1 );
     3da:	80 ea       	ldi	r24, 0xA0	; 160
     3dc:	90 e0       	ldi	r25, 0x00	; 0
     3de:	0e 94 69 00 	call	0xd2	; 0xd2 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
     3e2:	87 e9       	ldi	r24, 0x97	; 151
     3e4:	90 e0       	ldi	r25, 0x00	; 0
     3e6:	0e 94 69 00 	call	0xd2	; 0xd2 <vListInitialise>
	vListInitialise( &xPendingReadyList );
     3ea:	8a e8       	ldi	r24, 0x8A	; 138
     3ec:	90 e0       	ldi	r25, 0x00	; 0
     3ee:	0e 94 69 00 	call	0xd2	; 0xd2 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
     3f2:	81 e8       	ldi	r24, 0x81	; 129
     3f4:	90 e0       	ldi	r25, 0x00	; 0
     3f6:	0e 94 69 00 	call	0xd2	; 0xd2 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
     3fa:	80 ea       	ldi	r24, 0xA0	; 160
     3fc:	90 e0       	ldi	r25, 0x00	; 0
     3fe:	90 93 96 00 	sts	0x0096, r25
     402:	80 93 95 00 	sts	0x0095, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
     406:	87 e9       	ldi	r24, 0x97	; 151
     408:	90 e0       	ldi	r25, 0x00	; 0
     40a:	90 93 94 00 	sts	0x0094, r25
     40e:	80 93 93 00 	sts	0x0093, r24
     412:	10 c0       	rjmp	.+32     	; 0x434 <xTaskCreate+0x188>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
     414:	80 91 7b 00 	lds	r24, 0x007B
     418:	81 11       	cpse	r24, r1
     41a:	0c c0       	rjmp	.+24     	; 0x434 <xTaskCreate+0x188>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
     41c:	e0 91 cd 00 	lds	r30, 0x00CD
     420:	f0 91 ce 00 	lds	r31, 0x00CE
     424:	96 89       	ldd	r25, Z+22	; 0x16
     426:	8e 89       	ldd	r24, Y+22	; 0x16
     428:	89 17       	cp	r24, r25
     42a:	20 f0       	brcs	.+8      	; 0x434 <xTaskCreate+0x188>
				{
					pxCurrentTCB = pxNewTCB;
     42c:	d0 93 ce 00 	sts	0x00CE, r29
     430:	c0 93 cd 00 	sts	0x00CD, r28
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
     434:	80 91 77 00 	lds	r24, 0x0077
     438:	8f 5f       	subi	r24, 0xFF	; 255
     43a:	80 93 77 00 	sts	0x0077, r24
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
     43e:	8e 89       	ldd	r24, Y+22	; 0x16
     440:	90 91 7c 00 	lds	r25, 0x007C
     444:	98 17       	cp	r25, r24
     446:	10 f4       	brcc	.+4      	; 0x44c <xTaskCreate+0x1a0>
     448:	80 93 7c 00 	sts	0x007C, r24
     44c:	90 e0       	ldi	r25, 0x00	; 0
     44e:	9c 01       	movw	r18, r24
     450:	22 0f       	add	r18, r18
     452:	33 1f       	adc	r19, r19
     454:	22 0f       	add	r18, r18
     456:	33 1f       	adc	r19, r19
     458:	22 0f       	add	r18, r18
     45a:	33 1f       	adc	r19, r19
     45c:	82 0f       	add	r24, r18
     45e:	93 1f       	adc	r25, r19
     460:	b6 01       	movw	r22, r12
     462:	87 55       	subi	r24, 0x57	; 87
     464:	9f 4f       	sbci	r25, 0xFF	; 255
     466:	0e 94 7b 00 	call	0xf6	; 0xf6 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
     46a:	0f 90       	pop	r0
     46c:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
     46e:	80 91 7b 00 	lds	r24, 0x007B
     472:	88 23       	and	r24, r24
     474:	61 f0       	breq	.+24     	; 0x48e <xTaskCreate+0x1e2>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
     476:	e0 91 cd 00 	lds	r30, 0x00CD
     47a:	f0 91 ce 00 	lds	r31, 0x00CE
     47e:	96 89       	ldd	r25, Z+22	; 0x16
     480:	8e 89       	ldd	r24, Y+22	; 0x16
     482:	98 17       	cp	r25, r24
     484:	30 f4       	brcc	.+12     	; 0x492 <xTaskCreate+0x1e6>
		{
			taskYIELD_IF_USING_PREEMPTION();
     486:	0e 94 e0 06 	call	0xdc0	; 0xdc0 <vPortYield>
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
			prvAddNewTaskToReadyList( pxNewTCB );
			xReturn = pdPASS;
     48a:	81 e0       	ldi	r24, 0x01	; 1
     48c:	05 c0       	rjmp	.+10     	; 0x498 <xTaskCreate+0x1ec>
     48e:	81 e0       	ldi	r24, 0x01	; 1
     490:	03 c0       	rjmp	.+6      	; 0x498 <xTaskCreate+0x1ec>
     492:	81 e0       	ldi	r24, 0x01	; 1
     494:	01 c0       	rjmp	.+2      	; 0x498 <xTaskCreate+0x1ec>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     496:	8f ef       	ldi	r24, 0xFF	; 255
		}

		return xReturn;
	}
     498:	df 91       	pop	r29
     49a:	cf 91       	pop	r28
     49c:	0f 91       	pop	r16
     49e:	ff 90       	pop	r15
     4a0:	ef 90       	pop	r14
     4a2:	df 90       	pop	r13
     4a4:	cf 90       	pop	r12
     4a6:	bf 90       	pop	r11
     4a8:	af 90       	pop	r10
     4aa:	9f 90       	pop	r9
     4ac:	8f 90       	pop	r8
     4ae:	7f 90       	pop	r7
     4b0:	6f 90       	pop	r6
     4b2:	5f 90       	pop	r5
     4b4:	4f 90       	pop	r4
     4b6:	08 95       	ret

000004b8 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
     4b8:	ef 92       	push	r14
     4ba:	ff 92       	push	r15
     4bc:	0f 93       	push	r16
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
     4be:	0f 2e       	mov	r0, r31
     4c0:	f3 e7       	ldi	r31, 0x73	; 115
     4c2:	ef 2e       	mov	r14, r31
     4c4:	f0 e0       	ldi	r31, 0x00	; 0
     4c6:	ff 2e       	mov	r15, r31
     4c8:	f0 2d       	mov	r31, r0
     4ca:	00 e0       	ldi	r16, 0x00	; 0
     4cc:	20 e0       	ldi	r18, 0x00	; 0
     4ce:	30 e0       	ldi	r19, 0x00	; 0
     4d0:	45 e5       	ldi	r20, 0x55	; 85
     4d2:	50 e0       	ldi	r21, 0x00	; 0
     4d4:	66 e6       	ldi	r22, 0x66	; 102
     4d6:	70 e0       	ldi	r23, 0x00	; 0
     4d8:	8d ed       	ldi	r24, 0xDD	; 221
     4da:	93 e0       	ldi	r25, 0x03	; 3
     4dc:	0e 94 56 01 	call	0x2ac	; 0x2ac <xTaskCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
     4e0:	81 30       	cpi	r24, 0x01	; 1
     4e2:	81 f4       	brne	.+32     	; 0x504 <vTaskStartScheduler+0x4c>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
     4e4:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
     4e6:	8f ef       	ldi	r24, 0xFF	; 255
     4e8:	9f ef       	ldi	r25, 0xFF	; 255
     4ea:	90 93 76 00 	sts	0x0076, r25
     4ee:	80 93 75 00 	sts	0x0075, r24
		xSchedulerRunning = pdTRUE;
     4f2:	81 e0       	ldi	r24, 0x01	; 1
     4f4:	80 93 7b 00 	sts	0x007B, r24
		xTickCount = ( TickType_t ) 0U;
     4f8:	10 92 7e 00 	sts	0x007E, r1
     4fc:	10 92 7d 00 	sts	0x007D, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
     500:	0e 94 ab 06 	call	0xd56	; 0xd56 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
     504:	0f 91       	pop	r16
     506:	ff 90       	pop	r15
     508:	ef 90       	pop	r14
     50a:	08 95       	ret

0000050c <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
     50c:	80 91 72 00 	lds	r24, 0x0072
     510:	8f 5f       	subi	r24, 0xFF	; 255
     512:	80 93 72 00 	sts	0x0072, r24
     516:	08 95       	ret

00000518 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
     518:	cf 92       	push	r12
     51a:	df 92       	push	r13
     51c:	ef 92       	push	r14
     51e:	ff 92       	push	r15
     520:	0f 93       	push	r16
     522:	1f 93       	push	r17
     524:	cf 93       	push	r28
     526:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     528:	80 91 72 00 	lds	r24, 0x0072
     52c:	81 11       	cpse	r24, r1
     52e:	98 c0       	rjmp	.+304    	; 0x660 <xTaskIncrementTick+0x148>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + 1;
     530:	e0 90 7d 00 	lds	r14, 0x007D
     534:	f0 90 7e 00 	lds	r15, 0x007E
     538:	8f ef       	ldi	r24, 0xFF	; 255
     53a:	e8 1a       	sub	r14, r24
     53c:	f8 0a       	sbc	r15, r24

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
     53e:	f0 92 7e 00 	sts	0x007E, r15
     542:	e0 92 7d 00 	sts	0x007D, r14

		if( xConstTickCount == ( TickType_t ) 0U )
     546:	e1 14       	cp	r14, r1
     548:	f1 04       	cpc	r15, r1
     54a:	b9 f4       	brne	.+46     	; 0x57a <xTaskIncrementTick+0x62>
		{
			taskSWITCH_DELAYED_LISTS();
     54c:	80 91 95 00 	lds	r24, 0x0095
     550:	90 91 96 00 	lds	r25, 0x0096
     554:	20 91 93 00 	lds	r18, 0x0093
     558:	30 91 94 00 	lds	r19, 0x0094
     55c:	30 93 96 00 	sts	0x0096, r19
     560:	20 93 95 00 	sts	0x0095, r18
     564:	90 93 94 00 	sts	0x0094, r25
     568:	80 93 93 00 	sts	0x0093, r24
     56c:	80 91 78 00 	lds	r24, 0x0078
     570:	8f 5f       	subi	r24, 0xFF	; 255
     572:	80 93 78 00 	sts	0x0078, r24
     576:	0e 94 f3 00 	call	0x1e6	; 0x1e6 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
     57a:	80 91 75 00 	lds	r24, 0x0075
     57e:	90 91 76 00 	lds	r25, 0x0076
     582:	e8 16       	cp	r14, r24
     584:	f9 06       	cpc	r15, r25
     586:	08 f4       	brcc	.+2      	; 0x58a <xTaskIncrementTick+0x72>
     588:	54 c0       	rjmp	.+168    	; 0x632 <xTaskIncrementTick+0x11a>
     58a:	d1 2c       	mov	r13, r1
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
						{
							xSwitchRequired = pdTRUE;
     58c:	cc 24       	eor	r12, r12
     58e:	c3 94       	inc	r12
     590:	01 c0       	rjmp	.+2      	; 0x594 <xTaskIncrementTick+0x7c>
     592:	dc 2c       	mov	r13, r12
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     594:	e0 91 95 00 	lds	r30, 0x0095
     598:	f0 91 96 00 	lds	r31, 0x0096
     59c:	80 81       	ld	r24, Z
     59e:	81 11       	cpse	r24, r1
     5a0:	07 c0       	rjmp	.+14     	; 0x5b0 <xTaskIncrementTick+0x98>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     5a2:	8f ef       	ldi	r24, 0xFF	; 255
     5a4:	9f ef       	ldi	r25, 0xFF	; 255
     5a6:	90 93 76 00 	sts	0x0076, r25
     5aa:	80 93 75 00 	sts	0x0075, r24
					break;
     5ae:	42 c0       	rjmp	.+132    	; 0x634 <xTaskIncrementTick+0x11c>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     5b0:	e0 91 95 00 	lds	r30, 0x0095
     5b4:	f0 91 96 00 	lds	r31, 0x0096
     5b8:	05 80       	ldd	r0, Z+5	; 0x05
     5ba:	f6 81       	ldd	r31, Z+6	; 0x06
     5bc:	e0 2d       	mov	r30, r0
     5be:	c6 81       	ldd	r28, Z+6	; 0x06
     5c0:	d7 81       	ldd	r29, Z+7	; 0x07
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
     5c2:	2a 81       	ldd	r18, Y+2	; 0x02
     5c4:	3b 81       	ldd	r19, Y+3	; 0x03

					if( xConstTickCount < xItemValue )
     5c6:	e2 16       	cp	r14, r18
     5c8:	f3 06       	cpc	r15, r19
     5ca:	28 f4       	brcc	.+10     	; 0x5d6 <xTaskIncrementTick+0xbe>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
     5cc:	30 93 76 00 	sts	0x0076, r19
     5d0:	20 93 75 00 	sts	0x0075, r18
						break;
     5d4:	2f c0       	rjmp	.+94     	; 0x634 <xTaskIncrementTick+0x11c>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     5d6:	8e 01       	movw	r16, r28
     5d8:	0e 5f       	subi	r16, 0xFE	; 254
     5da:	1f 4f       	sbci	r17, 0xFF	; 255
     5dc:	c8 01       	movw	r24, r16
     5de:	0e 94 cd 00 	call	0x19a	; 0x19a <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     5e2:	8c 89       	ldd	r24, Y+20	; 0x14
     5e4:	9d 89       	ldd	r25, Y+21	; 0x15
     5e6:	89 2b       	or	r24, r25
     5e8:	21 f0       	breq	.+8      	; 0x5f2 <xTaskIncrementTick+0xda>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     5ea:	ce 01       	movw	r24, r28
     5ec:	0c 96       	adiw	r24, 0x0c	; 12
     5ee:	0e 94 cd 00 	call	0x19a	; 0x19a <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
     5f2:	2e 89       	ldd	r18, Y+22	; 0x16
     5f4:	80 91 7c 00 	lds	r24, 0x007C
     5f8:	82 17       	cp	r24, r18
     5fa:	10 f4       	brcc	.+4      	; 0x600 <xTaskIncrementTick+0xe8>
     5fc:	20 93 7c 00 	sts	0x007C, r18
     600:	30 e0       	ldi	r19, 0x00	; 0
     602:	c9 01       	movw	r24, r18
     604:	88 0f       	add	r24, r24
     606:	99 1f       	adc	r25, r25
     608:	88 0f       	add	r24, r24
     60a:	99 1f       	adc	r25, r25
     60c:	88 0f       	add	r24, r24
     60e:	99 1f       	adc	r25, r25
     610:	82 0f       	add	r24, r18
     612:	93 1f       	adc	r25, r19
     614:	b8 01       	movw	r22, r16
     616:	87 55       	subi	r24, 0x57	; 87
     618:	9f 4f       	sbci	r25, 0xFF	; 255
     61a:	0e 94 7b 00 	call	0xf6	; 0xf6 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     61e:	e0 91 cd 00 	lds	r30, 0x00CD
     622:	f0 91 ce 00 	lds	r31, 0x00CE
     626:	9e 89       	ldd	r25, Y+22	; 0x16
     628:	86 89       	ldd	r24, Z+22	; 0x16
     62a:	98 17       	cp	r25, r24
     62c:	08 f0       	brcs	.+2      	; 0x630 <xTaskIncrementTick+0x118>
     62e:	b1 cf       	rjmp	.-158    	; 0x592 <xTaskIncrementTick+0x7a>
     630:	b1 cf       	rjmp	.-158    	; 0x594 <xTaskIncrementTick+0x7c>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
     632:	d1 2c       	mov	r13, r1
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
     634:	e0 91 cd 00 	lds	r30, 0x00CD
     638:	f0 91 ce 00 	lds	r31, 0x00CE
     63c:	86 89       	ldd	r24, Z+22	; 0x16
     63e:	90 e0       	ldi	r25, 0x00	; 0
     640:	fc 01       	movw	r30, r24
     642:	ee 0f       	add	r30, r30
     644:	ff 1f       	adc	r31, r31
     646:	ee 0f       	add	r30, r30
     648:	ff 1f       	adc	r31, r31
     64a:	ee 0f       	add	r30, r30
     64c:	ff 1f       	adc	r31, r31
     64e:	8e 0f       	add	r24, r30
     650:	9f 1f       	adc	r25, r31
     652:	fc 01       	movw	r30, r24
     654:	e7 55       	subi	r30, 0x57	; 87
     656:	ff 4f       	sbci	r31, 0xFF	; 255
     658:	80 81       	ld	r24, Z
     65a:	82 30       	cpi	r24, 0x02	; 2
     65c:	40 f4       	brcc	.+16     	; 0x66e <xTaskIncrementTick+0x156>
     65e:	09 c0       	rjmp	.+18     	; 0x672 <xTaskIncrementTick+0x15a>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
     660:	80 91 7a 00 	lds	r24, 0x007A
     664:	8f 5f       	subi	r24, 0xFF	; 255
     666:	80 93 7a 00 	sts	0x007A, r24

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
     66a:	d1 2c       	mov	r13, r1
     66c:	02 c0       	rjmp	.+4      	; 0x672 <xTaskIncrementTick+0x15a>
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
			{
				xSwitchRequired = pdTRUE;
     66e:	dd 24       	eor	r13, r13
     670:	d3 94       	inc	r13
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
     672:	80 91 79 00 	lds	r24, 0x0079
     676:	88 23       	and	r24, r24
     678:	11 f0       	breq	.+4      	; 0x67e <xTaskIncrementTick+0x166>
		{
			xSwitchRequired = pdTRUE;
     67a:	dd 24       	eor	r13, r13
     67c:	d3 94       	inc	r13
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
     67e:	8d 2d       	mov	r24, r13
     680:	df 91       	pop	r29
     682:	cf 91       	pop	r28
     684:	1f 91       	pop	r17
     686:	0f 91       	pop	r16
     688:	ff 90       	pop	r15
     68a:	ef 90       	pop	r14
     68c:	df 90       	pop	r13
     68e:	cf 90       	pop	r12
     690:	08 95       	ret

00000692 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
     692:	df 92       	push	r13
     694:	ef 92       	push	r14
     696:	ff 92       	push	r15
     698:	0f 93       	push	r16
     69a:	1f 93       	push	r17
     69c:	cf 93       	push	r28
     69e:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
     6a0:	0f b6       	in	r0, 0x3f	; 63
     6a2:	f8 94       	cli
     6a4:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
     6a6:	80 91 72 00 	lds	r24, 0x0072
     6aa:	81 50       	subi	r24, 0x01	; 1
     6ac:	80 93 72 00 	sts	0x0072, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     6b0:	80 91 72 00 	lds	r24, 0x0072
     6b4:	81 11       	cpse	r24, r1
     6b6:	5e c0       	rjmp	.+188    	; 0x774 <xTaskResumeAll+0xe2>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
     6b8:	80 91 7f 00 	lds	r24, 0x007F
     6bc:	88 23       	and	r24, r24
     6be:	09 f4       	brne	.+2      	; 0x6c2 <xTaskResumeAll+0x30>
     6c0:	5b c0       	rjmp	.+182    	; 0x778 <xTaskResumeAll+0xe6>
     6c2:	c0 e0       	ldi	r28, 0x00	; 0
     6c4:	d0 e0       	ldi	r29, 0x00	; 0
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     6c6:	0f 2e       	mov	r0, r31
     6c8:	fa e8       	ldi	r31, 0x8A	; 138
     6ca:	ef 2e       	mov	r14, r31
     6cc:	f0 e0       	ldi	r31, 0x00	; 0
     6ce:	ff 2e       	mov	r15, r31
     6d0:	f0 2d       	mov	r31, r0

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
     6d2:	dd 24       	eor	r13, r13
     6d4:	d3 94       	inc	r13
     6d6:	30 c0       	rjmp	.+96     	; 0x738 <xTaskResumeAll+0xa6>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
     6d8:	e0 91 8f 00 	lds	r30, 0x008F
     6dc:	f0 91 90 00 	lds	r31, 0x0090
     6e0:	c6 81       	ldd	r28, Z+6	; 0x06
     6e2:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     6e4:	ce 01       	movw	r24, r28
     6e6:	0c 96       	adiw	r24, 0x0c	; 12
     6e8:	0e 94 cd 00 	call	0x19a	; 0x19a <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     6ec:	8e 01       	movw	r16, r28
     6ee:	0e 5f       	subi	r16, 0xFE	; 254
     6f0:	1f 4f       	sbci	r17, 0xFF	; 255
     6f2:	c8 01       	movw	r24, r16
     6f4:	0e 94 cd 00 	call	0x19a	; 0x19a <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     6f8:	8e 89       	ldd	r24, Y+22	; 0x16
     6fa:	90 91 7c 00 	lds	r25, 0x007C
     6fe:	98 17       	cp	r25, r24
     700:	10 f4       	brcc	.+4      	; 0x706 <xTaskResumeAll+0x74>
     702:	80 93 7c 00 	sts	0x007C, r24
     706:	90 e0       	ldi	r25, 0x00	; 0
     708:	9c 01       	movw	r18, r24
     70a:	22 0f       	add	r18, r18
     70c:	33 1f       	adc	r19, r19
     70e:	22 0f       	add	r18, r18
     710:	33 1f       	adc	r19, r19
     712:	22 0f       	add	r18, r18
     714:	33 1f       	adc	r19, r19
     716:	82 0f       	add	r24, r18
     718:	93 1f       	adc	r25, r19
     71a:	b8 01       	movw	r22, r16
     71c:	87 55       	subi	r24, 0x57	; 87
     71e:	9f 4f       	sbci	r25, 0xFF	; 255
     720:	0e 94 7b 00 	call	0xf6	; 0xf6 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     724:	e0 91 cd 00 	lds	r30, 0x00CD
     728:	f0 91 ce 00 	lds	r31, 0x00CE
     72c:	9e 89       	ldd	r25, Y+22	; 0x16
     72e:	86 89       	ldd	r24, Z+22	; 0x16
     730:	98 17       	cp	r25, r24
     732:	10 f0       	brcs	.+4      	; 0x738 <xTaskResumeAll+0xa6>
					{
						xYieldPending = pdTRUE;
     734:	d0 92 79 00 	sts	0x0079, r13
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     738:	f7 01       	movw	r30, r14
     73a:	80 81       	ld	r24, Z
     73c:	81 11       	cpse	r24, r1
     73e:	cc cf       	rjmp	.-104    	; 0x6d8 <xTaskResumeAll+0x46>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
     740:	cd 2b       	or	r28, r29
     742:	11 f0       	breq	.+4      	; 0x748 <xTaskResumeAll+0xb6>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
     744:	0e 94 f3 00 	call	0x1e6	; 0x1e6 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
     748:	c0 91 7a 00 	lds	r28, 0x007A

					if( uxPendedCounts > ( UBaseType_t ) 0U )
     74c:	cc 23       	and	r28, r28
     74e:	51 f0       	breq	.+20     	; 0x764 <xTaskResumeAll+0xd2>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
							{
								xYieldPending = pdTRUE;
     750:	d1 e0       	ldi	r29, 0x01	; 1

					if( uxPendedCounts > ( UBaseType_t ) 0U )
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
     752:	0e 94 8c 02 	call	0x518	; 0x518 <xTaskIncrementTick>
     756:	81 11       	cpse	r24, r1
							{
								xYieldPending = pdTRUE;
     758:	d0 93 79 00 	sts	0x0079, r29
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
     75c:	c1 50       	subi	r28, 0x01	; 1
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
     75e:	c9 f7       	brne	.-14     	; 0x752 <xTaskResumeAll+0xc0>

						uxPendedTicks = 0;
     760:	10 92 7a 00 	sts	0x007A, r1
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
     764:	80 91 79 00 	lds	r24, 0x0079
     768:	88 23       	and	r24, r24
     76a:	41 f0       	breq	.+16     	; 0x77c <xTaskResumeAll+0xea>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
     76c:	0e 94 e0 06 	call	0xdc0	; 0xdc0 <vPortYield>

				if( xYieldPending != pdFALSE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
     770:	81 e0       	ldi	r24, 0x01	; 1
     772:	05 c0       	rjmp	.+10     	; 0x77e <xTaskResumeAll+0xec>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB = NULL;
BaseType_t xAlreadyYielded = pdFALSE;
     774:	80 e0       	ldi	r24, 0x00	; 0
     776:	03 c0       	rjmp	.+6      	; 0x77e <xTaskResumeAll+0xec>
     778:	80 e0       	ldi	r24, 0x00	; 0
     77a:	01 c0       	rjmp	.+2      	; 0x77e <xTaskResumeAll+0xec>
     77c:	80 e0       	ldi	r24, 0x00	; 0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
     77e:	0f 90       	pop	r0
     780:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
     782:	df 91       	pop	r29
     784:	cf 91       	pop	r28
     786:	1f 91       	pop	r17
     788:	0f 91       	pop	r16
     78a:	ff 90       	pop	r15
     78c:	ef 90       	pop	r14
     78e:	df 90       	pop	r13
     790:	08 95       	ret

00000792 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
     792:	cf 93       	push	r28
     794:	df 93       	push	r29
     796:	ec 01       	movw	r28, r24
	BaseType_t xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
     798:	00 97       	sbiw	r24, 0x00	; 0
     79a:	51 f0       	breq	.+20     	; 0x7b0 <vTaskDelay+0x1e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
     79c:	0e 94 86 02 	call	0x50c	; 0x50c <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
     7a0:	60 e0       	ldi	r22, 0x00	; 0
     7a2:	ce 01       	movw	r24, r28
     7a4:	0e 94 12 01 	call	0x224	; 0x224 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
     7a8:	0e 94 49 03 	call	0x692	; 0x692 <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     7ac:	81 11       	cpse	r24, r1
     7ae:	02 c0       	rjmp	.+4      	; 0x7b4 <vTaskDelay+0x22>
		{
			portYIELD_WITHIN_API();
     7b0:	0e 94 e0 06 	call	0xdc0	; 0xdc0 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     7b4:	df 91       	pop	r29
     7b6:	cf 91       	pop	r28
     7b8:	08 95       	ret

000007ba <prvIdleTask>:

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
     7ba:	0f 2e       	mov	r0, r31
     7bc:	f9 ea       	ldi	r31, 0xA9	; 169
     7be:	ef 2e       	mov	r14, r31
     7c0:	f0 e0       	ldi	r31, 0x00	; 0
     7c2:	ff 2e       	mov	r15, r31
     7c4:	f0 2d       	mov	r31, r0
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
     7c6:	c1 e8       	ldi	r28, 0x81	; 129
     7c8:	d0 e0       	ldi	r29, 0x00	; 0
     7ca:	28 c0       	rjmp	.+80     	; 0x81c <prvIdleTask+0x62>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
     7cc:	0e 94 86 02 	call	0x50c	; 0x50c <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
     7d0:	18 81       	ld	r17, Y
			}
			( void ) xTaskResumeAll();
     7d2:	0e 94 49 03 	call	0x692	; 0x692 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
     7d6:	11 23       	and	r17, r17
     7d8:	09 f1       	breq	.+66     	; 0x81c <prvIdleTask+0x62>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
     7da:	0f b6       	in	r0, 0x3f	; 63
     7dc:	f8 94       	cli
     7de:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
     7e0:	e0 91 86 00 	lds	r30, 0x0086
     7e4:	f0 91 87 00 	lds	r31, 0x0087
     7e8:	06 81       	ldd	r16, Z+6	; 0x06
     7ea:	17 81       	ldd	r17, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     7ec:	c8 01       	movw	r24, r16
     7ee:	02 96       	adiw	r24, 0x02	; 2
     7f0:	0e 94 cd 00 	call	0x19a	; 0x19a <uxListRemove>
					--uxCurrentNumberOfTasks;
     7f4:	80 91 7f 00 	lds	r24, 0x007F
     7f8:	81 50       	subi	r24, 0x01	; 1
     7fa:	80 93 7f 00 	sts	0x007F, r24
					--uxDeletedTasksWaitingCleanUp;
     7fe:	80 91 80 00 	lds	r24, 0x0080
     802:	81 50       	subi	r24, 0x01	; 1
     804:	80 93 80 00 	sts	0x0080, r24
				}
				taskEXIT_CRITICAL();
     808:	0f 90       	pop	r0
     80a:	0f be       	out	0x3f, r0	; 63

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
     80c:	f8 01       	movw	r30, r16
     80e:	87 89       	ldd	r24, Z+23	; 0x17
     810:	90 8d       	ldd	r25, Z+24	; 0x18
     812:	0e 94 30 06 	call	0xc60	; 0xc60 <vPortFree>
			vPortFree( pxTCB );
     816:	c8 01       	movw	r24, r16
     818:	0e 94 30 06 	call	0xc60	; 0xc60 <vPortFree>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
     81c:	80 91 80 00 	lds	r24, 0x0080
     820:	81 11       	cpse	r24, r1
     822:	d4 cf       	rjmp	.-88     	; 0x7cc <prvIdleTask+0x12>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
     824:	f7 01       	movw	r30, r14
     826:	80 81       	ld	r24, Z
     828:	82 30       	cpi	r24, 0x02	; 2
     82a:	10 f0       	brcs	.+4      	; 0x830 <prvIdleTask+0x76>
			{
				taskYIELD();
     82c:	0e 94 e0 06 	call	0xdc0	; 0xdc0 <vPortYield>
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
     830:	0e 94 20 06 	call	0xc40	; 0xc40 <vApplicationIdleHook>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
     834:	f3 cf       	rjmp	.-26     	; 0x81c <prvIdleTask+0x62>

00000836 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
     836:	80 91 72 00 	lds	r24, 0x0072
     83a:	88 23       	and	r24, r24
     83c:	21 f0       	breq	.+8      	; 0x846 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
     83e:	81 e0       	ldi	r24, 0x01	; 1
     840:	80 93 79 00 	sts	0x0079, r24
     844:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
     846:	10 92 79 00 	sts	0x0079, r1
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
     84a:	20 91 7c 00 	lds	r18, 0x007C
     84e:	82 2f       	mov	r24, r18
     850:	90 e0       	ldi	r25, 0x00	; 0
     852:	fc 01       	movw	r30, r24
     854:	ee 0f       	add	r30, r30
     856:	ff 1f       	adc	r31, r31
     858:	ee 0f       	add	r30, r30
     85a:	ff 1f       	adc	r31, r31
     85c:	ee 0f       	add	r30, r30
     85e:	ff 1f       	adc	r31, r31
     860:	e8 0f       	add	r30, r24
     862:	f9 1f       	adc	r31, r25
     864:	e7 55       	subi	r30, 0x57	; 87
     866:	ff 4f       	sbci	r31, 0xFF	; 255
     868:	30 81       	ld	r19, Z
     86a:	31 11       	cpse	r19, r1
     86c:	11 c0       	rjmp	.+34     	; 0x890 <__stack+0x31>
     86e:	21 50       	subi	r18, 0x01	; 1
     870:	82 2f       	mov	r24, r18
     872:	90 e0       	ldi	r25, 0x00	; 0
     874:	fc 01       	movw	r30, r24
     876:	ee 0f       	add	r30, r30
     878:	ff 1f       	adc	r31, r31
     87a:	ee 0f       	add	r30, r30
     87c:	ff 1f       	adc	r31, r31
     87e:	ee 0f       	add	r30, r30
     880:	ff 1f       	adc	r31, r31
     882:	e8 0f       	add	r30, r24
     884:	f9 1f       	adc	r31, r25
     886:	e7 55       	subi	r30, 0x57	; 87
     888:	ff 4f       	sbci	r31, 0xFF	; 255
     88a:	30 81       	ld	r19, Z
     88c:	33 23       	and	r19, r19
     88e:	79 f3       	breq	.-34     	; 0x86e <__stack+0xf>
     890:	fc 01       	movw	r30, r24
     892:	ee 0f       	add	r30, r30
     894:	ff 1f       	adc	r31, r31
     896:	ee 0f       	add	r30, r30
     898:	ff 1f       	adc	r31, r31
     89a:	ee 0f       	add	r30, r30
     89c:	ff 1f       	adc	r31, r31
     89e:	8e 0f       	add	r24, r30
     8a0:	9f 1f       	adc	r25, r31
     8a2:	fc 01       	movw	r30, r24
     8a4:	e7 55       	subi	r30, 0x57	; 87
     8a6:	ff 4f       	sbci	r31, 0xFF	; 255
     8a8:	a1 81       	ldd	r26, Z+1	; 0x01
     8aa:	b2 81       	ldd	r27, Z+2	; 0x02
     8ac:	12 96       	adiw	r26, 0x02	; 2
     8ae:	0d 90       	ld	r0, X+
     8b0:	bc 91       	ld	r27, X
     8b2:	a0 2d       	mov	r26, r0
     8b4:	b2 83       	std	Z+2, r27	; 0x02
     8b6:	a1 83       	std	Z+1, r26	; 0x01
     8b8:	cf 01       	movw	r24, r30
     8ba:	03 96       	adiw	r24, 0x03	; 3
     8bc:	a8 17       	cp	r26, r24
     8be:	b9 07       	cpc	r27, r25
     8c0:	31 f4       	brne	.+12     	; 0x8ce <__stack+0x6f>
     8c2:	12 96       	adiw	r26, 0x02	; 2
     8c4:	8d 91       	ld	r24, X+
     8c6:	9c 91       	ld	r25, X
     8c8:	13 97       	sbiw	r26, 0x03	; 3
     8ca:	92 83       	std	Z+2, r25	; 0x02
     8cc:	81 83       	std	Z+1, r24	; 0x01
     8ce:	01 80       	ldd	r0, Z+1	; 0x01
     8d0:	f2 81       	ldd	r31, Z+2	; 0x02
     8d2:	e0 2d       	mov	r30, r0
     8d4:	86 81       	ldd	r24, Z+6	; 0x06
     8d6:	97 81       	ldd	r25, Z+7	; 0x07
     8d8:	90 93 ce 00 	sts	0x00CE, r25
     8dc:	80 93 cd 00 	sts	0x00CD, r24
     8e0:	20 93 7c 00 	sts	0x007C, r18
     8e4:	08 95       	ret

000008e6 <_LCD_OutNibble>:
// Funkcja wystawiajca pbajt na magistral danych
//
//-------------------------------------------------------------------------------------------------
void _LCD_OutNibble(unsigned char nibbleToWrite)
{
if(nibbleToWrite & 0x01)
     8e6:	80 ff       	sbrs	r24, 0
     8e8:	02 c0       	rjmp	.+4      	; 0x8ee <_LCD_OutNibble+0x8>
	LCD_DB4_PORT |= LCD_DB4;
     8ea:	ac 9a       	sbi	0x15, 4	; 21
     8ec:	01 c0       	rjmp	.+2      	; 0x8f0 <_LCD_OutNibble+0xa>
else
	LCD_DB4_PORT  &= ~LCD_DB4;
     8ee:	ac 98       	cbi	0x15, 4	; 21

if(nibbleToWrite & 0x02)
     8f0:	81 ff       	sbrs	r24, 1
     8f2:	02 c0       	rjmp	.+4      	; 0x8f8 <_LCD_OutNibble+0x12>
	LCD_DB5_PORT |= LCD_DB5;
     8f4:	ad 9a       	sbi	0x15, 5	; 21
     8f6:	01 c0       	rjmp	.+2      	; 0x8fa <_LCD_OutNibble+0x14>
else
	LCD_DB5_PORT  &= ~LCD_DB5;
     8f8:	ad 98       	cbi	0x15, 5	; 21

if(nibbleToWrite & 0x04)
     8fa:	82 ff       	sbrs	r24, 2
     8fc:	02 c0       	rjmp	.+4      	; 0x902 <_LCD_OutNibble+0x1c>
	LCD_DB6_PORT |= LCD_DB6;
     8fe:	ae 9a       	sbi	0x15, 6	; 21
     900:	01 c0       	rjmp	.+2      	; 0x904 <_LCD_OutNibble+0x1e>
else
	LCD_DB6_PORT  &= ~LCD_DB6;
     902:	ae 98       	cbi	0x15, 6	; 21

if(nibbleToWrite & 0x08)
     904:	83 ff       	sbrs	r24, 3
     906:	02 c0       	rjmp	.+4      	; 0x90c <_LCD_OutNibble+0x26>
	LCD_DB7_PORT |= LCD_DB7;
     908:	af 9a       	sbi	0x15, 7	; 21
     90a:	08 95       	ret
else
	LCD_DB7_PORT  &= ~LCD_DB7;
     90c:	af 98       	cbi	0x15, 7	; 21
     90e:	08 95       	ret

00000910 <_LCD_Write>:
//
// Funkcja zapisu bajtu do wywietacza (bez rozrnienia instrukcja/dane).
//
//-------------------------------------------------------------------------------------------------
void _LCD_Write(unsigned char dataToWrite)
{
     910:	cf 93       	push	r28
     912:	c8 2f       	mov	r28, r24
LCD_E_PORT |= LCD_E;
     914:	ab 9a       	sbi	0x15, 3	; 21
_LCD_OutNibble(dataToWrite >> 4);
     916:	82 95       	swap	r24
     918:	8f 70       	andi	r24, 0x0F	; 15
     91a:	0e 94 73 04 	call	0x8e6	; 0x8e6 <_LCD_OutNibble>
LCD_E_PORT &= ~LCD_E;
     91e:	ab 98       	cbi	0x15, 3	; 21
LCD_E_PORT |= LCD_E;
     920:	ab 9a       	sbi	0x15, 3	; 21
_LCD_OutNibble(dataToWrite);
     922:	8c 2f       	mov	r24, r28
     924:	0e 94 73 04 	call	0x8e6	; 0x8e6 <_LCD_OutNibble>
LCD_E_PORT &= ~LCD_E;
     928:	ab 98       	cbi	0x15, 3	; 21
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     92a:	87 ec       	ldi	r24, 0xC7	; 199
     92c:	90 e0       	ldi	r25, 0x00	; 0
     92e:	01 97       	sbiw	r24, 0x01	; 1
     930:	f1 f7       	brne	.-4      	; 0x92e <_LCD_Write+0x1e>
     932:	00 c0       	rjmp	.+0      	; 0x934 <_LCD_Write+0x24>
     934:	00 00       	nop
_delay_us(50);
}
     936:	cf 91       	pop	r28
     938:	08 95       	ret

0000093a <LCD_WriteCommand>:
// Funkcja zapisu rozkazu do wywietlacza
//
//-------------------------------------------------------------------------------------------------
void LCD_WriteCommand(unsigned char commandToWrite)
{
LCD_RS_PORT &= ~LCD_RS;
     93a:	aa 98       	cbi	0x15, 2	; 21
_LCD_Write(commandToWrite);
     93c:	0e 94 88 04 	call	0x910	; 0x910 <_LCD_Write>
     940:	08 95       	ret

00000942 <LCD_WriteData>:
// Funkcja zapisu danych do pamici wywietlacza
//
//-------------------------------------------------------------------------------------------------
void LCD_WriteData(unsigned char dataToWrite)
{
LCD_RS_PORT |= LCD_RS;
     942:	aa 9a       	sbi	0x15, 2	; 21
_LCD_Write(dataToWrite);
     944:	0e 94 88 04 	call	0x910	; 0x910 <_LCD_Write>
     948:	08 95       	ret

0000094a <LCD_WriteText>:
//
// Funkcja wywietlenia napisu na wyswietlaczu.
//
//-------------------------------------------------------------------------------------------------
void LCD_WriteText(char * text)
{
     94a:	cf 93       	push	r28
     94c:	df 93       	push	r29
     94e:	ec 01       	movw	r28, r24
while(*text)
     950:	88 81       	ld	r24, Y
     952:	88 23       	and	r24, r24
     954:	31 f0       	breq	.+12     	; 0x962 <LCD_WriteText+0x18>
     956:	21 96       	adiw	r28, 0x01	; 1
  LCD_WriteData(*text++);
     958:	0e 94 a1 04 	call	0x942	; 0x942 <LCD_WriteData>
// Funkcja wywietlenia napisu na wyswietlaczu.
//
//-------------------------------------------------------------------------------------------------
void LCD_WriteText(char * text)
{
while(*text)
     95c:	89 91       	ld	r24, Y+
     95e:	81 11       	cpse	r24, r1
     960:	fb cf       	rjmp	.-10     	; 0x958 <LCD_WriteText+0xe>
  LCD_WriteData(*text++);
}
     962:	df 91       	pop	r29
     964:	cf 91       	pop	r28
     966:	08 95       	ret

00000968 <LCD_GoTo>:
// Funkcja ustawienia wsprzdnych ekranowych
//
//-------------------------------------------------------------------------------------------------
void LCD_GoTo(unsigned char x, unsigned char y)
{
LCD_WriteCommand(HD44780_DDRAM_SET | (x + (0x40 * y)));
     968:	90 e4       	ldi	r25, 0x40	; 64
     96a:	69 9f       	mul	r22, r25
     96c:	80 0d       	add	r24, r0
     96e:	11 24       	eor	r1, r1
     970:	80 68       	ori	r24, 0x80	; 128
     972:	0e 94 9d 04 	call	0x93a	; 0x93a <LCD_WriteCommand>
     976:	08 95       	ret

00000978 <LCD_Initalize>:
//
// Procedura inicjalizacji kontrolera HD44780.
//
//-------------------------------------------------------------------------------------------------
void LCD_Initalize(void)
{
     978:	cf 93       	push	r28
unsigned char i;
LCD_DB4_DIR |= LCD_DB4; // Konfiguracja kierunku pracy wyprowadze
     97a:	a4 9a       	sbi	0x14, 4	; 20
LCD_DB5_DIR |= LCD_DB5; //
     97c:	a5 9a       	sbi	0x14, 5	; 20
LCD_DB6_DIR |= LCD_DB6; //
     97e:	a6 9a       	sbi	0x14, 6	; 20
LCD_DB7_DIR |= LCD_DB7; //
     980:	a7 9a       	sbi	0x14, 7	; 20
LCD_E_DIR 	|= LCD_E;   //
     982:	a3 9a       	sbi	0x14, 3	; 20
LCD_RS_DIR 	|= LCD_RS;  //
     984:	a2 9a       	sbi	0x14, 2	; 20
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     986:	8f e5       	ldi	r24, 0x5F	; 95
     988:	9a ee       	ldi	r25, 0xEA	; 234
     98a:	01 97       	sbiw	r24, 0x01	; 1
     98c:	f1 f7       	brne	.-4      	; 0x98a <LCD_Initalize+0x12>
     98e:	00 c0       	rjmp	.+0      	; 0x990 <LCD_Initalize+0x18>
     990:	00 00       	nop
_delay_ms(15); // oczekiwanie na ustalibizowanie si napiecia zasilajacego
LCD_RS_PORT &= ~LCD_RS; // wyzerowanie linii RS
     992:	aa 98       	cbi	0x15, 2	; 21
LCD_E_PORT &= ~LCD_E;  // wyzerowanie linii E
     994:	ab 98       	cbi	0x15, 3	; 21
     996:	c3 e0       	ldi	r28, 0x03	; 3

for(i = 0; i < 3; i++) // trzykrotne powtrzenie bloku instrukcji
  {
  LCD_E_PORT |= LCD_E; //  E = 1
     998:	ab 9a       	sbi	0x15, 3	; 21
  _LCD_OutNibble(0x03); // tryb 8-bitowy
     99a:	83 e0       	ldi	r24, 0x03	; 3
     99c:	0e 94 73 04 	call	0x8e6	; 0x8e6 <_LCD_OutNibble>
  LCD_E_PORT &= ~LCD_E; // E = 0
     9a0:	ab 98       	cbi	0x15, 3	; 21
     9a2:	8f e1       	ldi	r24, 0x1F	; 31
     9a4:	9e e4       	ldi	r25, 0x4E	; 78
     9a6:	01 97       	sbiw	r24, 0x01	; 1
     9a8:	f1 f7       	brne	.-4      	; 0x9a6 <LCD_Initalize+0x2e>
     9aa:	00 c0       	rjmp	.+0      	; 0x9ac <LCD_Initalize+0x34>
     9ac:	00 00       	nop
     9ae:	c1 50       	subi	r28, 0x01	; 1
LCD_RS_DIR 	|= LCD_RS;  //
_delay_ms(15); // oczekiwanie na ustalibizowanie si napiecia zasilajacego
LCD_RS_PORT &= ~LCD_RS; // wyzerowanie linii RS
LCD_E_PORT &= ~LCD_E;  // wyzerowanie linii E

for(i = 0; i < 3; i++) // trzykrotne powtrzenie bloku instrukcji
     9b0:	99 f7       	brne	.-26     	; 0x998 <LCD_Initalize+0x20>
  _LCD_OutNibble(0x03); // tryb 8-bitowy
  LCD_E_PORT &= ~LCD_E; // E = 0
  _delay_ms(5); // czekaj 5ms
  }

LCD_E_PORT |= LCD_E; // E = 1
     9b2:	ab 9a       	sbi	0x15, 3	; 21
_LCD_OutNibble(0x02); // tryb 4-bitowy
     9b4:	82 e0       	ldi	r24, 0x02	; 2
     9b6:	0e 94 73 04 	call	0x8e6	; 0x8e6 <_LCD_OutNibble>
LCD_E_PORT &= ~LCD_E; // E = 0
     9ba:	ab 98       	cbi	0x15, 3	; 21
     9bc:	8f e9       	ldi	r24, 0x9F	; 159
     9be:	9f e0       	ldi	r25, 0x0F	; 15
     9c0:	01 97       	sbiw	r24, 0x01	; 1
     9c2:	f1 f7       	brne	.-4      	; 0x9c0 <LCD_Initalize+0x48>
     9c4:	00 c0       	rjmp	.+0      	; 0x9c6 <LCD_Initalize+0x4e>
     9c6:	00 00       	nop

_delay_ms(1); // czekaj 1ms 
LCD_WriteCommand(HD44780_FUNCTION_SET | HD44780_FONT5x7 | HD44780_TWO_LINE | HD44780_4_BIT); // interfejs 4-bity, 2-linie, znak 5x7
     9c8:	88 e2       	ldi	r24, 0x28	; 40
     9ca:	0e 94 9d 04 	call	0x93a	; 0x93a <LCD_WriteCommand>
LCD_WriteCommand(HD44780_DISPLAY_ONOFF | HD44780_DISPLAY_OFF); // wyczenie wyswietlacza
     9ce:	88 e0       	ldi	r24, 0x08	; 8
     9d0:	0e 94 9d 04 	call	0x93a	; 0x93a <LCD_WriteCommand>
LCD_WriteCommand(HD44780_CLEAR); // czyszczenie zawartosi pamieci DDRAM
     9d4:	81 e0       	ldi	r24, 0x01	; 1
     9d6:	0e 94 9d 04 	call	0x93a	; 0x93a <LCD_WriteCommand>
     9da:	8f e3       	ldi	r24, 0x3F	; 63
     9dc:	9f e1       	ldi	r25, 0x1F	; 31
     9de:	01 97       	sbiw	r24, 0x01	; 1
     9e0:	f1 f7       	brne	.-4      	; 0x9de <LCD_Initalize+0x66>
     9e2:	00 c0       	rjmp	.+0      	; 0x9e4 <LCD_Initalize+0x6c>
     9e4:	00 00       	nop
_delay_ms(2);
LCD_WriteCommand(HD44780_ENTRY_MODE | HD44780_EM_SHIFT_CURSOR | HD44780_EM_INCREMENT);// inkrementaja adresu i przesuwanie kursora
     9e6:	86 e0       	ldi	r24, 0x06	; 6
     9e8:	0e 94 9d 04 	call	0x93a	; 0x93a <LCD_WriteCommand>
LCD_WriteCommand(HD44780_DISPLAY_ONOFF | HD44780_DISPLAY_ON | HD44780_CURSOR_OFF | HD44780_CURSOR_NOBLINK); // wcz LCD, bez kursora i mrugania
     9ec:	8c e0       	ldi	r24, 0x0C	; 12
     9ee:	0e 94 9d 04 	call	0x93a	; 0x93a <LCD_WriteCommand>
}
     9f2:	cf 91       	pop	r28
     9f4:	08 95       	ret

000009f6 <LCD_AddCustomSymbol>:
//
//-------------------------------------------------------------------------------------------------


void LCD_AddCustomSymbol(int ram_adr, char *c)
{
     9f6:	0f 93       	push	r16
     9f8:	1f 93       	push	r17
     9fa:	cf 93       	push	r28
     9fc:	df 93       	push	r29
	int i=0;
	for (i=0;i<8;i++)
	{
		LCD_WriteCommand(HD44780_CGRAM_SET|(ram_adr<<3)|i);
     9fe:	88 0f       	add	r24, r24
     a00:	99 1f       	adc	r25, r25
     a02:	88 0f       	add	r24, r24
     a04:	99 1f       	adc	r25, r25
     a06:	88 0f       	add	r24, r24
     a08:	99 1f       	adc	r25, r25
     a0a:	08 2f       	mov	r16, r24
     a0c:	00 64       	ori	r16, 0x40	; 64
     a0e:	c6 2f       	mov	r28, r22
     a10:	d7 2f       	mov	r29, r23
     a12:	10 e0       	ldi	r17, 0x00	; 0
     a14:	81 2f       	mov	r24, r17
     a16:	80 2b       	or	r24, r16
     a18:	0e 94 9d 04 	call	0x93a	; 0x93a <LCD_WriteCommand>
		LCD_WriteData(c[i]);
     a1c:	89 91       	ld	r24, Y+
     a1e:	0e 94 a1 04 	call	0x942	; 0x942 <LCD_WriteData>
     a22:	1f 5f       	subi	r17, 0xFF	; 255


void LCD_AddCustomSymbol(int ram_adr, char *c)
{
	int i=0;
	for (i=0;i<8;i++)
     a24:	18 30       	cpi	r17, 0x08	; 8
     a26:	b1 f7       	brne	.-20     	; 0xa14 <LCD_AddCustomSymbol+0x1e>
	{
		LCD_WriteCommand(HD44780_CGRAM_SET|(ram_adr<<3)|i);
		LCD_WriteData(c[i]);
	}
	LCD_WriteCommand(HD44780_ENTRY_MODE | HD44780_EM_SHIFT_CURSOR | HD44780_EM_INCREMENT);
     a28:	86 e0       	ldi	r24, 0x06	; 6
     a2a:	0e 94 9d 04 	call	0x93a	; 0x93a <LCD_WriteCommand>
}
     a2e:	df 91       	pop	r29
     a30:	cf 91       	pop	r28
     a32:	1f 91       	pop	r17
     a34:	0f 91       	pop	r16
     a36:	08 95       	ret

00000a38 <debounce_D>:

uint16_t buffer[8]={0,0,0,0,0,0,0,0};
sw_state_e enum_state[8]={0,0,0,0,0,0,0,0};

void debounce_D(volatile uint8_t *port_button)
{
     a38:	cf 92       	push	r12
     a3a:	df 92       	push	r13
     a3c:	ff 92       	push	r15
     a3e:	0f 93       	push	r16
     a40:	1f 93       	push	r17
     a42:	cf 93       	push	r28
     a44:	df 93       	push	r29
     a46:	af ec       	ldi	r26, 0xCF	; 207
     a48:	b0 e0       	ldi	r27, 0x00	; 0
     a4a:	e7 ed       	ldi	r30, 0xD7	; 215
     a4c:	f0 e0       	ldi	r31, 0x00	; 0
     a4e:	40 e0       	ldi	r20, 0x00	; 0
     a50:	50 e0       	ldi	r21, 0x00	; 0
			enum_state[port_button_poz]=Bt_pressed;
			//set_event();
		}else
		if((buffer[port_button_poz]&0x00ff)==0 && (buffer[port_button_poz]&0xff00)!=0 && enum_state[port_button_poz]==Bt_pressed)
		{
			enum_state[port_button_poz]=Bt_neg_edge;
     a52:	0f 2e       	mov	r0, r31
     a54:	f3 e0       	ldi	r31, 0x03	; 3
     a56:	ff 2e       	mov	r15, r31
     a58:	f0 2d       	mov	r31, r0
			PORTA=~PORTA;
			//setEvent(port_button_poz);
		}else
		if(buffer[port_button_poz]==0xffff && enum_state[port_button_poz]==Bt_pos_edge)
		{
			enum_state[port_button_poz]=Bt_pressed;
     a5a:	02 e0       	ldi	r16, 0x02	; 2
		{
			buffer[port_button_poz]|=0x01;
		}
		if(buffer[port_button_poz]==0x00ff && enum_state[port_button_poz]==Bt_unpressed)
		{
			enum_state[port_button_poz]=Bt_pos_edge;
     a5c:	11 e0       	ldi	r17, 0x01	; 1
     a5e:	6f 01       	movw	r12, r30
void debounce_D(volatile uint8_t *port_button)
{
	uint8 port_button_poz=0;
	for (port_button_poz=0;port_button_poz<8;port_button_poz++)
	{
		buffer[port_button_poz]<<=1;
     a60:	20 81       	ld	r18, Z
     a62:	31 81       	ldd	r19, Z+1	; 0x01
     a64:	22 0f       	add	r18, r18
     a66:	33 1f       	adc	r19, r19
     a68:	31 83       	std	Z+1, r19	; 0x01
     a6a:	20 83       	st	Z, r18
		if(((*port_button>>port_button_poz)&0x01)==0)
     a6c:	ec 01       	movw	r28, r24
     a6e:	68 81       	ld	r22, Y
     a70:	70 e0       	ldi	r23, 0x00	; 0
     a72:	04 2e       	mov	r0, r20
     a74:	02 c0       	rjmp	.+4      	; 0xa7a <debounce_D+0x42>
     a76:	75 95       	asr	r23
     a78:	67 95       	ror	r22
     a7a:	0a 94       	dec	r0
     a7c:	e2 f7       	brpl	.-8      	; 0xa76 <debounce_D+0x3e>
     a7e:	60 fd       	sbrc	r22, 0
     a80:	03 c0       	rjmp	.+6      	; 0xa88 <debounce_D+0x50>
		{
			buffer[port_button_poz]|=0x01;
     a82:	21 60       	ori	r18, 0x01	; 1
     a84:	31 83       	std	Z+1, r19	; 0x01
     a86:	20 83       	st	Z, r18
		}
		if(buffer[port_button_poz]==0x00ff && enum_state[port_button_poz]==Bt_unpressed)
     a88:	e6 01       	movw	r28, r12
     a8a:	28 81       	ld	r18, Y
     a8c:	39 81       	ldd	r19, Y+1	; 0x01
     a8e:	32 96       	adiw	r30, 0x02	; 2
     a90:	2f 3f       	cpi	r18, 0xFF	; 255
     a92:	31 05       	cpc	r19, r1
     a94:	41 f4       	brne	.+16     	; 0xaa6 <debounce_D+0x6e>
     a96:	6c 91       	ld	r22, X
     a98:	61 11       	cpse	r22, r1
     a9a:	19 c0       	rjmp	.+50     	; 0xace <debounce_D+0x96>
		{
			enum_state[port_button_poz]=Bt_pos_edge;
     a9c:	1c 93       	st	X, r17
			//set_event();
			PORTA=~PORTA;
     a9e:	2b b3       	in	r18, 0x1b	; 27
     aa0:	20 95       	com	r18
     aa2:	2b bb       	out	0x1b, r18	; 27
     aa4:	17 c0       	rjmp	.+46     	; 0xad4 <debounce_D+0x9c>
			//setEvent(port_button_poz);
		}else
		if(buffer[port_button_poz]==0xffff && enum_state[port_button_poz]==Bt_pos_edge)
     aa6:	2f 3f       	cpi	r18, 0xFF	; 255
     aa8:	df ef       	ldi	r29, 0xFF	; 255
     aaa:	3d 07       	cpc	r19, r29
     aac:	29 f4       	brne	.+10     	; 0xab8 <debounce_D+0x80>
     aae:	2c 91       	ld	r18, X
     ab0:	21 30       	cpi	r18, 0x01	; 1
     ab2:	81 f4       	brne	.+32     	; 0xad4 <debounce_D+0x9c>
		{
			enum_state[port_button_poz]=Bt_pressed;
     ab4:	0c 93       	st	X, r16
     ab6:	0e c0       	rjmp	.+28     	; 0xad4 <debounce_D+0x9c>
			//set_event();
		}else
		if((buffer[port_button_poz]&0x00ff)==0 && (buffer[port_button_poz]&0xff00)!=0 && enum_state[port_button_poz]==Bt_pressed)
     ab8:	21 11       	cpse	r18, r1
     aba:	09 c0       	rjmp	.+18     	; 0xace <debounce_D+0x96>
     abc:	b9 01       	movw	r22, r18
     abe:	66 27       	eor	r22, r22
     ac0:	67 2b       	or	r22, r23
     ac2:	29 f0       	breq	.+10     	; 0xace <debounce_D+0x96>
     ac4:	6c 91       	ld	r22, X
     ac6:	62 30       	cpi	r22, 0x02	; 2
     ac8:	11 f4       	brne	.+4      	; 0xace <debounce_D+0x96>
		{
			enum_state[port_button_poz]=Bt_neg_edge;
     aca:	fc 92       	st	X, r15
     acc:	03 c0       	rjmp	.+6      	; 0xad4 <debounce_D+0x9c>
// 			if (port_button_poz==4)
// 			{
// 				setEvent(ev9_B_falling);
// 			}
		}else
		if(buffer[port_button_poz]==0x0000)
     ace:	23 2b       	or	r18, r19
     ad0:	09 f4       	brne	.+2      	; 0xad4 <debounce_D+0x9c>
		{
			enum_state[port_button_poz]=Bt_unpressed;
     ad2:	1c 92       	st	X, r1
     ad4:	4f 5f       	subi	r20, 0xFF	; 255
     ad6:	5f 4f       	sbci	r21, 0xFF	; 255
     ad8:	11 96       	adiw	r26, 0x01	; 1
sw_state_e enum_state[8]={0,0,0,0,0,0,0,0};

void debounce_D(volatile uint8_t *port_button)
{
	uint8 port_button_poz=0;
	for (port_button_poz=0;port_button_poz<8;port_button_poz++)
     ada:	48 30       	cpi	r20, 0x08	; 8
     adc:	51 05       	cpc	r21, r1
     ade:	09 f0       	breq	.+2      	; 0xae2 <debounce_D+0xaa>
     ae0:	be cf       	rjmp	.-132    	; 0xa5e <debounce_D+0x26>
		{
			enum_state[port_button_poz]=Bt_unpressed;
		}
	}
	
}
     ae2:	df 91       	pop	r29
     ae4:	cf 91       	pop	r28
     ae6:	1f 91       	pop	r17
     ae8:	0f 91       	pop	r16
     aea:	ff 90       	pop	r15
     aec:	df 90       	pop	r13
     aee:	cf 90       	pop	r12
     af0:	08 95       	ret

00000af2 <LCD_FillGRAM>:
	}
};


void LCD_FillGRAM(void)
{
     af2:	cf 92       	push	r12
     af4:	df 92       	push	r13
     af6:	ef 92       	push	r14
     af8:	ff 92       	push	r15
     afa:	0f 93       	push	r16
     afc:	1f 93       	push	r17
     afe:	cf 93       	push	r28
     b00:	df 93       	push	r29
     b02:	cd b7       	in	r28, 0x3d	; 61
     b04:	de b7       	in	r29, 0x3e	; 62
     b06:	28 97       	sbiw	r28, 0x08	; 8
     b08:	0f b6       	in	r0, 0x3f	; 63
     b0a:	f8 94       	cli
     b0c:	de bf       	out	0x3e, r29	; 62
     b0e:	0f be       	out	0x3f, r0	; 63
     b10:	cd bf       	out	0x3d, r28	; 61
     b12:	0f 2e       	mov	r0, r31
     b14:	f4 e5       	ldi	r31, 0x54	; 84
     b16:	cf 2e       	mov	r12, r31
     b18:	f0 e0       	ldi	r31, 0x00	; 0
     b1a:	df 2e       	mov	r13, r31
     b1c:	f0 2d       	mov	r31, r0
	char buffer[8];
	int i,j;
	for (i=0;i<8;i++)
     b1e:	e1 2c       	mov	r14, r1
     b20:	f1 2c       	mov	r15, r1
     b22:	8e 01       	movw	r16, r28
     b24:	07 5f       	subi	r16, 0xF7	; 247
     b26:	1f 4f       	sbci	r17, 0xFF	; 255
     b28:	16 c0       	rjmp	.+44     	; 0xb56 <LCD_FillGRAM+0x64>
	{
		for (j=0;j<8;j++)
		{
			#if defined(USE_PROGRAM_MEMORY)
			buffer[j] = pgm_read_byte_near(&(lcd_custom_sym[i][j]));
     b2a:	84 91       	lpm	r24, Z
     b2c:	8d 93       	st	X+, r24
     b2e:	31 96       	adiw	r30, 0x01	; 1
{
	char buffer[8];
	int i,j;
	for (i=0;i<8;i++)
	{
		for (j=0;j<8;j++)
     b30:	a0 17       	cp	r26, r16
     b32:	b1 07       	cpc	r27, r17
     b34:	d1 f7       	brne	.-12     	; 0xb2a <LCD_FillGRAM+0x38>
			buffer[j] = pgm_read_byte_near(&(lcd_custom_sym[i][j]));
			#else
			buffer[j] = lcd_custom_sym[i][j];
			#endif
		}
		LCD_AddCustomSymbol(i,buffer);
     b36:	be 01       	movw	r22, r28
     b38:	6f 5f       	subi	r22, 0xFF	; 255
     b3a:	7f 4f       	sbci	r23, 0xFF	; 255
     b3c:	c7 01       	movw	r24, r14
     b3e:	0e 94 fb 04 	call	0x9f6	; 0x9f6 <LCD_AddCustomSymbol>

void LCD_FillGRAM(void)
{
	char buffer[8];
	int i,j;
	for (i=0;i<8;i++)
     b42:	8f ef       	ldi	r24, 0xFF	; 255
     b44:	e8 1a       	sub	r14, r24
     b46:	f8 0a       	sbc	r15, r24
     b48:	88 e0       	ldi	r24, 0x08	; 8
     b4a:	c8 0e       	add	r12, r24
     b4c:	d1 1c       	adc	r13, r1
     b4e:	88 e0       	ldi	r24, 0x08	; 8
     b50:	e8 16       	cp	r14, r24
     b52:	f1 04       	cpc	r15, r1
     b54:	21 f0       	breq	.+8      	; 0xb5e <LCD_FillGRAM+0x6c>
     b56:	de 01       	movw	r26, r28
     b58:	11 96       	adiw	r26, 0x01	; 1
	}
};


void LCD_FillGRAM(void)
{
     b5a:	f6 01       	movw	r30, r12
     b5c:	e6 cf       	rjmp	.-52     	; 0xb2a <LCD_FillGRAM+0x38>
			#endif
		}
		LCD_AddCustomSymbol(i,buffer);
	}
	
}
     b5e:	28 96       	adiw	r28, 0x08	; 8
     b60:	0f b6       	in	r0, 0x3f	; 63
     b62:	f8 94       	cli
     b64:	de bf       	out	0x3e, r29	; 62
     b66:	0f be       	out	0x3f, r0	; 63
     b68:	cd bf       	out	0x3d, r28	; 61
     b6a:	df 91       	pop	r29
     b6c:	cf 91       	pop	r28
     b6e:	1f 91       	pop	r17
     b70:	0f 91       	pop	r16
     b72:	ff 90       	pop	r15
     b74:	ef 90       	pop	r14
     b76:	df 90       	pop	r13
     b78:	cf 90       	pop	r12
     b7a:	08 95       	ret

00000b7c <debug>:
		vTaskDelay(50*2);
	}
}
//______________________________________________________________________________________
static void debug(void *pvParameters)
{
     b7c:	cf 93       	push	r28
     b7e:	df 93       	push	r29
     b80:	00 d0       	rcall	.+0      	; 0xb82 <debug+0x6>
     b82:	00 d0       	rcall	.+0      	; 0xb84 <debug+0x8>
     b84:	cd b7       	in	r28, 0x3d	; 61
     b86:	de b7       	in	r29, 0x3e	; 62
	(void)pvParameters;
	char buf[4]="0000";
     b88:	80 e3       	ldi	r24, 0x30	; 48
     b8a:	90 e3       	ldi	r25, 0x30	; 48
     b8c:	dc 01       	movw	r26, r24
     b8e:	89 83       	std	Y+1, r24	; 0x01
     b90:	9a 83       	std	Y+2, r25	; 0x02
     b92:	ab 83       	std	Y+3, r26	; 0x03
     b94:	bc 83       	std	Y+4, r27	; 0x04
	for(;;)
	{
		events=9;
     b96:	19 e0       	ldi	r17, 0x09	; 9
     b98:	10 93 e8 00 	sts	0x00E8, r17
		debounce_D(&PIND);
     b9c:	80 e3       	ldi	r24, 0x30	; 48
     b9e:	90 e0       	ldi	r25, 0x00	; 0
     ba0:	0e 94 1c 05 	call	0xa38	; 0xa38 <debounce_D>
		itoa(events,buf,10);
     ba4:	80 91 e8 00 	lds	r24, 0x00E8
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
     ba8:	4a e0       	ldi	r20, 0x0A	; 10
     baa:	be 01       	movw	r22, r28
     bac:	6f 5f       	subi	r22, 0xFF	; 255
     bae:	7f 4f       	sbci	r23, 0xFF	; 255
     bb0:	90 e0       	ldi	r25, 0x00	; 0
     bb2:	0e 94 bf 08 	call	0x117e	; 0x117e <__itoa_ncheck>
		LCD_GoTo(0,1);
     bb6:	61 e0       	ldi	r22, 0x01	; 1
     bb8:	80 e0       	ldi	r24, 0x00	; 0
     bba:	0e 94 b4 04 	call	0x968	; 0x968 <LCD_GoTo>
		LCD_WriteText(buf);
     bbe:	ce 01       	movw	r24, r28
     bc0:	01 96       	adiw	r24, 0x01	; 1
     bc2:	0e 94 a5 04 	call	0x94a	; 0x94a <LCD_WriteText>
// 			
// 		}
		//LCD_GoTo(2,1);
		//LCD_WriteCommand(14);
		//LCD_WriteData(17);
		vTaskDelay(200);
     bc6:	88 ec       	ldi	r24, 0xC8	; 200
     bc8:	90 e0       	ldi	r25, 0x00	; 0
     bca:	0e 94 c9 03 	call	0x792	; 0x792 <vTaskDelay>
     bce:	e4 cf       	rjmp	.-56     	; 0xb98 <debug+0x1c>

00000bd0 <main>:
static void tBlinkLED(void *pvParameters);
static void debug    (void *pvParameters);
/*-----------------------------------------------------------*/

int main( void )
{
     bd0:	ef 92       	push	r14
     bd2:	ff 92       	push	r15
     bd4:	0f 93       	push	r16
     bd6:	cf 93       	push	r28
     bd8:	df 93       	push	r29
     bda:	1f 92       	push	r1
     bdc:	cd b7       	in	r28, 0x3d	; 61
     bde:	de b7       	in	r29, 0x3e	; 62

static void prvIncrementResetCount( void )
{
unsigned char ucCount;

	eeprom_read_block( &ucCount, mainRESET_COUNT_ADDRESS, sizeof( ucCount ) );
     be0:	41 e0       	ldi	r20, 0x01	; 1
     be2:	50 e0       	ldi	r21, 0x00	; 0
     be4:	60 e5       	ldi	r22, 0x50	; 80
     be6:	70 e0       	ldi	r23, 0x00	; 0
     be8:	ce 01       	movw	r24, r28
     bea:	01 96       	adiw	r24, 0x01	; 1
     bec:	0e 94 e4 08 	call	0x11c8	; 0x11c8 <__eerd_block_m32>
	ucCount++;
     bf0:	69 81       	ldd	r22, Y+1	; 0x01
     bf2:	6f 5f       	subi	r22, 0xFF	; 255
     bf4:	69 83       	std	Y+1, r22	; 0x01
	eeprom_write_byte( mainRESET_COUNT_ADDRESS, ucCount );
     bf6:	80 e5       	ldi	r24, 0x50	; 80
     bf8:	90 e0       	ldi	r25, 0x00	; 0
     bfa:	0e 94 f4 08 	call	0x11e8	; 0x11e8 <__eewr_byte_m32>

int main( void )
{
	prvIncrementResetCount();

	LCD_Initalize();
     bfe:	0e 94 bc 04 	call	0x978	; 0x978 <LCD_Initalize>
	LCD_FillGRAM();
     c02:	0e 94 79 05 	call	0xaf2	; 0xaf2 <LCD_FillGRAM>
	
	
	DDRB=0;
     c06:	17 ba       	out	0x17, r1	; 23
	PORTB=0xff;
     c08:	8f ef       	ldi	r24, 0xFF	; 255
     c0a:	88 bb       	out	0x18, r24	; 24
	
	DDRA=0xff;
     c0c:	8a bb       	out	0x1a, r24	; 26
	PORTA=0;
     c0e:	1b ba       	out	0x1b, r1	; 27
	

	/* Create the tasks defined within this file. */
	//xTaskCreate( vLCD_TASK, "LCD", configMINIMAL_STACK_SIZE, NULL, mainCHECK_TASK_PRIORITY, NULL );
	//xTaskCreate( tBlinkLED, "Blink", configMINIMAL_STACK_SIZE, NULL, mainCHECK_TASK_PRIORITY, NULL);
	xTaskCreate( debug, "debug", configMINIMAL_STACK_SIZE, NULL, mainCHECK_TASK_PRIORITY, NULL);
     c10:	e1 2c       	mov	r14, r1
     c12:	f1 2c       	mov	r15, r1
     c14:	03 e0       	ldi	r16, 0x03	; 3
     c16:	20 e0       	ldi	r18, 0x00	; 0
     c18:	30 e0       	ldi	r19, 0x00	; 0
     c1a:	45 e5       	ldi	r20, 0x55	; 85
     c1c:	50 e0       	ldi	r21, 0x00	; 0
     c1e:	6b e6       	ldi	r22, 0x6B	; 107
     c20:	70 e0       	ldi	r23, 0x00	; 0
     c22:	8e eb       	ldi	r24, 0xBE	; 190
     c24:	95 e0       	ldi	r25, 0x05	; 5
     c26:	0e 94 56 01 	call	0x2ac	; 0x2ac <xTaskCreate>
	
	/* In this port, to use preemptive scheduler define configUSE_PREEMPTION
	as 1 in portmacro.h.  To use the cooperative scheduler define
	configUSE_PREEMPTION as 0. */
	vTaskStartScheduler();
     c2a:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <vTaskStartScheduler>

	return 0;
}
     c2e:	80 e0       	ldi	r24, 0x00	; 0
     c30:	90 e0       	ldi	r25, 0x00	; 0
     c32:	0f 90       	pop	r0
     c34:	df 91       	pop	r29
     c36:	cf 91       	pop	r28
     c38:	0f 91       	pop	r16
     c3a:	ff 90       	pop	r15
     c3c:	ef 90       	pop	r14
     c3e:	08 95       	ret

00000c40 <vApplicationIdleHook>:
	eeprom_write_byte( mainRESET_COUNT_ADDRESS, ucCount );
}
/*-----------------------------------------------------------*/

void vApplicationIdleHook( void )
{
     c40:	08 95       	ret

00000c42 <pvPortMalloc>:
#endif

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     c42:	cf 93       	push	r28
     c44:	df 93       	push	r29
     c46:	ec 01       	movw	r28, r24
void *pvReturn;

	vTaskSuspendAll();
     c48:	0e 94 86 02 	call	0x50c	; 0x50c <vTaskSuspendAll>
	{
		pvReturn = malloc( xWantedSize );
     c4c:	ce 01       	movw	r24, r28
     c4e:	0e 94 98 07 	call	0xf30	; 0xf30 <malloc>
     c52:	ec 01       	movw	r28, r24
		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     c54:	0e 94 49 03 	call	0x692	; 0x692 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     c58:	ce 01       	movw	r24, r28
     c5a:	df 91       	pop	r29
     c5c:	cf 91       	pop	r28
     c5e:	08 95       	ret

00000c60 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     c60:	cf 93       	push	r28
     c62:	df 93       	push	r29
     c64:	ec 01       	movw	r28, r24
	if( pv )
     c66:	00 97       	sbiw	r24, 0x00	; 0
     c68:	39 f0       	breq	.+14     	; 0xc78 <vPortFree+0x18>
	{
		vTaskSuspendAll();
     c6a:	0e 94 86 02 	call	0x50c	; 0x50c <vTaskSuspendAll>
		{
			free( pv );
     c6e:	ce 01       	movw	r24, r28
     c70:	0e 94 30 08 	call	0x1060	; 0x1060 <free>
			traceFREE( pv, 0 );
		}
		( void ) xTaskResumeAll();
     c74:	0e 94 49 03 	call	0x692	; 0x692 <xTaskResumeAll>
	}
}
     c78:	df 91       	pop	r29
     c7a:	cf 91       	pop	r28
     c7c:	08 95       	ret

00000c7e <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     c7e:	31 e1       	ldi	r19, 0x11	; 17
     c80:	fc 01       	movw	r30, r24
     c82:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
     c84:	31 97       	sbiw	r30, 0x01	; 1
     c86:	22 e2       	ldi	r18, 0x22	; 34
     c88:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
     c8a:	31 97       	sbiw	r30, 0x01	; 1
     c8c:	a3 e3       	ldi	r26, 0x33	; 51
     c8e:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     c90:	31 97       	sbiw	r30, 0x01	; 1
     c92:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     c94:	31 97       	sbiw	r30, 0x01	; 1
     c96:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
     c98:	31 97       	sbiw	r30, 0x01	; 1
     c9a:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     c9c:	31 97       	sbiw	r30, 0x01	; 1
     c9e:	60 e8       	ldi	r22, 0x80	; 128
     ca0:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
     ca2:	31 97       	sbiw	r30, 0x01	; 1
     ca4:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
     ca6:	31 97       	sbiw	r30, 0x01	; 1
     ca8:	62 e0       	ldi	r22, 0x02	; 2
     caa:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
     cac:	31 97       	sbiw	r30, 0x01	; 1
     cae:	63 e0       	ldi	r22, 0x03	; 3
     cb0:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
     cb2:	31 97       	sbiw	r30, 0x01	; 1
     cb4:	64 e0       	ldi	r22, 0x04	; 4
     cb6:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
     cb8:	31 97       	sbiw	r30, 0x01	; 1
     cba:	65 e0       	ldi	r22, 0x05	; 5
     cbc:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
     cbe:	31 97       	sbiw	r30, 0x01	; 1
     cc0:	66 e0       	ldi	r22, 0x06	; 6
     cc2:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
     cc4:	31 97       	sbiw	r30, 0x01	; 1
     cc6:	67 e0       	ldi	r22, 0x07	; 7
     cc8:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
     cca:	31 97       	sbiw	r30, 0x01	; 1
     ccc:	68 e0       	ldi	r22, 0x08	; 8
     cce:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
     cd0:	31 97       	sbiw	r30, 0x01	; 1
     cd2:	69 e0       	ldi	r22, 0x09	; 9
     cd4:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
     cd6:	31 97       	sbiw	r30, 0x01	; 1
     cd8:	60 e1       	ldi	r22, 0x10	; 16
     cda:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
     cdc:	31 97       	sbiw	r30, 0x01	; 1
     cde:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
     ce0:	31 97       	sbiw	r30, 0x01	; 1
     ce2:	32 e1       	ldi	r19, 0x12	; 18
     ce4:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
     ce6:	31 97       	sbiw	r30, 0x01	; 1
     ce8:	33 e1       	ldi	r19, 0x13	; 19
     cea:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
     cec:	31 97       	sbiw	r30, 0x01	; 1
     cee:	34 e1       	ldi	r19, 0x14	; 20
     cf0:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
     cf2:	31 97       	sbiw	r30, 0x01	; 1
     cf4:	35 e1       	ldi	r19, 0x15	; 21
     cf6:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
     cf8:	31 97       	sbiw	r30, 0x01	; 1
     cfa:	36 e1       	ldi	r19, 0x16	; 22
     cfc:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
     cfe:	31 97       	sbiw	r30, 0x01	; 1
     d00:	37 e1       	ldi	r19, 0x17	; 23
     d02:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
     d04:	31 97       	sbiw	r30, 0x01	; 1
     d06:	38 e1       	ldi	r19, 0x18	; 24
     d08:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
     d0a:	31 97       	sbiw	r30, 0x01	; 1
     d0c:	39 e1       	ldi	r19, 0x19	; 25
     d0e:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
     d10:	31 97       	sbiw	r30, 0x01	; 1
     d12:	30 e2       	ldi	r19, 0x20	; 32
     d14:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
     d16:	31 97       	sbiw	r30, 0x01	; 1
     d18:	31 e2       	ldi	r19, 0x21	; 33
     d1a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
     d1c:	31 97       	sbiw	r30, 0x01	; 1
     d1e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
     d20:	31 97       	sbiw	r30, 0x01	; 1
     d22:	23 e2       	ldi	r18, 0x23	; 35
     d24:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     d26:	31 97       	sbiw	r30, 0x01	; 1
     d28:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     d2a:	31 97       	sbiw	r30, 0x01	; 1
     d2c:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
     d2e:	31 97       	sbiw	r30, 0x01	; 1
     d30:	26 e2       	ldi	r18, 0x26	; 38
     d32:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
     d34:	31 97       	sbiw	r30, 0x01	; 1
     d36:	27 e2       	ldi	r18, 0x27	; 39
     d38:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
     d3a:	31 97       	sbiw	r30, 0x01	; 1
     d3c:	28 e2       	ldi	r18, 0x28	; 40
     d3e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
     d40:	31 97       	sbiw	r30, 0x01	; 1
     d42:	29 e2       	ldi	r18, 0x29	; 41
     d44:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
     d46:	31 97       	sbiw	r30, 0x01	; 1
     d48:	20 e3       	ldi	r18, 0x30	; 48
     d4a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
     d4c:	31 97       	sbiw	r30, 0x01	; 1
     d4e:	21 e3       	ldi	r18, 0x31	; 49
     d50:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
     d52:	86 97       	sbiw	r24, 0x26	; 38
     d54:	08 95       	ret

00000d56 <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	OCR1AH = ucHighByte;
     d56:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = ucLowByte;
     d58:	89 ef       	ldi	r24, 0xF9	; 249
     d5a:	8a bd       	out	0x2a, r24	; 42

	/* Setup clock source and compare match behaviour. */
	/* ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64; */
	ucLowByte = (1<<3)|(1<<1)|(1<<0);
	TCCR1B = ucLowByte;
     d5c:	8b e0       	ldi	r24, 0x0B	; 11
     d5e:	8e bd       	out	0x2e, r24	; 46

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
     d60:	89 b7       	in	r24, 0x39	; 57
	/* ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE; */
	ucLowByte |= (1<<4);
     d62:	80 61       	ori	r24, 0x10	; 16
	TIMSK = ucLowByte;
     d64:	89 bf       	out	0x39, r24	; 57
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     d66:	a0 91 cd 00 	lds	r26, 0x00CD
     d6a:	b0 91 ce 00 	lds	r27, 0x00CE
     d6e:	cd 91       	ld	r28, X+
     d70:	cd bf       	out	0x3d, r28	; 61
     d72:	dd 91       	ld	r29, X+
     d74:	de bf       	out	0x3e, r29	; 62
     d76:	ff 91       	pop	r31
     d78:	ef 91       	pop	r30
     d7a:	df 91       	pop	r29
     d7c:	cf 91       	pop	r28
     d7e:	bf 91       	pop	r27
     d80:	af 91       	pop	r26
     d82:	9f 91       	pop	r25
     d84:	8f 91       	pop	r24
     d86:	7f 91       	pop	r23
     d88:	6f 91       	pop	r22
     d8a:	5f 91       	pop	r21
     d8c:	4f 91       	pop	r20
     d8e:	3f 91       	pop	r19
     d90:	2f 91       	pop	r18
     d92:	1f 91       	pop	r17
     d94:	0f 91       	pop	r16
     d96:	ff 90       	pop	r15
     d98:	ef 90       	pop	r14
     d9a:	df 90       	pop	r13
     d9c:	cf 90       	pop	r12
     d9e:	bf 90       	pop	r11
     da0:	af 90       	pop	r10
     da2:	9f 90       	pop	r9
     da4:	8f 90       	pop	r8
     da6:	7f 90       	pop	r7
     da8:	6f 90       	pop	r6
     daa:	5f 90       	pop	r5
     dac:	4f 90       	pop	r4
     dae:	3f 90       	pop	r3
     db0:	2f 90       	pop	r2
     db2:	1f 90       	pop	r1
     db4:	0f 90       	pop	r0
     db6:	0f be       	out	0x3f, r0	; 63
     db8:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     dba:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
     dbc:	81 e0       	ldi	r24, 0x01	; 1
     dbe:	08 95       	ret

00000dc0 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     dc0:	0f 92       	push	r0
     dc2:	0f b6       	in	r0, 0x3f	; 63
     dc4:	f8 94       	cli
     dc6:	0f 92       	push	r0
     dc8:	1f 92       	push	r1
     dca:	11 24       	eor	r1, r1
     dcc:	2f 92       	push	r2
     dce:	3f 92       	push	r3
     dd0:	4f 92       	push	r4
     dd2:	5f 92       	push	r5
     dd4:	6f 92       	push	r6
     dd6:	7f 92       	push	r7
     dd8:	8f 92       	push	r8
     dda:	9f 92       	push	r9
     ddc:	af 92       	push	r10
     dde:	bf 92       	push	r11
     de0:	cf 92       	push	r12
     de2:	df 92       	push	r13
     de4:	ef 92       	push	r14
     de6:	ff 92       	push	r15
     de8:	0f 93       	push	r16
     dea:	1f 93       	push	r17
     dec:	2f 93       	push	r18
     dee:	3f 93       	push	r19
     df0:	4f 93       	push	r20
     df2:	5f 93       	push	r21
     df4:	6f 93       	push	r22
     df6:	7f 93       	push	r23
     df8:	8f 93       	push	r24
     dfa:	9f 93       	push	r25
     dfc:	af 93       	push	r26
     dfe:	bf 93       	push	r27
     e00:	cf 93       	push	r28
     e02:	df 93       	push	r29
     e04:	ef 93       	push	r30
     e06:	ff 93       	push	r31
     e08:	a0 91 cd 00 	lds	r26, 0x00CD
     e0c:	b0 91 ce 00 	lds	r27, 0x00CE
     e10:	0d b6       	in	r0, 0x3d	; 61
     e12:	0d 92       	st	X+, r0
     e14:	0e b6       	in	r0, 0x3e	; 62
     e16:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     e18:	0e 94 1b 04 	call	0x836	; 0x836 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     e1c:	a0 91 cd 00 	lds	r26, 0x00CD
     e20:	b0 91 ce 00 	lds	r27, 0x00CE
     e24:	cd 91       	ld	r28, X+
     e26:	cd bf       	out	0x3d, r28	; 61
     e28:	dd 91       	ld	r29, X+
     e2a:	de bf       	out	0x3e, r29	; 62
     e2c:	ff 91       	pop	r31
     e2e:	ef 91       	pop	r30
     e30:	df 91       	pop	r29
     e32:	cf 91       	pop	r28
     e34:	bf 91       	pop	r27
     e36:	af 91       	pop	r26
     e38:	9f 91       	pop	r25
     e3a:	8f 91       	pop	r24
     e3c:	7f 91       	pop	r23
     e3e:	6f 91       	pop	r22
     e40:	5f 91       	pop	r21
     e42:	4f 91       	pop	r20
     e44:	3f 91       	pop	r19
     e46:	2f 91       	pop	r18
     e48:	1f 91       	pop	r17
     e4a:	0f 91       	pop	r16
     e4c:	ff 90       	pop	r15
     e4e:	ef 90       	pop	r14
     e50:	df 90       	pop	r13
     e52:	cf 90       	pop	r12
     e54:	bf 90       	pop	r11
     e56:	af 90       	pop	r10
     e58:	9f 90       	pop	r9
     e5a:	8f 90       	pop	r8
     e5c:	7f 90       	pop	r7
     e5e:	6f 90       	pop	r6
     e60:	5f 90       	pop	r5
     e62:	4f 90       	pop	r4
     e64:	3f 90       	pop	r3
     e66:	2f 90       	pop	r2
     e68:	1f 90       	pop	r1
     e6a:	0f 90       	pop	r0
     e6c:	0f be       	out	0x3f, r0	; 63
     e6e:	0f 90       	pop	r0

	asm volatile ( "ret" );
     e70:	08 95       	ret

00000e72 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     e72:	0f 92       	push	r0
     e74:	0f b6       	in	r0, 0x3f	; 63
     e76:	f8 94       	cli
     e78:	0f 92       	push	r0
     e7a:	1f 92       	push	r1
     e7c:	11 24       	eor	r1, r1
     e7e:	2f 92       	push	r2
     e80:	3f 92       	push	r3
     e82:	4f 92       	push	r4
     e84:	5f 92       	push	r5
     e86:	6f 92       	push	r6
     e88:	7f 92       	push	r7
     e8a:	8f 92       	push	r8
     e8c:	9f 92       	push	r9
     e8e:	af 92       	push	r10
     e90:	bf 92       	push	r11
     e92:	cf 92       	push	r12
     e94:	df 92       	push	r13
     e96:	ef 92       	push	r14
     e98:	ff 92       	push	r15
     e9a:	0f 93       	push	r16
     e9c:	1f 93       	push	r17
     e9e:	2f 93       	push	r18
     ea0:	3f 93       	push	r19
     ea2:	4f 93       	push	r20
     ea4:	5f 93       	push	r21
     ea6:	6f 93       	push	r22
     ea8:	7f 93       	push	r23
     eaa:	8f 93       	push	r24
     eac:	9f 93       	push	r25
     eae:	af 93       	push	r26
     eb0:	bf 93       	push	r27
     eb2:	cf 93       	push	r28
     eb4:	df 93       	push	r29
     eb6:	ef 93       	push	r30
     eb8:	ff 93       	push	r31
     eba:	a0 91 cd 00 	lds	r26, 0x00CD
     ebe:	b0 91 ce 00 	lds	r27, 0x00CE
     ec2:	0d b6       	in	r0, 0x3d	; 61
     ec4:	0d 92       	st	X+, r0
     ec6:	0e b6       	in	r0, 0x3e	; 62
     ec8:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     eca:	0e 94 8c 02 	call	0x518	; 0x518 <xTaskIncrementTick>
     ece:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     ed0:	0e 94 1b 04 	call	0x836	; 0x836 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     ed4:	a0 91 cd 00 	lds	r26, 0x00CD
     ed8:	b0 91 ce 00 	lds	r27, 0x00CE
     edc:	cd 91       	ld	r28, X+
     ede:	cd bf       	out	0x3d, r28	; 61
     ee0:	dd 91       	ld	r29, X+
     ee2:	de bf       	out	0x3e, r29	; 62
     ee4:	ff 91       	pop	r31
     ee6:	ef 91       	pop	r30
     ee8:	df 91       	pop	r29
     eea:	cf 91       	pop	r28
     eec:	bf 91       	pop	r27
     eee:	af 91       	pop	r26
     ef0:	9f 91       	pop	r25
     ef2:	8f 91       	pop	r24
     ef4:	7f 91       	pop	r23
     ef6:	6f 91       	pop	r22
     ef8:	5f 91       	pop	r21
     efa:	4f 91       	pop	r20
     efc:	3f 91       	pop	r19
     efe:	2f 91       	pop	r18
     f00:	1f 91       	pop	r17
     f02:	0f 91       	pop	r16
     f04:	ff 90       	pop	r15
     f06:	ef 90       	pop	r14
     f08:	df 90       	pop	r13
     f0a:	cf 90       	pop	r12
     f0c:	bf 90       	pop	r11
     f0e:	af 90       	pop	r10
     f10:	9f 90       	pop	r9
     f12:	8f 90       	pop	r8
     f14:	7f 90       	pop	r7
     f16:	6f 90       	pop	r6
     f18:	5f 90       	pop	r5
     f1a:	4f 90       	pop	r4
     f1c:	3f 90       	pop	r3
     f1e:	2f 90       	pop	r2
     f20:	1f 90       	pop	r1
     f22:	0f 90       	pop	r0
     f24:	0f be       	out	0x3f, r0	; 63
     f26:	0f 90       	pop	r0

	asm volatile ( "ret" );
     f28:	08 95       	ret

00000f2a <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     f2a:	0e 94 39 07 	call	0xe72	; 0xe72 <vPortYieldFromTick>
		asm volatile ( "reti" );
     f2e:	18 95       	reti

00000f30 <malloc>:
     f30:	cf 93       	push	r28
     f32:	df 93       	push	r29
     f34:	82 30       	cpi	r24, 0x02	; 2
     f36:	91 05       	cpc	r25, r1
     f38:	10 f4       	brcc	.+4      	; 0xf3e <malloc+0xe>
     f3a:	82 e0       	ldi	r24, 0x02	; 2
     f3c:	90 e0       	ldi	r25, 0x00	; 0
     f3e:	e0 91 eb 00 	lds	r30, 0x00EB
     f42:	f0 91 ec 00 	lds	r31, 0x00EC
     f46:	20 e0       	ldi	r18, 0x00	; 0
     f48:	30 e0       	ldi	r19, 0x00	; 0
     f4a:	a0 e0       	ldi	r26, 0x00	; 0
     f4c:	b0 e0       	ldi	r27, 0x00	; 0
     f4e:	30 97       	sbiw	r30, 0x00	; 0
     f50:	39 f1       	breq	.+78     	; 0xfa0 <malloc+0x70>
     f52:	40 81       	ld	r20, Z
     f54:	51 81       	ldd	r21, Z+1	; 0x01
     f56:	48 17       	cp	r20, r24
     f58:	59 07       	cpc	r21, r25
     f5a:	b8 f0       	brcs	.+46     	; 0xf8a <malloc+0x5a>
     f5c:	48 17       	cp	r20, r24
     f5e:	59 07       	cpc	r21, r25
     f60:	71 f4       	brne	.+28     	; 0xf7e <malloc+0x4e>
     f62:	82 81       	ldd	r24, Z+2	; 0x02
     f64:	93 81       	ldd	r25, Z+3	; 0x03
     f66:	10 97       	sbiw	r26, 0x00	; 0
     f68:	29 f0       	breq	.+10     	; 0xf74 <malloc+0x44>
     f6a:	13 96       	adiw	r26, 0x03	; 3
     f6c:	9c 93       	st	X, r25
     f6e:	8e 93       	st	-X, r24
     f70:	12 97       	sbiw	r26, 0x02	; 2
     f72:	2c c0       	rjmp	.+88     	; 0xfcc <malloc+0x9c>
     f74:	90 93 ec 00 	sts	0x00EC, r25
     f78:	80 93 eb 00 	sts	0x00EB, r24
     f7c:	27 c0       	rjmp	.+78     	; 0xfcc <malloc+0x9c>
     f7e:	21 15       	cp	r18, r1
     f80:	31 05       	cpc	r19, r1
     f82:	31 f0       	breq	.+12     	; 0xf90 <malloc+0x60>
     f84:	42 17       	cp	r20, r18
     f86:	53 07       	cpc	r21, r19
     f88:	18 f0       	brcs	.+6      	; 0xf90 <malloc+0x60>
     f8a:	a9 01       	movw	r20, r18
     f8c:	db 01       	movw	r26, r22
     f8e:	01 c0       	rjmp	.+2      	; 0xf92 <malloc+0x62>
     f90:	ef 01       	movw	r28, r30
     f92:	9a 01       	movw	r18, r20
     f94:	bd 01       	movw	r22, r26
     f96:	df 01       	movw	r26, r30
     f98:	02 80       	ldd	r0, Z+2	; 0x02
     f9a:	f3 81       	ldd	r31, Z+3	; 0x03
     f9c:	e0 2d       	mov	r30, r0
     f9e:	d7 cf       	rjmp	.-82     	; 0xf4e <malloc+0x1e>
     fa0:	21 15       	cp	r18, r1
     fa2:	31 05       	cpc	r19, r1
     fa4:	f9 f0       	breq	.+62     	; 0xfe4 <malloc+0xb4>
     fa6:	28 1b       	sub	r18, r24
     fa8:	39 0b       	sbc	r19, r25
     faa:	24 30       	cpi	r18, 0x04	; 4
     fac:	31 05       	cpc	r19, r1
     fae:	80 f4       	brcc	.+32     	; 0xfd0 <malloc+0xa0>
     fb0:	8a 81       	ldd	r24, Y+2	; 0x02
     fb2:	9b 81       	ldd	r25, Y+3	; 0x03
     fb4:	61 15       	cp	r22, r1
     fb6:	71 05       	cpc	r23, r1
     fb8:	21 f0       	breq	.+8      	; 0xfc2 <malloc+0x92>
     fba:	fb 01       	movw	r30, r22
     fbc:	93 83       	std	Z+3, r25	; 0x03
     fbe:	82 83       	std	Z+2, r24	; 0x02
     fc0:	04 c0       	rjmp	.+8      	; 0xfca <malloc+0x9a>
     fc2:	90 93 ec 00 	sts	0x00EC, r25
     fc6:	80 93 eb 00 	sts	0x00EB, r24
     fca:	fe 01       	movw	r30, r28
     fcc:	32 96       	adiw	r30, 0x02	; 2
     fce:	44 c0       	rjmp	.+136    	; 0x1058 <malloc+0x128>
     fd0:	fe 01       	movw	r30, r28
     fd2:	e2 0f       	add	r30, r18
     fd4:	f3 1f       	adc	r31, r19
     fd6:	81 93       	st	Z+, r24
     fd8:	91 93       	st	Z+, r25
     fda:	22 50       	subi	r18, 0x02	; 2
     fdc:	31 09       	sbc	r19, r1
     fde:	39 83       	std	Y+1, r19	; 0x01
     fe0:	28 83       	st	Y, r18
     fe2:	3a c0       	rjmp	.+116    	; 0x1058 <malloc+0x128>
     fe4:	20 91 e9 00 	lds	r18, 0x00E9
     fe8:	30 91 ea 00 	lds	r19, 0x00EA
     fec:	23 2b       	or	r18, r19
     fee:	41 f4       	brne	.+16     	; 0x1000 <malloc+0xd0>
     ff0:	20 91 62 00 	lds	r18, 0x0062
     ff4:	30 91 63 00 	lds	r19, 0x0063
     ff8:	30 93 ea 00 	sts	0x00EA, r19
     ffc:	20 93 e9 00 	sts	0x00E9, r18
    1000:	20 91 60 00 	lds	r18, 0x0060
    1004:	30 91 61 00 	lds	r19, 0x0061
    1008:	21 15       	cp	r18, r1
    100a:	31 05       	cpc	r19, r1
    100c:	41 f4       	brne	.+16     	; 0x101e <malloc+0xee>
    100e:	2d b7       	in	r18, 0x3d	; 61
    1010:	3e b7       	in	r19, 0x3e	; 62
    1012:	40 91 64 00 	lds	r20, 0x0064
    1016:	50 91 65 00 	lds	r21, 0x0065
    101a:	24 1b       	sub	r18, r20
    101c:	35 0b       	sbc	r19, r21
    101e:	e0 91 e9 00 	lds	r30, 0x00E9
    1022:	f0 91 ea 00 	lds	r31, 0x00EA
    1026:	e2 17       	cp	r30, r18
    1028:	f3 07       	cpc	r31, r19
    102a:	a0 f4       	brcc	.+40     	; 0x1054 <malloc+0x124>
    102c:	2e 1b       	sub	r18, r30
    102e:	3f 0b       	sbc	r19, r31
    1030:	28 17       	cp	r18, r24
    1032:	39 07       	cpc	r19, r25
    1034:	78 f0       	brcs	.+30     	; 0x1054 <malloc+0x124>
    1036:	ac 01       	movw	r20, r24
    1038:	4e 5f       	subi	r20, 0xFE	; 254
    103a:	5f 4f       	sbci	r21, 0xFF	; 255
    103c:	24 17       	cp	r18, r20
    103e:	35 07       	cpc	r19, r21
    1040:	48 f0       	brcs	.+18     	; 0x1054 <malloc+0x124>
    1042:	4e 0f       	add	r20, r30
    1044:	5f 1f       	adc	r21, r31
    1046:	50 93 ea 00 	sts	0x00EA, r21
    104a:	40 93 e9 00 	sts	0x00E9, r20
    104e:	81 93       	st	Z+, r24
    1050:	91 93       	st	Z+, r25
    1052:	02 c0       	rjmp	.+4      	; 0x1058 <malloc+0x128>
    1054:	e0 e0       	ldi	r30, 0x00	; 0
    1056:	f0 e0       	ldi	r31, 0x00	; 0
    1058:	cf 01       	movw	r24, r30
    105a:	df 91       	pop	r29
    105c:	cf 91       	pop	r28
    105e:	08 95       	ret

00001060 <free>:
    1060:	cf 93       	push	r28
    1062:	df 93       	push	r29
    1064:	00 97       	sbiw	r24, 0x00	; 0
    1066:	09 f4       	brne	.+2      	; 0x106a <free+0xa>
    1068:	87 c0       	rjmp	.+270    	; 0x1178 <free+0x118>
    106a:	fc 01       	movw	r30, r24
    106c:	32 97       	sbiw	r30, 0x02	; 2
    106e:	13 82       	std	Z+3, r1	; 0x03
    1070:	12 82       	std	Z+2, r1	; 0x02
    1072:	c0 91 eb 00 	lds	r28, 0x00EB
    1076:	d0 91 ec 00 	lds	r29, 0x00EC
    107a:	20 97       	sbiw	r28, 0x00	; 0
    107c:	81 f4       	brne	.+32     	; 0x109e <free+0x3e>
    107e:	20 81       	ld	r18, Z
    1080:	31 81       	ldd	r19, Z+1	; 0x01
    1082:	28 0f       	add	r18, r24
    1084:	39 1f       	adc	r19, r25
    1086:	80 91 e9 00 	lds	r24, 0x00E9
    108a:	90 91 ea 00 	lds	r25, 0x00EA
    108e:	82 17       	cp	r24, r18
    1090:	93 07       	cpc	r25, r19
    1092:	79 f5       	brne	.+94     	; 0x10f2 <free+0x92>
    1094:	f0 93 ea 00 	sts	0x00EA, r31
    1098:	e0 93 e9 00 	sts	0x00E9, r30
    109c:	6d c0       	rjmp	.+218    	; 0x1178 <free+0x118>
    109e:	de 01       	movw	r26, r28
    10a0:	20 e0       	ldi	r18, 0x00	; 0
    10a2:	30 e0       	ldi	r19, 0x00	; 0
    10a4:	ae 17       	cp	r26, r30
    10a6:	bf 07       	cpc	r27, r31
    10a8:	50 f4       	brcc	.+20     	; 0x10be <free+0x5e>
    10aa:	12 96       	adiw	r26, 0x02	; 2
    10ac:	4d 91       	ld	r20, X+
    10ae:	5c 91       	ld	r21, X
    10b0:	13 97       	sbiw	r26, 0x03	; 3
    10b2:	9d 01       	movw	r18, r26
    10b4:	41 15       	cp	r20, r1
    10b6:	51 05       	cpc	r21, r1
    10b8:	09 f1       	breq	.+66     	; 0x10fc <free+0x9c>
    10ba:	da 01       	movw	r26, r20
    10bc:	f3 cf       	rjmp	.-26     	; 0x10a4 <free+0x44>
    10be:	b3 83       	std	Z+3, r27	; 0x03
    10c0:	a2 83       	std	Z+2, r26	; 0x02
    10c2:	40 81       	ld	r20, Z
    10c4:	51 81       	ldd	r21, Z+1	; 0x01
    10c6:	84 0f       	add	r24, r20
    10c8:	95 1f       	adc	r25, r21
    10ca:	8a 17       	cp	r24, r26
    10cc:	9b 07       	cpc	r25, r27
    10ce:	71 f4       	brne	.+28     	; 0x10ec <free+0x8c>
    10d0:	8d 91       	ld	r24, X+
    10d2:	9c 91       	ld	r25, X
    10d4:	11 97       	sbiw	r26, 0x01	; 1
    10d6:	84 0f       	add	r24, r20
    10d8:	95 1f       	adc	r25, r21
    10da:	02 96       	adiw	r24, 0x02	; 2
    10dc:	91 83       	std	Z+1, r25	; 0x01
    10de:	80 83       	st	Z, r24
    10e0:	12 96       	adiw	r26, 0x02	; 2
    10e2:	8d 91       	ld	r24, X+
    10e4:	9c 91       	ld	r25, X
    10e6:	13 97       	sbiw	r26, 0x03	; 3
    10e8:	93 83       	std	Z+3, r25	; 0x03
    10ea:	82 83       	std	Z+2, r24	; 0x02
    10ec:	21 15       	cp	r18, r1
    10ee:	31 05       	cpc	r19, r1
    10f0:	29 f4       	brne	.+10     	; 0x10fc <free+0x9c>
    10f2:	f0 93 ec 00 	sts	0x00EC, r31
    10f6:	e0 93 eb 00 	sts	0x00EB, r30
    10fa:	3e c0       	rjmp	.+124    	; 0x1178 <free+0x118>
    10fc:	d9 01       	movw	r26, r18
    10fe:	13 96       	adiw	r26, 0x03	; 3
    1100:	fc 93       	st	X, r31
    1102:	ee 93       	st	-X, r30
    1104:	12 97       	sbiw	r26, 0x02	; 2
    1106:	4d 91       	ld	r20, X+
    1108:	5d 91       	ld	r21, X+
    110a:	a4 0f       	add	r26, r20
    110c:	b5 1f       	adc	r27, r21
    110e:	ea 17       	cp	r30, r26
    1110:	fb 07       	cpc	r31, r27
    1112:	79 f4       	brne	.+30     	; 0x1132 <free+0xd2>
    1114:	80 81       	ld	r24, Z
    1116:	91 81       	ldd	r25, Z+1	; 0x01
    1118:	84 0f       	add	r24, r20
    111a:	95 1f       	adc	r25, r21
    111c:	02 96       	adiw	r24, 0x02	; 2
    111e:	d9 01       	movw	r26, r18
    1120:	11 96       	adiw	r26, 0x01	; 1
    1122:	9c 93       	st	X, r25
    1124:	8e 93       	st	-X, r24
    1126:	82 81       	ldd	r24, Z+2	; 0x02
    1128:	93 81       	ldd	r25, Z+3	; 0x03
    112a:	13 96       	adiw	r26, 0x03	; 3
    112c:	9c 93       	st	X, r25
    112e:	8e 93       	st	-X, r24
    1130:	12 97       	sbiw	r26, 0x02	; 2
    1132:	e0 e0       	ldi	r30, 0x00	; 0
    1134:	f0 e0       	ldi	r31, 0x00	; 0
    1136:	8a 81       	ldd	r24, Y+2	; 0x02
    1138:	9b 81       	ldd	r25, Y+3	; 0x03
    113a:	00 97       	sbiw	r24, 0x00	; 0
    113c:	19 f0       	breq	.+6      	; 0x1144 <free+0xe4>
    113e:	fe 01       	movw	r30, r28
    1140:	ec 01       	movw	r28, r24
    1142:	f9 cf       	rjmp	.-14     	; 0x1136 <free+0xd6>
    1144:	ce 01       	movw	r24, r28
    1146:	02 96       	adiw	r24, 0x02	; 2
    1148:	28 81       	ld	r18, Y
    114a:	39 81       	ldd	r19, Y+1	; 0x01
    114c:	82 0f       	add	r24, r18
    114e:	93 1f       	adc	r25, r19
    1150:	20 91 e9 00 	lds	r18, 0x00E9
    1154:	30 91 ea 00 	lds	r19, 0x00EA
    1158:	28 17       	cp	r18, r24
    115a:	39 07       	cpc	r19, r25
    115c:	69 f4       	brne	.+26     	; 0x1178 <free+0x118>
    115e:	30 97       	sbiw	r30, 0x00	; 0
    1160:	29 f4       	brne	.+10     	; 0x116c <free+0x10c>
    1162:	10 92 ec 00 	sts	0x00EC, r1
    1166:	10 92 eb 00 	sts	0x00EB, r1
    116a:	02 c0       	rjmp	.+4      	; 0x1170 <free+0x110>
    116c:	13 82       	std	Z+3, r1	; 0x03
    116e:	12 82       	std	Z+2, r1	; 0x02
    1170:	d0 93 ea 00 	sts	0x00EA, r29
    1174:	c0 93 e9 00 	sts	0x00E9, r28
    1178:	df 91       	pop	r29
    117a:	cf 91       	pop	r28
    117c:	08 95       	ret

0000117e <__itoa_ncheck>:
    117e:	bb 27       	eor	r27, r27
    1180:	4a 30       	cpi	r20, 0x0A	; 10
    1182:	31 f4       	brne	.+12     	; 0x1190 <__itoa_ncheck+0x12>
    1184:	99 23       	and	r25, r25
    1186:	22 f4       	brpl	.+8      	; 0x1190 <__itoa_ncheck+0x12>
    1188:	bd e2       	ldi	r27, 0x2D	; 45
    118a:	90 95       	com	r25
    118c:	81 95       	neg	r24
    118e:	9f 4f       	sbci	r25, 0xFF	; 255
    1190:	0c 94 cb 08 	jmp	0x1196	; 0x1196 <__utoa_common>

00001194 <__utoa_ncheck>:
    1194:	bb 27       	eor	r27, r27

00001196 <__utoa_common>:
    1196:	fb 01       	movw	r30, r22
    1198:	55 27       	eor	r21, r21
    119a:	aa 27       	eor	r26, r26
    119c:	88 0f       	add	r24, r24
    119e:	99 1f       	adc	r25, r25
    11a0:	aa 1f       	adc	r26, r26
    11a2:	a4 17       	cp	r26, r20
    11a4:	10 f0       	brcs	.+4      	; 0x11aa <__utoa_common+0x14>
    11a6:	a4 1b       	sub	r26, r20
    11a8:	83 95       	inc	r24
    11aa:	50 51       	subi	r21, 0x10	; 16
    11ac:	b9 f7       	brne	.-18     	; 0x119c <__utoa_common+0x6>
    11ae:	a0 5d       	subi	r26, 0xD0	; 208
    11b0:	aa 33       	cpi	r26, 0x3A	; 58
    11b2:	08 f0       	brcs	.+2      	; 0x11b6 <__utoa_common+0x20>
    11b4:	a9 5d       	subi	r26, 0xD9	; 217
    11b6:	a1 93       	st	Z+, r26
    11b8:	00 97       	sbiw	r24, 0x00	; 0
    11ba:	79 f7       	brne	.-34     	; 0x119a <__utoa_common+0x4>
    11bc:	b1 11       	cpse	r27, r1
    11be:	b1 93       	st	Z+, r27
    11c0:	11 92       	st	Z+, r1
    11c2:	cb 01       	movw	r24, r22
    11c4:	0c 94 01 09 	jmp	0x1202	; 0x1202 <strrev>

000011c8 <__eerd_block_m32>:
    11c8:	dc 01       	movw	r26, r24
    11ca:	cb 01       	movw	r24, r22

000011cc <__eerd_blraw_m32>:
    11cc:	fc 01       	movw	r30, r24
    11ce:	e1 99       	sbic	0x1c, 1	; 28
    11d0:	fe cf       	rjmp	.-4      	; 0x11ce <__eerd_blraw_m32+0x2>
    11d2:	06 c0       	rjmp	.+12     	; 0x11e0 <__eerd_blraw_m32+0x14>
    11d4:	ff bb       	out	0x1f, r31	; 31
    11d6:	ee bb       	out	0x1e, r30	; 30
    11d8:	e0 9a       	sbi	0x1c, 0	; 28
    11da:	31 96       	adiw	r30, 0x01	; 1
    11dc:	0d b2       	in	r0, 0x1d	; 29
    11de:	0d 92       	st	X+, r0
    11e0:	41 50       	subi	r20, 0x01	; 1
    11e2:	50 40       	sbci	r21, 0x00	; 0
    11e4:	b8 f7       	brcc	.-18     	; 0x11d4 <__eerd_blraw_m32+0x8>
    11e6:	08 95       	ret

000011e8 <__eewr_byte_m32>:
    11e8:	26 2f       	mov	r18, r22

000011ea <__eewr_r18_m32>:
    11ea:	e1 99       	sbic	0x1c, 1	; 28
    11ec:	fe cf       	rjmp	.-4      	; 0x11ea <__eewr_r18_m32>
    11ee:	9f bb       	out	0x1f, r25	; 31
    11f0:	8e bb       	out	0x1e, r24	; 30
    11f2:	2d bb       	out	0x1d, r18	; 29
    11f4:	0f b6       	in	r0, 0x3f	; 63
    11f6:	f8 94       	cli
    11f8:	e2 9a       	sbi	0x1c, 2	; 28
    11fa:	e1 9a       	sbi	0x1c, 1	; 28
    11fc:	0f be       	out	0x3f, r0	; 63
    11fe:	01 96       	adiw	r24, 0x01	; 1
    1200:	08 95       	ret

00001202 <strrev>:
    1202:	dc 01       	movw	r26, r24
    1204:	fc 01       	movw	r30, r24
    1206:	67 2f       	mov	r22, r23
    1208:	71 91       	ld	r23, Z+
    120a:	77 23       	and	r23, r23
    120c:	e1 f7       	brne	.-8      	; 0x1206 <strrev+0x4>
    120e:	32 97       	sbiw	r30, 0x02	; 2
    1210:	04 c0       	rjmp	.+8      	; 0x121a <strrev+0x18>
    1212:	7c 91       	ld	r23, X
    1214:	6d 93       	st	X+, r22
    1216:	70 83       	st	Z, r23
    1218:	62 91       	ld	r22, -Z
    121a:	ae 17       	cp	r26, r30
    121c:	bf 07       	cpc	r27, r31
    121e:	c8 f3       	brcs	.-14     	; 0x1212 <strrev+0x10>
    1220:	08 95       	ret

00001222 <_exit>:
    1222:	f8 94       	cli

00001224 <__stop_program>:
    1224:	ff cf       	rjmp	.-2      	; 0x1224 <__stop_program>
